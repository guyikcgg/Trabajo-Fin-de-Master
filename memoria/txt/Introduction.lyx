#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\master content.lyx
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Presentación del proyecto
\end_layout

\begin_layout Section
Motivación
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Here is a problem • It’s an interesting problem • It’s an unsolved problem
 • Here is my idea • My idea works (details, data) • Here’s how my idea
 compares to other people’s approaches
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe the problem • State your contributions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
IoT es muy guay, y está creciendo mucho -> Referencias académicas aquí!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
De entre todas las revoluciones de Internet, el Internet de las Cosas (
\lang english
Internet of Things
\lang spanish
, IoT) es probablemente la que tiene mayor impacto en la actualidad 
\begin_inset CommandInset citation
LatexCommand cite
key "plummer2014top,evans2011internet"

\end_inset

.
 Este nuevo paradigma, que supone la conexión masiva de dispositivos de
 uso cotidiano a Internet, posibilita la creación de nuevos servicios y
 propuestas de valor, como los 
\lang english
SmartHomes
\lang spanish
, 
\lang english
SmartCities
\lang spanish
 o la Industria
\begin_inset space ~
\end_inset

4.0 
\begin_inset CommandInset citation
LatexCommand cite
key "jeschke2017industrial"

\end_inset

.
 Muchas empresas ven nuevas oportunidades de negocio fundamentadas en
\begin_inset Note Note
status open

\begin_layout Plain Layout
/que hacen uso de
\end_layout

\end_inset

 esta tecnología.
 Así, por ejemplo, Google, IBM y Amazon tienen disponibles sus plataformas
 de computación en la nube específicas para IoT 
\begin_inset CommandInset citation
LatexCommand cite
key "pflanzner2016survey"

\end_inset

.
 Estas plataformas habilitan el desarrollo de productos y servicios que
 proporcionan valor al usuario final, como pueden ser las lámparas inteligentes
 de Phillips 
\begin_inset Quotes fld
\end_inset

hue
\begin_inset Quotes frd
\end_inset

 (
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.meethue.com/
\end_layout

\end_inset

) o el kit para SmartHome de eesy-innovation 
\begin_inset Quotes fld
\end_inset

H2
\begin_inset Quotes frd
\end_inset

 (
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.h2-smart.com/
\end_layout

\end_inset

).
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Del mismo modo, muchas otras empresas, tanto grandes (como Phillips) como
 startups (como eesy-innovation), están desarrollando productos finales
 que hacen uso de estas tecnologías habilitadoras.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sin embargo, el hecho de que los dispositivos estén conectados a la Internet,
 hace que estos sean potencialmente vulnerables a los ciberataques, que
 podrían ser perpetrados por un atacante conectado desde cualquier lugar
 del mundo.
 Estas potenciales vulnerabilidades
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, que podrían afectar directamente a los servicios, o incluso podrían usar
 los nuevos dispositivos para perpetrar un ataque de denegación de servicio
 
\begin_inset Quotes fld
\end_inset

masivo
\begin_inset Quotes frd
\end_inset

, hacen que la seguridad
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Aunque el término seguridad es muy amplio y tiene diferentes acepciones
 cuando se usa en términos informáticos, en el presente trabajo lo usaremos
 para referirnos a ciberseguridad, a menos que se indique lo contrario.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Definir ciberseguridad?
\end_layout

\end_inset


\end_layout

\end_inset

 juegue un rol imprescindible en todos los sistemas IoT.
 
\end_layout

\end_inset

 podrían afectar directamente a los servicios ofrecidos a los usuarios,
 pudiendo llegar a incurrir en daños materiales o incluso personales 
\begin_inset CommandInset citation
LatexCommand cite
key "7167238,6017172"

\end_inset

.
 Un escenario pesimista frecuentemente citado en la literatura es el uso
 de la nueva masa de dispositivos para llevar a cabo ataques de denegación
 de servicio distribuidos (
\lang english
distributed denial-of-service
\lang spanish
, DDoS), con las nefastas consecuencias que esto conllevaría
\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
 Por este motivo, la seguridad
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Aunque el término seguridad es muy amplio y tiene diferentes acepciones
 cuando se usa en términos informáticos, en el presente trabajo lo usaremos
 para referirnos a la seguridad de los datos (ciberseguridad), a menos que
 se indique lo contrario.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Definir ciberseguridad?
\end_layout

\end_inset


\end_layout

\end_inset

 juega un rol fundamental en todos los sistemas IoT, y deberá considerarse
 desde el diseño inicial del sistema.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Enlazar con objetivos y hablar de sistemas empotrados.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Muchos productos IoT son pequeños dispositivos que se basan en sistemas
 empotrados.
 Los sistemas empotrados tienen unas importantes limitaciones computacionales
 y suelen funcionar de forma independiente 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-ModernOS"

\end_inset

.
 Tal vez por esto tradicionalmente no se ha considerado la seguridad en
 términos de proteger el sistema de ataques externos.
 Sin embargo, con el nuevo paradigma IoT, muchas son las empresas que requieren
 este tipo de seguridad en sus dispositivos.
 En muchas ocasiones, esto viene impuesto por los proveedores de servicios
 de computación en la nube, como Amazon Web Services, que exige unos niveles
 de seguridad importantes en la conexión, pues solo de esta forma puede
 el sistema ser robusto y seguro.
 Por su parte, las empresas desarrolladoras de productos finales que deseen
 proporcionar un servicio IoT de calidad tendrán que ajustarse a los estándares
 impuestos por estos proveedores de servicio.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Algunas empresas se lo toman en serio.
 Uno de los referentes, AWS 
\begin_inset Note Note
status open

\begin_layout Plain Layout
buscar otros
\end_layout

\end_inset

, no permite conexiones no seguras.
 Esto fuerza a las empresas que quieran trabajar con estos proveedores de
 servicio profesionales/robustos, que quieren hacer un buen producto, a
 integrar seguridad en sus sistemas.
 Es el ejemplo de eesy innovation, que tiene una gama de productos SmartHome
 (H2) usando tecnología IoT.
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Objetivos"

\end_inset

Objetivos
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
se habla de que hay una empresa (eesy) que está desarrollando unos productos
 para IoT-SmartHome usando tecnología de Infineon (porque son partners),
 que esta empresa se preocupa por la seguridad, y que el sistema deberán
 funcionar con AWS IoT (que se ha elegido por ser una plataforma segura
 y escalable), por lo que tendremos que integrar esta plataforma y cuidar
 la seguridad de la forma que AWS especifica.
 Allí se habla de que hay una red de sensores que envía los datos a un gateway.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este trabajo fin de máster ha sido realizado en relación a un contrato concedido
 por la empresa eesy-innovation
\begin_inset Foot
status open

\begin_layout Plain Layout
No usamos mayúsculas para ajustarnos a la imagen corporativa de la empresa.
\end_layout

\end_inset

.
 eesy-innovation (
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.eesy-innovation.com/
\end_layout

\end_inset

) es una empresa alemana, con sede en Múnich, que ofrece servicios de ingeniería
 a sus numerosos socios en la industria.
 Gracias a su fuerte departamento de I+D y a su dilatada experiencia en
 electrónica y telecomunicaciones, eesy-innovation ha colaborado en proyectos
 nacionales y europeos, como TreuFunk y NexGen.
 En la actualidad, la empresa está desarrollando una solución tecnológica
 para la automatización del hogar (SmartHome).
 Su gama de productos H2 permitirá al usuario controlar, gestionar y monitorizar
 los dispositivos conectados en casa de forma remota, haciendo uso de tecnología
s IoT.
 Desde un punto de vista tecnológico, los productos H2 son sistemas embebidos
 basados en los microcontroladores 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
XMC
\end_layout

\end_inset

 de la multinacional alemana Infineon, con la que eesy-innovation colabora
 de forma continuada.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
El presente trabajo tiene como objetivo interconectar los productos de IoT
 de una empresa (eesy) con una plataforma bien conocida de IoT (AWS).
 Para ello, sera necesario integrar seguridad y conectividad a la plataforma.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El objetivo principal del presente trabajo es interconectar los dispositivos
 H2 con la nube de Amazon (Amazon Web Services IoT, AWS
\begin_inset space ~
\end_inset

IoT).
 Esto se llevará a cabo a través de un dispositivo especial que se incluye
 dentro de la gama de productos, denominado 
\emph on
H2
\begin_inset space ~
\end_inset

miniGateway
\emph default
 (o simplemente miniGW).
 Como su nombre indica, este dispositivo no es más que una puerta de enlace
 que interconecta la red de sensores y actuadores con la Nube.
 La elección de la nube de Amazon ha sido realizada por la empresa tras
 considerar una serie de factores estratégicos y tecnológicos, entre los
 que se encuentra la seguridad y la escalabilidad del sistema.
 Tras la consecución del proyecto, se espera que el miniGW integre las caracterí
sticas necesarias para comunicarse con AWS
\begin_inset space ~
\end_inset

IoT, con el nivel de seguridad que esta plataforma exige.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
integrar una implementación existente del protocolo TLS en la pasarela (gateway)
 que interconecta los sensores y actuadores de H2 con Internet.
 De este modo, conseguiremos que la transmisión de datos entre la red de
 sensores y la nube se lleve a cabo de forma segura
\begin_inset Note Note
status open

\begin_layout Plain Layout
, permitiendo que el usuario y la casa se sientan seguros ;)
\end_layout

\end_inset

.
 Como objetivo adicional, planteamos la interconexión de la pasarela con
 la nube de Amazon para IoT (Amazon Web Services IoT, AWS
\begin_inset space ~
\end_inset

IoT).
 De esta forma, que 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
De forma más concreta, los objetivos perseguidos en este trabajo fin de
 máster son los siguientes:
\end_layout

\begin_layout Enumerate
Estudio de los conceptos de seguridad en redes, en especial los que aplican
 a sistemas empotrados y al nuevo paradigma de IoT.
 Breve presentación de TLS y de X.509.
\end_layout

\begin_layout Enumerate
Análisis de las implementaciones TLS para sistemas empotrados y elección
 de una de ellas.
\end_layout

\begin_layout Enumerate
Integración de la biblioteca TLS seleccionada en el sistema objetivo (miniGW).
\end_layout

\begin_layout Enumerate
Estudio y presentación de la nube AWS
\begin_inset space ~
\end_inset

IoT.
\begin_inset Note Note
status open

\begin_layout Plain Layout
 Breve presentación de MQTT.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Integración del AWS
\begin_inset space ~
\end_inset

IoT Device SDK en el sistema objetivo.
 Realización de una prueba de concepto.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
La pasarela está diseñada entorno a un microcontrolador XMC4500 de Infineon,
 que a su vez está basado en un núcleo ARM Cortex-M3.
 Esta pasarela deberá comunicarse con la nube de Amazon AWS IoT, con la
 que intercambiará mensajes mediante el protocolo MQTT.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Section
Metodología de trabajo
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Mencionar que se ha ido entregando el trabajo en entregables, y que el objetivo
 es tener una demo, y un manual para facilitar la integración en el sistema
 final
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
primero pc y luego microcontrolador
\end_layout

\begin_layout Plain Layout
Tests a cada paso
\end_layout

\begin_layout Plain Layout
El proyecto ha sido puesto bajo control de versiones, usando Git.
 Los sistemas de control de versiones permiten conservar un registro histórico
 de las acciones realizadas, pudiendo volver a estados pasados cuando se
 desee.
 Otra de las ventajas de usar un control de versiones es la posibilidad
 de crear ramas para gestionar las distintas características del proyecto.
 En este trabajo, para cada nueva línea de investigación se ha creado una
 rama, uniéndose los beneficios obtenidos a las ramas comunes.
 En concreto, el sistema de ramificaciones está basado en 
\begin_inset CommandInset citation
LatexCommand cite
key "Successful-Git"

\end_inset

.
 Git es además un sistema distribuido, siendo muy sencillo crear un repositorio
 de trabajo y compartirlo para permitir el trabajo en equipo, fundamental
 en cualquier ámbito de desarrollo, ya sea software o hardware.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Fácil integración con el resto del código del gateway: Diseño modular +
 control de versiones
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
IDE: DAVE (ver 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Entorno-de-trabajo"

\end_inset

)
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Decir que se han entregado reports y código a la empresa de forma periódica,
 que el trabajo se ha realizado bajo su supervisión.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Estructura de la memoria
\end_layout

\begin_layout Standard
La memoria se estructura en tres grandes partes, que describimos a continuación.
\end_layout

\begin_layout Subsubsection
Fundamentos teóricos y presentación de la tecnología
\end_layout

\begin_layout Standard
La primera parte está dedicada 
\begin_inset Note Note
status open

\begin_layout Plain Layout
a una breve introducción y
\end_layout

\end_inset

 a la presentación de las bases teóricas que permitirán una mejor comprensión
 del desarrollo del proyecto.
\end_layout

\begin_layout Standard
En primer lugar, llevaremos a cabo una exposición de los principios básicos
 de seguridad (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Principios-seguridad"

\end_inset

), prestando especial atención a los requisitos de seguridad en sistemas
 empotrados (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Seguridad-en-sist-empotrados"

\end_inset

).
\end_layout

\begin_layout Standard
A continuación presentaremos brevemente el protocolo TLS (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:TLS"

\end_inset

), los certificados digitales X.509 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:X509"

\end_inset

) y la estructura de la nube de Amazon AWS
\begin_inset space ~
\end_inset

IoT (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:AWS-IoT"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Trabajo realizado
\end_layout

\begin_layout Standard
En la segunda parte desarrollaremos con detalle el trabajo realizado durante
 la consecución de este proyecto.
\end_layout

\begin_layout Standard
Comenzaremos esta parte con una presentación pormenorizada del sistema objetivo
 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Descripción-del-sistema"

\end_inset

), a la que seguirá el análisis de las implementaciones TLS existentes y
 se justificará la elección de mbedTLS (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Análisis-implementacions-TLS"

\end_inset

).
\end_layout

\begin_layout Standard
También presentaremos aquí los detalles de la integración de TLS en el sistema,
 así como los problemas que hemos tenido que resolver durante la misma (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementación-TLS"

\end_inset

).
 Pondremos fin a esta parte con los detalles de la integración del Kit de
 Desarrollo de Software para dispositivos embebidos programados en
\begin_inset space ~
\end_inset

C de Amazon, 
\lang english
AWS
\begin_inset space ~
\end_inset

IoT Device
\begin_inset space ~
\end_inset

SDK for embedded
\begin_inset space ~
\end_inset

C
\lang spanish
 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementación-AWS-IoT"

\end_inset

).
 En cada uno de estos capítulos explicaremos las verificaciones y tests
 llevados a cabo, exponiendo los resultados obtenidos y planteando los problemas
 que hemos enfrentado.
\end_layout

\begin_layout Subsubsection
Conclusiones y trabajo futuro
\end_layout

\begin_layout Standard
Para terminar, presentaremos las conclusiones obtenidas de la realización
 de este proyecto y disertaremos acerca de las posibles mejoras que podemos
 llevar a cabo en nuestro sistema (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Conclusiones-y-trabajo-futuro"

\end_inset

)
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
incluyendo una prueba de concepto en la que veremos la comunicación entre
 el dispositivo y la nube IoT (capítulo
\begin_inset space ~
\end_inset

#)
\end_layout

\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 También expondremos las futuras líneas de trabajo (capítulo
\begin_inset space ~
\end_inset

#).
\end_layout

\end_inset


\end_layout

\begin_layout Part
Fundamentos teóricos y presentación de la tecnología
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Principios-seguridad"

\end_inset

Principios básicos de criptografía
\end_layout

\begin_layout Standard
El propósito de la criptografía es convertir un mensaje o fichero (
\emph on
texto plano
\emph default
) en algo que a priori carece de sentido (
\emph on
criptograma
\emph default
), de forma que solo las personas autorizadas pueden realizar la transformación
 inversa para acceder al contenido original.
 La operación de transformar el texto plano en un criptograma es conocida
 como 
\emph on
encriptación
\emph default
 o 
\emph on
cifrado
\emph default
, mientras que la operación inversa se denomina 
\emph on
desencriptación
\emph default
 o 
\emph on
descifrado
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Por su similitud al idioma anglosajón, preferiremos los términos encriptación
 (
\lang english
encryption
\lang spanish
) y desencriptación (
\lang english
decryption
\lang spanish
), a pesar de la disonancia de los mismos.
\end_layout

\end_inset

.
 Al contrario de lo que nos dice la intuición, uno de los fundamentos de
 la criptografía moderna, el principio de Kerckhoff, afirma que los algoritmos
 de cifrado y descifrado deben ser públicos.
 El uso de algoritmos secretos es una táctica conocida como 
\emph on
seguridad por oscuridad
\emph default
, y suele acarrear severos problemas de seguridad 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-ModernOS"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
 En su lugar, el único elemento que debe permanecer en secreto es la 
\emph on
clave
\emph default
, que se usa como parámetro de entrada en los algoritmos de cifrado y descifrado.
 De este modo, aunque los algoritmo de cifrado y descifrado sean conocidos,
 un potencial atacante que tenga acceso al criptograma no podrá descifrar
 el mensaje original si no posee la clave.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Introducir Two fundamental cryptographic principles: redundancy and freshness
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
La seguridad de un sistema criptográfico puede estudiarse 
\end_layout

\begin_layout Plain Layout
Para que un sistema criptográfico sea considerado seguro, este debe abordar
 una serie de problemasque le confieran las características listadas a continuac
ión.
\end_layout

\begin_layout Description
Confidencialidad los mensajes no deberán 
\end_layout

\begin_layout Plain Layout
que impidan deducir el contenido del mensaje a partir del criptograma (confidenc
ialidad), que per.
 También se deben evitar otros tipos de ataque, como replay attacks, etc
 (ver sección
\begin_inset space ~
\end_inset

#Requisitos generales de seguridad#).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A continuación formalizaremos los procesos de encriptación y desencriptación.
 Esto será útil para discurrir acerca de las diferentes técnicas de cifrado
 de las que haremos uso en este trabajo.
 Llamemos 
\begin_inset Formula $P$
\end_inset

 al texto plano, 
\begin_inset Formula $K_{E}$
\end_inset

 a la clave de encriptación, 
\begin_inset Formula $C$
\end_inset

 al criptograma y 
\begin_inset Formula $E$
\end_inset

 al algoritmo o función de encriptación.
 De esta forma, podemos definir el proceso de encriptación con la ecuación
 
\begin_inset Formula $C=E\left(P,K_{E}\right)$
\end_inset

.
 Esto sugiere que para obtener el criptograma es necesario aplicar el algoritmo
 de encriptación sobre el texto plano y la clave de encriptación, que son
 tomados como parámetros.
 De forma similar, podemos definir el proceso de desencriptación con la
 ecuación 
\begin_inset Formula $P=D\left(C,K_{D}\right)$
\end_inset

, donde 
\begin_inset Formula $D$
\end_inset

 es el algoritmo de desencriptación y 
\begin_inset Formula $K_{D}$
\end_inset

 es la clave de desencriptación, que puede sr distinta a la clave de encriptació
n.
 Esto indica que la obtención del texto plano a partir del criptograma pasa
 por aplicar la función de desencriptación a este criptograma, tomando como
 segundo parámetro la clave de desencriptación.
 La relación entre estas operaciones queda ilustrada en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Relacion-plaintext-ciphertext"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/relacion-plain-cipher.eps
	lyxscale 80
	width 86col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Relacion-plaintext-ciphertext"

\end_inset

Relación entre el texto plano y el texto cifrado.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aunque existe una multitud de algoritmos de encriptación y desencriptación
 disponibles, todos ellos caen en alguna de estas dos categorías: criptografía
 de clave simétrica y criptografía de clave pública.
 Estos dos tipos de cifrado se expondrán con detalle en los siguientes epígrafes.
\end_layout

\begin_layout Section
Criptografía de clave simétrica
\end_layout

\begin_layout Standard
Los algoritmos de cifrado 
\emph on
de clave simétrica
\emph default
 son llamados así porque usan la misma clave en la encriptación y en la
 desencriptación.
 La 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:symmetric-ciphers"

\end_inset

 describe algunas características de los algoritmos criptográficos de clave
 simétrica más conocidos, entre los que se encuentran DES (
\lang english
Data Encription Standard
\lang spanish

\begin_inset Index idx
status open

\begin_layout Plain Layout
Data Encription Standard (DES)
\end_layout

\end_inset

) y AES (
\lang english
Advanced Encription Standard
\lang spanish

\begin_inset Index idx
status open

\begin_layout Plain Layout
Advanced Encription Standard (AES)
\end_layout

\end_inset

).
 A continuación presentaremos los fundamentos de los algoritmos de 
\emph on
cifrado por bloques
\emph default
, que consiste en encriptar el texto plano dividiéndolo en bloques de 
\begin_inset Formula $n$
\end_inset

 bits, produciendo así el criptograma en bloques de la misma longitud.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Algoritmo de cifrado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Autor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Longitud de clave
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Comentarios
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
DES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
IBM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
56 bits
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Vulnerable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
RC4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Ronald Rivest
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1-2048 bits
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Algunas claves vulnerables
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
RC5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Ronald Rivest
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
128-256 bits
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Bueno, pero patentado
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
AES (Rijndael)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Daemen and Rijmen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
128-256 bits
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Mejor elección
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Triple DES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
IBM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
168 bits
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Bueno, pero antiguo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Twofish
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Bruce Schneier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
128-256 bits
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Muy robusto y usado
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:symmetric-ciphers"

\end_inset

Algunos de los algoritmos de clave simétrica más comunes 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Los algoritmos de cifrado por bloques pueden implementarse en hardware (para
 mayor velocidad) o en software (mayor flexibilidad).
 A continuación tratamos algunos aspectos de implementación en hardware
 para ilustrar los principios del cifrado por bloques.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para ilustrar los principios del cifrado por bloques, recurriremos a algunos
 aspectos de su implementación en hardware.
 De este modo, podemos decir que que cualquier método de cifrado por bloques
 puede descomponerse en una sucesión de dos elementos hardware muy sencillos:
 las 
\emph on
cajas de permutación
\emph default
 (P-box) y las 
\emph on
cajas de sustitución
\emph default
 (S-box), que se ilustran en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:P-box,S-box"

\end_inset

.
\end_layout

\begin_layout Standard
Las cajas de permutación producen una reordenación entre los bits de su
 entrada y de su salida, sin modificar el número de ceros o de unos presentes.
 Esto puede conseguirse a través de un cableado arbitrario entre cada uno
 de los bits de entrada y de salida.
 De esta forma, la operación de permutación solo requiere la propagación
 de la señal, que se lleva a cabo sin coste computacional alguno.
 Una caja de permutación correctamente diseñada será capaz de efectuar cualquier
 permutación deseada reconfigurando su cableado.
 Como puede comprobarse, las cajas de permutación obedecen al principio
 de Kerckhoff: el método utilizado (la permutación de bits) es público,
 lo que se reserva es el orden en que se realiza este cableado, que hará
 las veces de clave.
\end_layout

\begin_layout Standard
Por otro lado, las cajas de sustitución cuentan con tres etapas.
 La primera de ellas es un decodificador, que en este ejemplo es de 3 bits,
 por lo que se seleccionará una de las 8 líneas, estableciéndose el valor
 de esta a 1 y permaneciendo el resto a 0.
 La segunda etapa es una P-box.
 La tercera etapa codifica la línea de entrada seleccionada nuevamente a
 binario.
 Con el cableado mostrado, la secuencia de entrada compuesta por los números
 octales 01234567 producirá la secuencia de salida 24506713.
 De nuevo, mediante el cableado apropiado de la P-box dentro de la S-box,
 se puede realizar cualquier sustitución.
 Además, la implementación hardware de este dispositivo requiere muy pocas
 puertas lógicas, por lo que es posible lograr una gran velocidad, con un
 tiempo de propagación muy inferior al nanosegundo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/block-ciphers.eps
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:P-box,S-box"

\end_inset

Elementos básicos del cifrado por bloques 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
 (a)
\begin_inset space ~
\end_inset

P-box.
 (b)
\begin_inset space ~
\end_inset

S-box.
 (c)
\begin_inset space ~
\end_inset

Producto.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Cualquier método de cifrado por bloques puede verse como un diccionario
 que relaciona de forma única todas las posibles combinaciones de 
\begin_inset Formula $n$
\end_inset

 bits de texto plano con otra combinación (normalmente distinta) del mismo
 número de bits en el criptograma.
 De este modo, podemos decir que, 
\end_layout

\begin_layout Plain Layout
En su modo de operación más básico, cualquier cifrado por bloques actúa
 como un diccionario que permite 
\begin_inset Quotes fld
\end_inset

traducir
\begin_inset Quotes frd
\end_inset

 cualquier bloque de texto plano a otro bloque de la misma longitud del
 criptograma.
 Cuando los bloques 
\end_layout

\begin_layout Plain Layout
Dentro de esta categoría podemos distinguir dos estrategias: por un lado,
 tenemos el cifrado por bloques, que opera sobre bloques de un número 
\begin_inset Formula $n$
\end_inset

 de bits de texto plano, produciendo el criptograma en bloques de la misma
 longitud.
 Por otro lado, tenemos el cifrado de flujo, en los que los dígitos del
 texto plano se combinan con dígitos pseudoaleatorios where plaintext digits
 are combined with a pseudorandom cipher digit stream (keystream).
 In a stream cipher, each plaintext digit is encrypted one at a time with
 the corresponding digit of the keystream, to give a digit of the ciphertext
 stream
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Modos de cifrado
\end_layout

\begin_layout Subsubsection
Modo Electronic Code Book (ECB)
\end_layout

\begin_layout Standard
Cualquier método de cifrado por bloques, sin importar lo complejo que sea,
 puede verse como un diccionario que relaciona de forma única todas las
 posibles combinaciones de 
\begin_inset Formula $n$
\end_inset

 bits de texto plano con otra combinación (normalmente distinta) del mismo
 número de bits en el criptograma.
 De este modo, podemos decir que cualquier cifrado por bloques actúa como
 un 
\begin_inset Quotes fld
\end_inset

diccionario
\begin_inset Quotes frd
\end_inset

 que permite traducir, en función de la clave utilizada, cualquier bloque
 de texto plano a otro bloque de la misma longitud del criptograma.
\end_layout

\begin_layout Standard
Cuando el algoritmo de cifrado actúa del modo descrito diremos que se está
 usando el modo de cifrado conocido como 
\lang english
Electronic Code Book
\lang spanish
.
 Este modo es el más directo y el más eficiente en su implementación.
 Sin embargo, presenta una vulnerabilidad, que se hace más importante cuanto
 menor es tamaño del bloque.
 Puesto que un bloque de texto plano determinado siempre dará como resultado
 el mismo bloque de criptograma, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
de manera que 
\end_layout

\end_inset

la confidencialidad puede verse comprometida por ataques basados en criptoanális
is, como se muestra en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Comparacion-modos-cifrado"

\end_inset

.
 Además de la confidencialidad, este modo de cifrado puede sufrir de ataques
 de reproducción (
\lang english
replay attacks
\lang spanish
) si no se toman medidas para evitarlos.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Tux.jpg
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Tux_ecb.jpg
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/Tux_secure.jpg
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Comparacion-modos-cifrado"

\end_inset

Comparación entre los modos de cifrado por bloques 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki:tux"

\end_inset

.
 (a) Imagen sin cifrar (texto plano).
 (b) Imagen encriptada usando el modo ECB (vulnerable a ataques de criptoanálisi
s).
 (c) Imagen encriptada usando otro modo de cifrado (se consigue un criptograma
 pseudo-aleatorio).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Modo Cipher Block Chaining (CBC)
\end_layout

\begin_layout Standard
Para evitar este tipo de ataques, todos los cifrados por bloque se pueden
 encadenar de varias formas.
 Una de estas formas es la conocida como 
\lang english
Cipher Block Chaining
\lang spanish
 (CBC).
 Con este método, mostrado en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:CBC-mode"

\end_inset

, cada bloque de texto plano es mezclado con el bloque de criptograma anterior
 antes de ser encriptado.
 Esto se consigue gracias a la función XOR y sus interesantes propiedades.
 Por consiguiente, un mismo bloque de texto plano ya no se traduce al mismo
 bloque de criptograma, y el cifrado ya no es un diccionario de sustitución
 monoalfabético.
 El primer bloque se mezcla (XOR) con un vector de inicialización (
\lang english
initialization vector
\lang spanish
, IV) elegido al azar, que se transmite, en texto plano, junto con el texto
 cifrado.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/CBC-mode-tanenbaum.eps
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:CBC-mode"

\end_inset

Modo de encriptación Cipher Block Chaining 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
 (a) Encriptación.
 (b) Desencriptación.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Podemos ver cómo funciona el modo CBC examinando el ejemplo de la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:CBC-mode"

\end_inset

.
 Comenzamos calculando 
\begin_inset Formula $C_{0}=E(P_{0}\:\mathrm{XOR}\:IV)$
\end_inset

.
 Luego calculamos 
\begin_inset Formula $C_{1}=E(P_{1}\:\mathrm{XOR}\:C_{0})$
\end_inset

, y así sucesivamente.
 El proceso de desencriptación también usa XOR para revertir el proceso,
 con 
\begin_inset Formula $P_{0}=IV\:\mathrm{XOR}\:D(C_{0})$
\end_inset

, y así sucesivamente.
 Cabe destacar que el cifrado del bloque 
\begin_inset Formula $i$
\end_inset

 es una función de todo el texto plano en los bloques 
\begin_inset Formula $0$
\end_inset

 a 
\begin_inset Formula $i-1$
\end_inset

, por lo que el mismo bloque de texto plano genera un criptograma diferente
 dependiendo de dónde se encuentre en el mensaje.
 En este caso, un ataque que consista en modificar un bloque del criptograma
 producirá un mensaje sin sentido a partir del bloque modificado cuando
 el mensaje se desencripte.
 El modo CBC también tiene la ventaja de que el mismo bloque de texto plano
 no dará como resultado el mismo bloque de criptograma, lo que hace que
 el criptoanálisis sea mucho más difícil.
\end_layout

\begin_layout Subsubsection
Otros modos de cifrado
\end_layout

\begin_layout Standard
Existen otros modos de cifrado además de los presentados aquí.
 Todos ellos tienen la ventaja, al igual que CBC, de producir una salida
 pseudo-aleatoria, que complica el criptoanálisis.
 Sin embargo, existen diferencias significativas entre ellos.
 Por ejemplo, el modo de cifrado por contador (CTR) no encadena los bloques
 de texto plano mezclándolos con el criptograma anterior, sino que usa un
 IV que se incrementa con cada bloque.
 De esta forma, CTR produce una salida pseudo-aleatoria, permitiendo el
 acceso no secuencial a la información, siempre y cuando se disponga de
 la clave, el IV inicial y el número de secuencia.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Otra alternativa es el cifrado de flujo (stream cipher), que consiste en
 mezclar el texto plano con una secuencia pseudo-aleatoria conseguida mediante
 el cifrado en cadena de 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Criptografía de clave pública
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
USADA PARA INTERCAMBIAR CLAVES PARA CRIPTOGRAFÍA SIMÉTRICA, QUE ES MÁS EFICIENTE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La criptografía 
\emph on
de clave pública
\emph default
, también conocida como criptografía asimétrica, parte de la idea de tener
 dos claves distintas para encriptar y para desencriptar.
 De este modo, tendremos un algoritmo de encriptación 
\begin_inset Formula $E$
\end_inset

, parametrizado con la clave 
\begin_inset Formula $K_{E}$
\end_inset

, y un algoritmo de desencriptación 
\begin_inset Formula $D$
\end_inset

, parametrizado con la clave 
\begin_inset Formula $K_{D}$
\end_inset

.
 Los algoritmos criptográficos de clave pública deben cumplir ciertas propiedade
s para garantizar la confidencialidad de los mensajes enviados, y son las
 que siguen 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $D\left(E\left(P\right)\right)=P$
\end_inset

.
\end_layout

\begin_layout Enumerate
Es extremadamente difícil deducir 
\begin_inset Formula $D$
\end_inset

 a partir de 
\begin_inset Formula $E$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $E$
\end_inset

 debe resistir ataques de texto plano escogido (
\lang english
chosen-plaintext attack
\lang spanish
).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
El primer requisito dice que si aplicamos 
\begin_inset Formula $D$
\end_inset

 a un mensaje encriptado, 
\begin_inset Formula $E(P)$
\end_inset

, obtendremos el mensaje en texto plano original, 
\begin_inset Formula $P$
\end_inset

.
 Sin esta propiedad, el receptor legítimo no podría descifrar el criptograma.
 El segundo requisito habla por sí mismo.
 El tercer requisito es necesario porque, como veremos en un momento, los
 intrusos pueden experimentar con el algoritmo al contenido de sus corazones.
 En estas condiciones, no hay ninguna razón para que la clave de cifrado
 no pueda hacerse pública.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
El método funciona así.
 Una persona, por ejemplo, Alice, que quiere recibir mensajes secretos,
 primero crea dos algoritmos que cumplen los requisitos anteriores.
 El algoritmo de encriptación y la clave de Alice se hacen públicos
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
, de ahí el nombre de criptografía de clave pública.
 Alice podría poner su clave pública en su página de inicio en la Web, por
 ejemplo.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Veamos cómo funciona la criptografía de clave pública con un ejemplo sencillo.
 En este ejemplo tendremos dos nodos que nunca han establecido comunicación
 entre sí, pero que desean comunicarse de forma segura.
 Como suele hacerse en criptografía, llamaremos 
\emph on
Alice
\emph default
 al primer nodo, y 
\emph on
Bob
\emph default
 al segundo.
 Utilizaremos la notación 
\begin_inset Formula $E_{A}$
\end_inset

 para referirnos al algoritmo de encriptación parametrizado por la clave
 pública de Alice.
 De manera similar, el algoritmo de desencriptación (secreto) parametrizado
 por la clave privada de Alice será denominado 
\begin_inset Formula $D_{A}$
\end_inset

.
 Bob hace lo mismo, publicando 
\begin_inset Formula $E_{B}$
\end_inset

 pero manteniendo 
\begin_inset Formula $D_{B}$
\end_inset

 en secreto.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Ahora veamos si podemos resolver el problema de establecer un canal seguro
 entre Alice y Bob, que nunca tuvieron contacto previo.
\end_layout

\end_inset

 Se supone que tanto la clave de encriptación de Alice, 
\begin_inset Formula $E_{A}$
\end_inset

, como la clave de cifrado de Bob, 
\begin_inset Formula $E_{B}$
\end_inset

, se encuentran en archivos de lectura pública.
 Ahora Alice toma su primer mensaje, 
\begin_inset Formula $P$
\end_inset

, calcula 
\begin_inset Formula $E_{B}(P)$
\end_inset

 y lo envía a Bob.
 Bob lo descifra aplicando su clave secreta 
\begin_inset Formula $D_{B}$
\end_inset

 (es decir, calcula 
\begin_inset Formula $D_{B}(E_{B}(P))=P$
\end_inset

).
 Nadie más puede leer el mensaje encriptado, 
\begin_inset Formula $E_{B}(P)$
\end_inset

, porque se supone que el sistema de cifrado es robusto y porque es demasiado
 difícil derivar 
\begin_inset Formula $D_{B}$
\end_inset

 a partir de 
\begin_inset Formula $E_{B}$
\end_inset

, que es la única clave de Bob conocida públicamente.
 Para enviar una respuesta, 
\begin_inset Formula $R$
\end_inset

, Bob transmite 
\begin_inset Formula $E_{A}(R)$
\end_inset

.
 Alice y Bob ahora pueden comunicarse de forma segura.
\end_layout

\begin_layout Standard
Como vemos, la criptografía de clave pública requiere que cada usuario tenga
 dos claves: una clave pública, utilizada por todo el mundo para encriptar
 los mensajes que se enviarán a ese usuario, y una clave privada, que el
 usuario necesita para descifrar los mensajes.
 Constantemente nos referiremos a estas claves como las claves pública y
 privada, respectivamente, y las distinguiremos de las claves secretas utilizada
s para la criptografía de clave simétrica convencional 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
\end_layout

\begin_layout Standard
Encontrar algoritmos que satisfagan los tres requisitos mencionados anteriorment
e no es fácil, pero existen algunos algoritmos publicados con estas propiedades.
 Uno de los más conocidos y usados hoy en día es RSA, descubierto en el
 MIT en los años 1970, y que toma el nombre de las iniciales de sus tres
 descubridores: Rivest, Shamir y Adleman 
\begin_inset CommandInset citation
LatexCommand cite
key "rivest1978method"

\end_inset

.
 RSA basa su seguridad en la dificultad de factorizar números muy grandes,
 en especial cuando estos son el producto de números primos elevados.
 A pesar de todos los intentos de romper su seguridad, RSA ha demostrado
 ser un algoritmo seguro y robusto durante más de 30 años.
 Su mayor desventaja es que requiere claves de al menos 1024 bits para una
 buena seguridad (frente a 128 bits para algoritmos de clave simétrica),
 lo que lo hace bastante lento.
 Por este motivo, muchos protocolos de seguridad solo usan criptografía
 de clave pública para realizar el intercambio seguro de una clave privada,
 pasando luego a comunicarse con criptografía simétrica, a través de un
 algoritmo parametrizado con esta clave.
\end_layout

\begin_layout Standard
Otros esquemas de clave pública se basan en la dificultad de calcular logaritmos
 discretos 
\begin_inset CommandInset citation
LatexCommand cite
key "elgamal1985public,schnorr1991efficient"

\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Los algoritmos que usan este principio han sido inventados por El
\begin_inset space ~
\end_inset

Gamal 
\begin_inset CommandInset citation
LatexCommand cite
key "elgamal1985public"

\end_inset

 y Schnorr 
\begin_inset CommandInset citation
LatexCommand cite
key "schnorr1991efficient"

\end_inset

.
\end_layout

\end_inset

 Existen algunos otros esquemas, como los basados en curvas elípticas 
\begin_inset CommandInset citation
LatexCommand cite
key "menezes1993reducing"

\end_inset

, que están disfrutando de una gran popularidad en nuestros días gracias
 a su eficiencia relativamente alta, pues son capaces de obtener niveles
 de seguridad equivalentes con claves más cortas.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
La distribución de claves es un proceso que exige suma precaución, pudiendo
 llegar a ser el eslabón más débil de un criptosistemas.
 No importa lo fuerte que sea un algoritmo de cifrado, si un intruso puede
 robar la clave, el sistema no tiene valor.
 Tradicionalmente la clave de cifrado y la clave de descifrado son la misma
 (o pueden derivarse fácilmente una de la otra).
 Pero la clave tenía que ser distribuida a todos los usuarios del sistema.
 Por lo tanto, parecía como si hubiera un problema inherente.
 Las llaves debían protegerse contra el robo, pero también debían distribuirse
 para que no pudieran encerrarse en la bóveda de un banco.
\end_layout

\begin_layout Plain Layout
En 1976, dos investigadores de la Universidad de Stanford, Diffie y Hellman
 (1976), propusieron un tipo de criptosistema radicalmente nuevo, en el
 que las claves de cifrado y descifrado eran tan diferentes que la clave
 de desencriptado no podía derivarse de la clave de cifrado.
 En su propuesta, el algoritmo de encriptación (con clave), E, y el algoritmo
 de descifrado (con clave), D, tenían que cumplir tres requisitos.
 Estos requisitos se pueden expresar de la siguiente manera:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Historically, distributing the keys has always been the weakest link in
 most cryptosystems.
 No matter how strong a cryptosystem was, if an intruder could steal the
 key, the system was worthless.
 Cryptologists always took for granted that the encryption key and decryption
 key were the same (or easily derived from one another).
 But the key had to be distributed to all users of the system.
 Thus, it seemed as if there was an inherent problem.
 Keys had to be protected from theft, but they also had to be distributed,
 so they could not be locked in a bank vault.
 
\end_layout

\begin_layout Plain Layout
In 1976, two researchers at Stanford University, Diffie and Hellman (1976),
 proposed a radically new kind of cryptosystem, one in which the encryption
 and decryption keys were so different that the decryption key could not
 feasibly be derived from the encryption key.
 In their proposal, the (keyed) encryption algo- rithm, E, and the (keyed)
 decryption algorithm, D, had to meet three requirements.
 These requirements can be stated simply as follows:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The first requirement says that if we apply D to an encrypted message, E(P),
 we get the original plaintext message, P, back.
 Without this property, the legitimate receiver could not decrypt the ciphertext.
 The second requirement speaks for it- self.
 The third requirement is needed because, as we shall see in a moment, in-
 truders may experiment with the algorithm to their hearts’ content.
 Under these conditions, there is no reason that the encryption key cannot
 be made public.
\end_layout

\begin_layout Plain Layout
The method works like this.
 A person, say, Alice, who wants to receive secret messages, first devises
 two algorithms meeting the above requirements.
 The en- cryption algorithm and Alice’s key are then made public, hence
 the name public- key cryptography.
 Alice might put her public key on her home page on the Web, for example.
 We will use the notation E A to mean the encryption algorithm parameterized
 by Alice’s public key.
 Similarly, the (secret) decryption algorithm parameterized by Alice’s private
 key is D A .
 Bob does the same thing, publicizing E B but keeping D B secret.
\end_layout

\begin_layout Plain Layout
Now let us see if we can solve the problem of establishing a secure channel
 between Alice and Bob, who have never had any previous contact.
 Both Alice’s encryption key, E A , and Bob’s encryption key, E B , are
 assumed to be in publicly readable files.
 Now Alice takes her first message, P, computes E B (P), and sends it to
 Bob.
 Bob then decrypts it by applying his secret key D B [i.e., he computes D
 B (E B (P)) = P].
 No one else can read the encrypted message, E B (P), because the encryption
 system is assumed to be strong and because it is too difficult to derive
 D B from the publicly known E B .
 To send a reply, R, Bob transmits E A (R).
 Alice and Bob can now communicate securely.
\end_layout

\begin_layout Plain Layout
A note on terminology is perhaps useful here.
 Public-key cryptography re- quires each user to have two keys: a public
 key, used by the entire world for en- crypting messages to be sent to that
 user, and a private key, which the user needs for decrypting messages.
 We will consistently refer to these keys as the public and private keys,
 respectively, and distinguish them from the secret keys used for conventional
 symmetric-key cryptography.
\end_layout

\begin_layout Plain Layout
RSA
\end_layout

\begin_layout Plain Layout
The only catch is that we need to find algorithms that indeed satisfy all
 three requirements.
 Due to the potential advantages of public-key cryptography, many researchers
 are hard at work, and some algorithms have already been published.
 One good method was discovered by a group at M.I.T.
 (Rivest et al., 1978).
 It is known by the initials of the three discoverers (Rivest, Shamir, Adleman):
 RSA.
 It has survived all attempts to break it for more than 30 years and is
 considered very strong.
 Much practical security is based on it.
 For this reason, Rivest, Shamir, and Adleman were given the 2002 ACM Turing
 Award.
 Its major disadvantage is that it requires keys of at least 1024 bits for
 good security (versus 128 bits for symmetric-key algorithms), which makes
 it quite slow.
\end_layout

\begin_layout Plain Layout
Other Public-Key Algorithms
\end_layout

\begin_layout Plain Layout
Other public-key schemes are based on the difficulty of computing discrete
 logarithms.
 Algorithms that use this principle have been invented by El Gamal (1985)
 and Schnorr (1991).
\end_layout

\begin_layout Plain Layout
A few other schemes exist, such as those based on elliptic curves (Menezes
 and Vanstone, 1993), but the two major categories are those based on the
 diffi- culty of factoring large numbers and computing discrete logarithms
 modulo a large prime.
 These problems are thought to be genuinely difficult to solve— mathematicians
 have been working on them for many years without any great breakthroughs.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Firmas digitales
\begin_inset Index idx
status open

\begin_layout Plain Layout
firma digital
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
digital signature
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The authenticity of many legal, financial, and other documents is determined
 by the presence or absence of an authorized handwritten signature.
 And photocopies do not count.
 For computerized message systems to replace the physical transport of paper-and
-ink documents, a method must be found to allow documents to be signed in
 an unforgeable way.
\end_layout

\begin_layout Plain Layout
The problem of devising a replacement for handwritten signatures is a diffi-
 cult one.
 Basically, what is needed is a system by which one party can send a signed
 message to another party in such a way that the following conditions hold:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las firmas tradicionales se llevan usando mucho tiempo para establecer compromis
os legales entre dos partes.
 En un esquema de comunicación, esto se traduce en garantizar una serie
 de situaciones 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

:
\end_layout

\begin_layout Enumerate
El receptor puede verificar la identidad del remitente.
\end_layout

\begin_layout Enumerate
El remitente no puede repudiar el contenido del mensaje más adelante.
\end_layout

\begin_layout Enumerate
El receptor no puede haber elaborado el mensaje por sí mismo.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The first requirement is needed, for example, in financial systems.
 When a customer’s computer orders a bank’s computer to buy a ton of gold,
 the bank’s computer needs to be able to make sure that the computer giving
 the order really belongs to the customer whose account is to be debited.
 In other words, the bank has to authenticate the customer (and the customer
 has to authenticate the bank).
\end_layout

\begin_layout Plain Layout
The second requirement is needed to protect the bank against fraud.
 Suppose that the bank buys the ton of gold, and immediately thereafter
 the price of gold drops sharply.
 A dishonest customer might then proceed to sue the bank, claiming that
 he never issued any order to buy gold.
 When the bank produces the message in court, the customer may deny having
 sent it.
 The property that no party to a contract can later deny having signed it
 is called nonrepudiation.
 The digital sig- nature schemes that we will now study help provide it.
\end_layout

\begin_layout Plain Layout
The third requirement is needed to protect the customer in the event that
 the price of gold shoots up and the bank tries to construct a signed message
 in which the customer asked for one bar of gold instead of one ton.
 In this fraud scenario, the bank just keeps the rest of the gold for itself.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si pensamos en transacciones bancarias, por ejemplo, garantizar estas situacione
s es de gran importancia.
 Sin embargo, en el dominio digital, no tenemos la posibilidad de firmar
 un documento en el sentido tradicional, ya que todos los documentos y mensajes
 están compuestos por un puñado de ceros y unos, todos iguales entre sí.
 Para verificar la autenticidad del documento y dar solución a las situaciones
 listadas anteriormente tendremos que hacer uso de las firmas digitales,
 de las que hablaremos a continuación.
\begin_inset Note Note
status open

\begin_layout Plain Layout
 cómo saber si un documento es auténtico? firmas digitales.
 Las firmas digitales resuelven estos problemas (authenticity, non repudiation
 y ...).
 Existen varias modalidades de firmas digitales, la más usada hoy en día
 #ref# es la que se basa en clave pública.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Firmas digitales de clave pública
\end_layout

\begin_layout Standard
El problema de las firmas digitales puede resolverse de forma relativamente
 sencilla haciendo uso de la criptografía de clave pública.
 De hecho, este enfoque es el más usado hoy en día.
\end_layout

\begin_layout Standard
Supongamos que los algoritmos de encriptación y desencriptación de clave
 pública tienen la propiedad de que 
\begin_inset Formula $E(D(P))=P$
\end_inset

 (además, por supuesto, de la propiedad habitual de que 
\begin_inset Formula $D(E(P))=P$
\end_inset

).
 En este caso, Alice puede enviar un mensaje 
\begin_inset Formula $P$
\end_inset

 firmado a Bob transmitiendo 
\begin_inset Formula $E_{B}(D_{A}(P))$
\end_inset

.
 Puesto que Alice conoce su propia clave privada, 
\begin_inset Formula $D_{A}$
\end_inset

 y la clave pública de Bob, 
\begin_inset Formula $E_{B}$
\end_inset

, construir este mensaje es algo que Alice puede hacer.
 Cuando Bob recibe el mensaje, lo transforma usando su clave privada, como
 de costumbre, produciendo 
\begin_inset Formula $D_{A}(P)$
\end_inset

, al que aplica 
\begin_inset Formula $E_{A}$
\end_inset

 para obtener el texto original 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
\end_layout

\begin_layout Standard
Alice no podrá negar haber enviado el mensaje 
\begin_inset Formula $P$
\end_inset

 a Bob, ya que su clave pública está disponible de forma abierta y por tanto
 es posible demostrar que 
\begin_inset Formula $D_{A}(P)$
\end_inset

 solo puede haber sido generado por ella.
 Sin embargo, este esquema trae consigo algunos problemas relacionados con
 la gestión de claves, como
\begin_inset Note Note
status open

\begin_layout Plain Layout
.
 Algunos de estos problemas
\end_layout

\end_inset

 son el robo de la clave privada, o el cambio de clave.
 Algunos de estos problemas pueden ser resueltos con una infraestructura
 de clave pública (
\lang english
public key infrastructure
\lang spanish
, PKI).
 Hablaremos de infraestructuras de clave pública y de certificados digitales
 en el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:X509"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Cuando se presenta el caso en la corte, Bob puede producir P y 
\begin_inset Formula $D_{A}(P)$
\end_inset

.
 El juez puede verificar fácilmente que Bob efectivamente tiene un mensaje
 válido encriptado por 
\begin_inset Formula $D_{A}$
\end_inset

 simplemente aplicando 
\begin_inset Formula $E_{A}$
\end_inset

 a él.
 Como Bob no sabe cuál es la clave privada de Alice, la única forma en que
 Bob podría haber adquirido un mensaje cifrado es si Alice realmente lo
 envió.
 Mientras esté en la cárcel por perjurio y fraude, Alice tendrá mucho tiempo
 para idear nuevos e interesantes algoritmos de clave pública.
\end_layout

\begin_layout Plain Layout
Si bien el uso de la criptografía de clave pública para firmas digitales
 es un esquema elegante, existen problemas que están relacionados con el
 entorno en el que operan y no con el algoritmo básico.
 Por un lado, Bob puede demostrar que Alice envió un mensaje solo mientras
 
\begin_inset Formula $D_{A}$
\end_inset

 permanezca en secreto.
 Si Alice revela su clave secreta, el argumento ya no se cumple, porque
 cualquiera podría haber enviado el mensaje, incluido el propio Bob.
\end_layout

\begin_layout Plain Layout
El problema podría surgir, por ejemplo, si Bob es el corredor de bolsa de
 Alice.
 Supongamos que Alice le dice a Bob que compre una determinada acción o
 fianza.
 Inmediatamente después, el precio cae bruscamente.
 Para repudiar su mensaje a Bob, Alice corre hacia la policía alegando que
 su casa fue robada y que le robaron la PC que tenía la clave.
 Dependiendo de las leyes de su estado o país, puede o no ser legalmente
 responsable, especialmente si afirma no haber descubierto el robo hasta
 llegar a casa del trabajo, varias horas después de lo que supuestamente
 sucedió.
\end_layout

\begin_layout Plain Layout
Otro problema con el esquema de firma es qué sucede si Alice decide cambiar
 su clave.
 Hacerlo es claramente legal, y probablemente sea una buena idea hacerlo
 periódicamente.
 Si luego surge un caso judicial, como se describió anteriormente, el juez
 aplicará la actual 
\begin_inset Formula $E_{A}$
\end_inset

 a 
\begin_inset Formula $D_{A}(P)$
\end_inset

 y descubrirá que no produce 
\begin_inset Formula $P$
\end_inset

.
 Bob se verá bastante estúpido en este punto.
\end_layout

\begin_layout Plain Layout
En principio, cualquier algoritmo de clave pública se puede usar para firmas
 digitales.
 El estándar de la industria de facto es el algoritmo RSA.
 Muchos productos de seguridad lo usan.
 Sin embargo, en 1991, el NIST propuso usar una variante del algoritmo de
 clave pública de El Gamal para su nuevo estándar de firma digital (DSS).
 El Gamal obtiene su seguridad de la dificultad de calcular logaritmos discretos
, más que de la dificultad de factorizar grandes números.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
A structural problem with using symmetric-key cryptography for digital sig-
 natures is that everyone has to agree to trust Big Brother.
 Furthermore, Big Brother gets to read all signed messages.
 The most logical candidates for running the Big Brother server are the
 government, the banks, the accountants, and the lawyers.
 Unfortunately, none of these inspire total confidence in all citizens.
 Hence, it would be nice if signing documents did not require a trusted
 authority.
\end_layout

\begin_layout Plain Layout
Fortunately, public-key cryptography can make an important contribution
 in this area.
 Let us assume that the public-key encryption and decryption algorithms
 have the property that E(D(P)) = P, in addition, of course, to the usual
 property that D(E(P)) = P.
 (RSA has this property, so the assumption is not unrea- sonable.) Assuming
 that this is the case, Alice can send a signed plaintext mes- sage, P,
 to Bob by transmitting E B (D A (P)).
 Note carefully that Alice knows her own (private) key, D A , as well as
 Bob’s public key, E B , so constructing this mes- sage is something Alice
 can do.
\end_layout

\begin_layout Plain Layout
When Bob receives the message, he transforms it using his private key, as
 usual, yielding D A (P), as shown in Fig.
 8-19.
 He stores this text in a safe place and then applies E A to get the original
 plaintext.
\end_layout

\begin_layout Plain Layout
To see how the signature property works, suppose that Alice subsequently
 denies having sent the message P to Bob.
 When the case comes up in court, Bob can produce both P and D A (P).
 The judge can easily verify that Bob indeed has a valid message encrypted
 by D A by simply applying E A to it.
 Since Bob does not know what Alice’s private key is, the only way Bob could
 have acquired a mes- sage encrypted by it is if Alice did indeed send it.
 While in jail for perjury and fraud, Alice will have much time to devise
 interesting new public-key algorithms.
\end_layout

\begin_layout Plain Layout
Although using public-key cryptography for digital signatures is an elegant
 scheme, there are problems that are related to the environment in which
 they oper- ate rather than to the basic algorithm.
 For one thing, Bob can prove that a mes- sage was sent by Alice only as
 long as D A remains secret.
 If Alice discloses her secret key, the argument no longer holds, because
 anyone could have sent the message, including Bob himself.
\end_layout

\begin_layout Plain Layout
The problem might arise, for example, if Bob is Alice’s stockbroker.
 Suppose that Alice tells Bob to buy a certain stock or bond.
 Immediately thereafter, the price drops sharply.
 To repudiate her message to Bob, Alice runs to the police claiming that
 her home was burglarized and the PC holding her key was stolen.
 Depending on the laws in her state or country, she may or may not be legally
 liable, especially if she claims not to have discovered the break-in until
 getting home from work, several hours after it allegedly happened.
\end_layout

\begin_layout Plain Layout
Another problem with the signature scheme is what happens if Alice decides
 to change her key.
 Doing so is clearly legal, and it is probably a good idea to do so periodically.
 If a court case later arises, as described above, the judge will apply
 the current E A to D A (P) and discover that it does not produce P.
 Bob will look pretty stupid at this point.
\end_layout

\begin_layout Plain Layout
In principle, any public-key algorithm can be used for digital signatures.
 The de facto industry standard is the RSA algorithm.
 Many security products use it.
 However, in 1991, NIST proposed using a variant of the El Gamal public-key
 al- gorithm for its new Digital Signature Standard (DSS).
 El Gamal gets its securi- ty from the difficulty of computing discrete
 logarithms, rather than from the diffi- culty of factoring large numbers.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Funciones hash criptográficas
\begin_inset Index idx
status open

\begin_layout Plain Layout
hash
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
message digest
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El proceso de firma explicado también puede llevarse a cabo empleando un
 hash del mensaje, en lugar del mensaje completo.
 Este método tiene dos ventajas.
 Por un lado, el hash será más corto que el mensaje, por lo que el proceso
 de firma será más eficiente, tanto en la generación como en la verificación.
 Por otro lado, separamos las funciones de autenticación y confidencialidad,
 por lo que no será necesario encriptar un mensaje si lo único que necesitamos
 es garantizar la autenticidad del remitente y evitar el repudio de la transacci
ón.
\end_layout

\begin_layout Standard
El esquema que exponemos a continuación se basa en la idea de una función
 hash unidireccional que toma un texto plano de longitud arbitraria calcula
 una cadena de bits de longitud fija a partir de este.
 Esta función hash, a menudo denominada 
\lang english
message digest
\lang spanish
 (MD), debe cumplir cuatro propiedades importantes 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

:
\end_layout

\begin_layout Standard
1.
 Dado 
\begin_inset Formula $P$
\end_inset

, es fácil calcular 
\begin_inset Formula $MD(P)$
\end_inset

.
\end_layout

\begin_layout Standard
2.
 Dado 
\begin_inset Formula $MD(P)$
\end_inset

, es efectivamente imposible encontrar 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
3.
 Dado 
\begin_inset Formula $P$
\end_inset

, es extremadamente difícil encontrar 
\begin_inset Formula $P'$
\end_inset

 tal que 
\begin_inset Formula $MD(P')=MD(P)$
\end_inset

.
\end_layout

\begin_layout Standard
4.
 Un cambio en la entrada, por pequeño que sea, producirá una salida muy
 diferente.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Para cumplir el criterio 3, el hash debe tener al menos 128 bits de longitud,
 preferiblemente más.
 Para cumplir el criterio 4, el hash debe manipular los bits muy a fondo,
 a diferencia de los algoritmos de cifrado de clave simétrica que hemos
 visto.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Computar el hash de un mensaje es mucho más eficiente que encriptarlo con
 un algoritmo de clave pública, por lo que los 
\lang english
message digests
\lang spanish
 pueden usarse para acelerar algoritmos de firma digital.
\end_layout

\begin_layout Standard
El funcionamiento de este tipo de firmas queda ilustrado en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Uso-de-SHA-1"

\end_inset

.
 Como puede verse en la misma, el mensaje de Alice 
\begin_inset Formula $M$
\end_inset

 se envía sin encriptar, junto a un hash firmado 
\begin_inset Formula $D_{A}(H)$
\end_inset

, donde 
\begin_inset Formula $H=MD(M)$
\end_inset

 usando el algoritmo de hash seguro SHA-1 
\begin_inset CommandInset citation
LatexCommand cite
key "national1993secure"

\end_inset

.
 Gracias a las propiedades de las funciones de hash, este esquema permite
 a Bob verificar la identidad de Alice y la integridad del mensaje en un
 paso, simplemente comprobando que 
\begin_inset Formula $E_{A}(D_{A}(H))=MD(M)$
\end_inset

.
 En caso de que esto no pueda comprobarse, el mensaje puede haber sido modificad
o (o haber sido firmado por otra entidad), por lo que Bob deberá desconfiar
 del mismo.
 En cambio, si el resultado coincide, podremos estar seguros de que el mensaje
 no ha sido modificado en su transmisión, y que ha sido firmado, en este
 caso, por Alice.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/sha1-tanenbaum.eps
	width 85col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Uso-de-SHA-1"

\end_inset

Uso del algoritmo seguro de hash SHA-1 y del algoritmo de clave pública
 RSA para la firma de un documento no confidencial 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
SHA-1 y SHA-2
\end_layout

\begin_layout Plain Layout
Se ha propuesto una variedad de funciones de resumen de mensaje.
 Una de las funciones más utilizadas es SHA-1 (Secure Hash Algorithm 1)
 (NIST, 1993).
 Como todos los resúmenes de mensajes, opera procesando bits de una manera
 lo suficientemente complicada como para que cada bit de salida se vea afectado
 por cada bit de entrada.
 SHA-1 fue desarrollado por NSA y bendecido por NIST en FIPS 180-1.
 Procesa datos de entrada en bloques de 512 bits y genera un resumen de
 mensaje de 160 bits.
 Una forma típica para que Alice envíe un mensaje no secreto pero firmado
 a Bob se ilustra en [fig: Uso-de-SHA-1].
 Aquí, su mensaje de texto plano se introduce en el algoritmo SHA-1 para
 obtener un hash SHA-1 de 160 bits.
 Luego, Alice firma el hash con su clave privada RSA y envía tanto el mensaje
 de texto simple como el hash firmado a Bob.
\end_layout

\begin_layout Plain Layout
Después de recibir el mensaje, Bob calcula el mismo hash SHA-1 y también
 aplica la clave pública de Alice al hash firmado para obtener el hash original,
 H.
 Si los dos están de acuerdo, el mensaje se considera válido.
 Como Trudy no puede modificar el mensaje (texto sin formato) mientras está
 en tránsito y producir uno nuevo que se haya desplazado a H, Bob puede
 detectar fácilmente cualquier cambio que Trudy haya realizado en el mensaje.
 Para los mensajes cuya integridad es importante pero cuyos contenidos no
 son secretos, el esquema de la figura 8-21 es ampliamente utilizado.
 Por un costo relativamente pequeño en computación, garantiza que cualquier
 modificación realizada en el mensaje de texto simple en tránsito puede
 detectarse con muy alta probabilidad.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
One criticism of signature methods is that they often couple two distinct
 func- tions: authentication and secrecy.
 Often, authentication is needed but secrecy is not always needed.
 Also, getting an export license is often easier if the system in question
 provides only authentication but not secrecy.
 Below we will describe an authentication scheme that does not require encryptin
g the entire message.
\end_layout

\begin_layout Plain Layout
This scheme is based on the idea of a one-way hash function that takes an
 arbitrarily long piece of plaintext and from it computes a fixed-length
 bit string.
 This hash function, MD, often called a message digest, has four important
 proper- ties:
\end_layout

\begin_layout Enumerate
Given P, it is easy to compute MD(P).
 
\end_layout

\begin_layout Enumerate
Given MD(P), it is effectively impossible to find P.
 
\end_layout

\begin_layout Enumerate
Given P, no one can find P' such that MD (P') = MD(P).
 
\end_layout

\begin_layout Enumerate
A change to the input of even 1 bit produces a very different output.
\end_layout

\begin_layout Plain Layout
To meet criterion 3, the hash should be at least 128 bits long, preferably
 more.
 To meet criterion 4, the hash must mangle the bits very thoroughly, not
 unlike the symmetric-key encryption algorithms we have seen.
\end_layout

\begin_layout Plain Layout
Computing a message digest from a piece of plaintext is much faster than
 en- crypting that plaintext with a public-key algorithm, so message digests
 can be used to speed up digital signature algorithms.
 To see how this works, consider the signature protocol of Fig.
 8-18 again.
 Instead, of signing P with K BB (A, t, P), BB now computes the message
 digest by applying MD to P, yielding MD(P).
 BB then encloses K BB (A, t, MD(P)) as the fifth item in the list encrypted
 with K B that is sent to Bob, instead of K BB (A, t, P).
\end_layout

\begin_layout Plain Layout
If a dispute arises, Bob can produce both P and K BB (A, t, MD(P)).
 After Big Brother has decrypted it for the judge, Bob has MD(P), which
 is guaranteed to be genuine, and the alleged P.
 However, since it is effectively impossible for Bob to find any other message
 that gives this hash, the judge will easily be convinced that Bob is telling
 the truth.
 Using message digests in this way saves both encryption time and message
 transport costs.
\end_layout

\begin_layout Plain Layout
Message digests work in public-key cryptosystems, too, as shown in Fig.
 8- 20.
 Here, Alice first computes the message digest of her plaintext.
 She then signs the message digest and sends both the signed digest and
 the plaintext to Bob.
 If Trudy replaces P along the way, Bob will see this when he computes MD(P).
\end_layout

\begin_layout Plain Layout
SHA-1 y SHA-2
\end_layout

\begin_layout Plain Layout
A variety of message digest functions have been proposed.
 One of the most widely used functions is SHA-1 (Secure Hash Algorithm 1)
 (NIST, 1993).
 Like all message digests, it operates by mangling bits in a sufficiently
 complicated way that every output bit is affected by every input bit.
 SHA-1 was developed by NSA and blessed by NIST in FIPS 180-1.
 It processes input data in 512-bit blocks, and it generates a 160-bit message
 digest.
 A typical way for Alice to send a nonsecret but signed message to Bob is
 illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Uso-de-SHA-1"

\end_inset

.
 Here, her plaintext message is fed into the SHA-1 algorithm to get a 160-bit
 SHA-1 hash.
 Alice then signs the hash with her RSA private key and sends both the plaintext
 message and the signed hash to Bob.
\end_layout

\begin_layout Plain Layout
After receiving the message, Bob computes the SHA-1 hash himself and also
 applies Alice’s public key to the signed hash to get the original hash,
 H.
 If the two agree, the message is considered valid.
 Since there is no way for Trudy to modify the (plaintext) message while
 it is in transit and produce a new one that hashes to H, Bob can easily
 detect any changes Trudy has made to the message.
 For messages whose integrity is important but whose contents are not secret,
 the scheme of Fig.
 8-21 is widely used.
 For a relatively small cost in computation, it guarantees that any modification
s made to the plaintext message in transit can be detected with very high
 probability.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Seguridad-en-sist-empotrados"

\end_inset

Seguridad en sistemas empotrados
\end_layout

\begin_layout Standard
Como hemos visto en el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Principios-seguridad"

\end_inset

, una parte importante de la ciberseguridad depende del uso de funciones
 y algoritmos complejos, que suelen estar relacionados con operaciones computaci
onalmente muy costosas.
 Sin embargo, los sistemas empotrados, como los usados en los nodos finales
 y en las pasarelas de las infraestructuras IoT, suelen disponer de recursos
 muy limitados.
 Esta escasez de recursos impondrá una serie de limitaciones, que van desde
 limitaciones computacionales (baja frecuencia de la CPU, escasa memoria)
 hasta limitaciones energéticas (sistemas autónomos alimentados por baterías)
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, que a su vez se traduce en limitaciones en el tiempo de cómputo empleable
\end_layout

\end_inset

.
 Por otro lado, los sistemas embebidos son responsables, en numerosas ocasiones,
 de llevar a cabo funciones críticas, que podrían poner en peligro la integridad
 física del usuario en caso de fallo.
 Debido a estos factores, la seguridad en sistemas empotrados debe ser tratada
 de un modo especial.
\end_layout

\begin_layout Standard
Aunque a continuación hablaremos de requisitos generales de seguridad, conviene
 mencionar que son muchas las entidades involucradas en la cadena de diseño,
 fabricación y uso de un sistema embebido típico.
 Los requisitos de seguridad dependerán de la perspectiva que consideremos,
 tal y como ilustra la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Actores-implicados-requisitos-seguridad"

\end_inset

, con el ejemplo de un teléfono móvil.
 En el ejemplo, el usuario estará interesado en mantener la confidencialidad
 y la integridad de los datos que almacena o transmite haciendo uso del
 sistema.
 El proveedor de hardware, por su parte, tratará de proteger la propiedad
 intelectual de los módulos provistos al diseñador del dispositivo.
 El proveedor de contenidos, en cambio, tratará de evitar la copia ilegal
 de los contenidos multimedia ofrecidos al usuario.
 De esta forma, las entidades no confiables (potencialmente maliciosas)
 también variarán dependiendo de la perspectiva considerada 
\begin_inset CommandInset citation
LatexCommand cite
key "ravi2004security"

\end_inset

.
\end_layout

\begin_layout Standard
En las siguientes secciones daremos una definición para los sistemas empotrados
 y estudiaremos sus características más relevantes.
 También presentaremos algunos de los requisitos de seguridad fundamentales
 en cualquier sistema informático.
 Finalmente, introduciremos las soluciones de seguridad con las que se abordan
 estos requisitos.
 Con esto habremos dado las primeras pinceladas en la definición de los
 requisitos de seguridad de nuestro sistema.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
unas pinceladas con las que empezaremos a comprender cuáles serán los requisitos
 de seguridad de nuestro sistema.
\end_layout

\begin_layout Plain Layout
pretendemos ofrecer una imagen más definida de los que serán los requisitos
 de seguridad de nuestro sistema.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/actores-implicados-seguridad.png
	lyxscale 10
	width 55col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Actores-implicados-requisitos-seguridad"

\end_inset

Actores implicados y requisitos de seguridad de un terminal móvil 
\begin_inset CommandInset citation
LatexCommand cite
key "ravi2004security"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Particularidades de los sistemas empotrados
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Como hemos introducido anteriormente, los sistemas empotrados presentan
 varias particularidades que nos harán .
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los sistemas empotrados
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
sistema empotrado
\end_layout

\end_inset

 (también conocidos como sistemas embebidos
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
sistema embebido
\end_layout

\end_inset

 o 
\lang english
embedded systems
\lang spanish

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
embedded system
\end_layout

\end_inset

) son sistemas basados en computador y que están diseñados para realizar
 una función concreta.
 Muchos sistemas empotrados llevan a cabo tareas a tiempo real, siendo frecuente
 su uso en el control de sistemas mecánicos, como ascensores o cadenas de
 montaje 
\begin_inset CommandInset citation
LatexCommand cite
key "EmbeddedSysDesign"

\end_inset

.
\end_layout

\begin_layout Standard
Además, estos sistemas están presentes en muchos electrodomésticos, como
 hornos microondas, lavadoras o reproductores de música.
 En este contexto, también los encontramos en el núcleo de muchos dispositivos
 cotidianos, como la calculadora, la cámara de fotos o el marcapasos 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-ModernOS"

\end_inset

.
\end_layout

\begin_layout Standard
Podría discutirse si algunos dispositivos como los 
\emph on
SmartPhones
\emph default
 o las videoconsolas de última generación son también sistemas empotrados.
 No obstante, estos dispositivos cuentan con un sistema operativo (
\lang english
operating system
\lang spanish
, OS) que les permite ejecutar aplicaciones de terceros bajo demanda del
 usuario.
 Por este motivo, estos dispositivos serán considerados en este trabajo
 como computadores de propósito general, a pesar de compartir algunas caracterís
ticas con los sistemas empotrados.
\end_layout

\begin_layout Standard
Estas son las principales características que consideraremos para decir
 que un sistema es empotrado:
\end_layout

\begin_layout Itemize
Se trata de un sistema electrónico basado en microprocesador (normalmente
 microcontrolador).
\end_layout

\begin_layout Itemize
El sistema está diseñado para llevar a cabo una aplicación o tarea específica,
 ejecutando un software concreto que es instalado en el proceso de producción.
 El sistema no está diseñado para ejecutar software de terceros.
\end_layout

\begin_layout Itemize
El sistema cuenta con los periféricos necesarios para llevar a cabo su función.
 El sistema está diseñado para controlar este hardware específico, no permitiend
o que se añadan nuevos periféricos.
\end_layout

\begin_layout Itemize
El sistema puede ser el núcleo de un dispositivo autónomo (como un mando
 a distancia), o puede formar parte de un sistema mayor (como las distintas
 unidades de control electrónico de un automóvil).
\end_layout

\begin_layout Standard
En aras de la exhaustividad, y aunque no es un problema que afecte directamente
 a este proyecto, destacaremos los requisitos temporales de algunos sistemas
 empotrados.
 En numerosas ocasiones, las tareas deben ser realizadas en tiempo real,
 proporcionando respuestas a ciertos eventos en un intervalo de tiempo controlad
o y reducido.
 Esto tiene gran relación con la tendencia a usar sistemas empotrados en
 la implementación de sistemas críticos.
 Los sistemas críticos deben ser altamente fiables, llevando a cabo su función
 de forma rigurosa y precisa.
 En caso de error, un sistema crítico puede desencadenar un fallo general
 del sistema, incurrir en enormes pérdidas económicas o incluso poner en
 riesgo la vida de personas.
\end_layout

\begin_layout Section
Requisitos generales de seguridad
\end_layout

\begin_layout Standard
Como hemos mencionado anteriormente, los recursos computacionales de los
 sistemas empotrados suelen ser muy limitados.
 Esto supone un abaratamiento de costes que se hace muy relevante en la
 producción en masa de los dispositivos.
 Sin embargo, esta escasez de recursos, junto al 
\emph on
propósito no general
\emph default
 de estos sistemas, hace que estos carezcan de un sistema operativo propiamente
 dicho, con todas las consecuencias que esto conlleva.
\end_layout

\begin_layout Standard
En los sistemas empotrados más complejos es frecuente el uso de un planificador
 de tareas (
\lang english
scheduler
\lang spanish
) sencillo, o de un sistema operativo de tiempo real (
\lang english
real-time operating system
\lang spanish
, RTOS), con los que se facilita el desarrollo y ejecución de procesos concurren
tes.
 Estas herramientas suelen permitir una buena gestión de las tareas de tiempo
 real, sin embargo no cuentan con los servicios proporcionados por un sistema
 operativo, como una pila de red, un sistema de ficheros, o la posibilidad
 de ejecutar software de terceros.
 Por este motivo, tendremos que estudiar cuidadosamente los requisitos de
 seguridad del sistema, ya que todos ellos deberán ser implementados por
 el equipo de desarrollo del mismo.
\end_layout

\begin_layout Standard
A continuación presentamos los requisitos de seguridad más relevantes en
 cualquier sistema informático 
\begin_inset CommandInset citation
LatexCommand cite
key "ravi2004security"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Qué se debe asegurar y cuáles son las dificultades (escasa CPU, RAM, batería,
 etc).
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Identificación de usuarios
\end_layout

\begin_layout Standard
Se trata del proceso de validar a los usuarios antes de permitirles usar
 el sistema.
 Este requisito es fundamental cuando el sistema proporciona el acceso a
 datos sensibles (como los valores de sensores en un
\emph on
 SmartHome
\emph default
), a servicios restringidos (como llamadas telefónicas) o permite el control
 de otro sistema (como una cerradura electrónica o la calefacción).
\end_layout

\begin_layout Standard
La identificación de usuarios es especialmente importante cuando el sistema
 empotrado puede ser accedido con facilidad por personas no autorizadas,
 como son aquellos que están conectados a Internet.
\end_layout

\begin_layout Subsubsection
Acceso seguro a la red
\end_layout

\begin_layout Standard
Consiste en proporcionar acceso a una conexión de red o a un servicio solo
 si el dispositivo está autorizado.
 Por ejemplo, un router doméstico no debería permitir el acceso a ningún
 dispositivo que no haya sido autorizado a usar la red.
 Del mismo modo, una pasarela IoT no deberá retransmitir datos de una red
 de sensores ajena.
\end_layout

\begin_layout Subsubsection
Comunicación segura
\end_layout

\begin_layout Standard
La comunicación segura incluye varias funciones, que se listan a continuación.
 También proporcionamos explicaciones con ejemplos concernientes al presente
 proyecto.
\end_layout

\begin_layout Enumerate
Autenticar
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
autenticación
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
las partes a
\end_layout

\end_inset

 los extremos de la comunicación, ya sean personas o sistemas informáticos.
\end_layout

\begin_deeper
\begin_layout Standard
En el caso que nos ocupa, necesitaremos un mecanismo para verificar la identidad
 de los nodos de la red.
 Solo así podremos asegurarnos que los datos mostrados en la terminal son,
 efectivamente, los medidos por nuestros dispositivos.
\end_layout

\end_deeper
\begin_layout Enumerate
Garantizar la confidencialidad
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
confidencialidad
\end_layout

\end_inset

 de los datos comunicados, evitando que puedan ser leídos por entidades
 no autorizadas.
\end_layout

\begin_deeper
\begin_layout Standard
En un 
\lang english
SmartHome
\lang spanish
, la disponibilidad de los datos de temperatura o de presencia de personas
 podrían ser usados para atentar contra la propiedad privada.
\end_layout

\end_deeper
\begin_layout Enumerate
Garantizar la integridad
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
integridad
\end_layout

\end_inset

 de los datos comunicados, evitando que puedan ser modificados por entidades
 no autorizadas.
\end_layout

\begin_deeper
\begin_layout Standard
Un posible atacante podría causar severas molestias, e incluso sembrar el
 terror en el hogar, enviando comandos aleatorios a las lámparas o a la
 caldera.
 A pesar de que el atacante no entendería el contenido de los mensajes,
 los habitantes de la casa podrían creerse víctimas de un 
\emph on
poltergeist
\emph default
.
\end_layout

\end_deeper
\begin_layout Enumerate
Evitar el repudio
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
no repudio
\end_layout

\end_inset

 de transacciones ejecutadas de forma efectiva, como puede ser una transferencia
 bancaria.
\end_layout

\begin_deeper
\begin_layout Standard
Como puede ser, también, el pedido de víveres efectuado de forma autónoma
 por un frigorífico inteligente correctamente configurado.
\end_layout

\end_deeper
\begin_layout Subsubsection
Almacenamiento seguro de datos
\end_layout

\begin_layout Standard
Consiste en asegurar la confidencialidad y la integridad de la información
 sensible almacenada en el sistema.
 Esta información solo podrá ser leída por usuarios o dispositivos autorizados
 a ello.
 Del mismo modo, solo los usuarios o dispositivos autorizados podrán modificar
 determinados datos.
 Por ejemplo, en el caso de una tarjeta bancaria, solo el usuario debería
 poder modificar la clave, y solo el banco debería poder modificar el saldo.
 En el caso que nos ocupa, solo el usuario del sistema podrá leer la información
 de los sensores almacenada en la Nube, y solo los sensores podrán actualizar
 dicha información.
\end_layout

\begin_layout Subsubsection
Disponibilidad
\end_layout

\begin_layout Standard
Debe garantizarse que el sistema pueda realizar la función para la que fue
 diseñado y dar servicio a los usuarios legítimos en todo momento, no interrumpi
éndose a causa de ataques de denegación de servicio (
\lang english
denial of service
\lang spanish
, DoS).
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
el sistema que le da de comer al gato no debe quedarse colgado, y la camarita
 debe funcionar y estar disponible en todo momento (un DoS sería desastroso
 en este caso)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Resistencia a la manipulación
\emph on
 
\emph default
\lang english
(Tamper resistance)
\end_layout

\begin_layout Standard
Los ataques perpetrados contra los sistemas empotrados pueden explotar vulnerabi
lidades a distintos niveles, incluyendo aquellas presentes en el sistema
 operativo y las aplicaciones.
 Estos ataques pueden manipular datos o procesos sensibles (ataques a la
 integridad), revelar información confidencial (ataques a la privacidad)
 o denegar el acceso a los recursos del sistema (ataques a la disponibilidad).
 Por tanto, es necesario desarrollar y desplegar diversas medidas contra
 estos ataques, tanto a nivel software como a nivel hardware.
\end_layout

\begin_layout Subsubsection
Fiabilidad del sistema
\end_layout

\begin_layout Standard
Para afirmar que un sistema es realmente fiable, no basta con que este funcione
 de forma correcta la mayor parte del tiempo, sino que debe verificarse
 que su funcionamiento es el esperado en todo momento.
 Si además el sistema ha de ser seguro, este debe funcionar incluso cuando
 es sometido a ataques de seguridad.
 La fiabilidad es un requisito fundamental cuando se trata de 
\emph on
sistemas críticos
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
La implementación y testeo de sistemas altamente fiables son mucho más complejas
 que las de aquellos sistemas que simplemente funcionan correctamente la
 mayor parte del tiempo.
 Los sistemas seguros se enfrentan a un desafío aún mayor: deben operar
 de forma fiable incluso cuando
\end_layout

\begin_layout Plain Layout
It is well known that truly reliable systems are much more difficult to
 build than those that merely work most of the time.
 Secure systems face an even greater challenge: they must continue to operate
 reliably despite attacks.
 As systems become more complicated, there are inevitably more possible
 failure modes.
 PUES NECESITAREMOS VERIFICAR DE ALGÚN MODO!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Soluciones de seguridad
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Usando las técnicas explicadas en el cap 2, se pueden elaborar soluciones
 completas de seguridad
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Existen múltiples técnicas con las que se trata de satisfacer los requisitos
 de seguridad definidos en la sección anterior.
 A continuación presentamos algunos de ellos, prestando especial atención
 a los que tienen más relevancia en la realización de este trabajo.
\end_layout

\begin_layout Subsubsection
Protocolos de seguridad
\end_layout

\begin_layout Standard
Los protocolos de seguridad
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
protocolo de seguridad
\end_layout

\end_inset

 proporcionan formas de establecer canales de comunicación seguros entre
 dispositivos.
 Esto se consigue estableciendo mecanismos para asegurar la confidencialidad
 y la integridad de los mensajes, y autenticando cada uno de los extremos
 de la comunicación.
 La confidencialidad suele implicar el cifrado de los datos previa transmisión,
 normalmente con técnicas de criptografía simétrica.
 Por su parte, la integridad de los mensajes, que es esencial para evitar
 la manipulación de los mismos por un posible atacante, se consigue añadiendo
 un código de autenticación de mensaje (
\lang english
message authentication aode
\lang spanish

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
message authentication code (MAC)
\end_layout

\end_inset

, MAC) a cada mensaje transmitido.
 Los códigos MAC se calculan mediante la aplicación de una función hash
 criptográfica al mensaje, y cifrando el resultado con una clave privada.
 La verificación de la autenticidad de los dispositivos puede conseguirse
 con el uso de certificados digitales.
 De esta forma, dos dispositivos pueden comunicarse de forma segura a través
 de una red a priori
\emph on
 
\emph default
no segura.
\end_layout

\begin_layout Standard
Tal vez los protocolos de seguridad más conocidos sean 
\lang english
Internet Protocol Security
\lang spanish
 (IPSec) y 
\lang english
Transport Layer Security
\lang spanish
 (TLS), este último sucesor de 
\lang english
Secure Sockets Layer
\lang spanish
 (SSL
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Secure Sockets Layer SSL
\end_layout

\end_inset

).
 El uso de estos protocolos está muy extendido: el primero, en el despliegue
 de redes privadas virtuales (
\lang english
virtual private networks
\lang spanish
, VPN), el segundo, en la realización de transacciones de aplicación seguras
 en Internet.
 Estos protocolos son prácticamente transparentes para las capas de comunicación
 superiores.
 De este modo, una aplicación que se comunica en red de forma no segura
 puede pasar a establecer una comunicación segura con pocas modificaciones,
 sin necesidad de ser rediseñada desde cero.
 No obstante, los requisitos computacionales que supone el uso de estos
 protocolos pueden comprometer la capacidad computacional del sistema con
 gran facilidad, en especial cuando se trata de sistemas empotrados.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
DATOS EN TLS: WolfSSL (memoria) y estudio de esta gente (CPU y tamaño del
 paquete)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:TLS"

\end_inset

 presentamos las características principales del protocolo TLS, por su relevanci
a en el presente proyecto.
\end_layout

\begin_layout Subsubsection
Certificados digitales de clave pública
\end_layout

\begin_layout Standard
Estos certificados digitales
\begin_inset Index idx
status open

\begin_layout Plain Layout
certificado digital
\end_layout

\end_inset

, de los que hablaremos más a fondo en el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:X509"

\end_inset

, proporcionan formas de asociar una identidad digital con una entidad física,
 basándose en criptografía asimétrica.
 Esto se consigue a través de un fichero, con el que es posible validar
 que la entidad física posee una determinada clave pública, gracias a la
 confianza depositada en una 
\emph on
autoridad certificadora
\emph default
 y en su 
\emph on
cadena de confianza
\emph default
.
 El certificado incluye información sobre la clave, la identidad de su propietar
io (sujeto del certificado) y sobre la firma digital de la entidad.
\end_layout

\begin_layout Subsubsection
Gestión de derechos digitales
\end_layout

\begin_layout Standard
Las herramientas de gestión de derechos digitales (
\lang english
digital right management
\lang spanish
, DRM) proporcionan entornos seguros para proteger contenidos digitales
 de un uso no autorizado.
 De esta forma, es posible evitar la copia de música con derechos de autor,
 así como la retransmisión pública de películas protegidas por las leyes
 de propiedad intelectual.
 Algunas herramientas de gestión de derechos digitales son los protocolos
 OpenIPMP, MPEG, ISMA, y MOSES 
\begin_inset CommandInset citation
LatexCommand cite
key "ravi2004security"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Almacenamiento y ejecución seguros
\end_layout

\begin_layout Standard
Estas soluciones requieren que el sistema haya sido diseñado teniendo en
 cuenta las consideraciones de seguridad.
 Algunos ejemplos sencillos son el uso de hardware para monitorizar las
 transacciones en un bus, bloqueando acceso ilegales a zonas protegidas
 de la memoria, la autenticación del firmware que se ejecuta en el sistema,
 o el aislamiento de aplicaciones para preservar la privacidad e integridad
 tanto del código como de los datos asociados a cada proceso 
\begin_inset CommandInset citation
LatexCommand cite
key "ravi2004security"

\end_inset

.
 Destacaremos aquí el hecho de que algunos procesadores comerciales están
 diseñados para la ejecución segura, como es el caso de algunos ARM 
\begin_inset CommandInset citation
LatexCommand cite
key "ARM:TrustZone"

\end_inset

, y que existen sistemas operativos de tiempo real diseñados para este fin.
\end_layout

\begin_layout Subsubsection
Verificación del software
\end_layout

\begin_layout Standard
Existe un gran abanico de verificaciones a las que se puede someter un software
 para comprobar que lleva a cabo la función para la que fue diseñado en
 todo momento.
 Esto puede hacerse de diversas formas.
 La verificación formal, por su parte, supone la comprobación (matemática)
 de que el software realiza su función sin importar las condiciones a las
 que es sometido.
 Este método de verificación es el más estricto de todos, siendo también
 el más fiable.
 Sin embargo, la verificación formal es muy costosa, por su dificultad y
 por el gran tiempo que conlleva.
 Otro método es el análisis estático, que supone la revisión del código
 fuente (o del código objeto) sin llevar a cabo la ejecución del programa.
 De esta forma es posible detectar muchos errores y algunas prácticas comunes
 que suponen un riesgo para la integridad de la ejecución
\begin_inset Note Note
status open

\begin_layout Plain Layout
como es el uso de punteros sin tipo
\end_layout

\end_inset

.
 Por último, mencionaremos el análisis dinámico, que requiere la ejecución
 del programa en ambientes diversos, idealmente con todos los posibles valores
 en los parámetros de entrada de cada función.
\end_layout

\begin_layout Standard
Existen diversos estándares que especifican requisitos en la verificación
 de software.
 También podemos encontrar directrices que nos ayudan a escribir código
 libre de errores.
 Los siguientes son ejemplos de estos estándares y directrices.
\end_layout

\begin_layout Description
FIPS-140 estándares de seguridad informática del gobierno de los Estados
 Unidos, que especifican requisitos para módulos criptográficos.
\end_layout

\begin_layout Description
Evaluation
\begin_inset space ~
\end_inset

Assurance
\begin_inset space ~
\end_inset

Level
\begin_inset space ~
\end_inset

(EAL) certificaciones para seguridad informática por niveles definidos por
 el estándar 
\lang english
Common Criteria for Information Technology Security Evaluation
\lang spanish
 (ISO/IEC
\begin_inset space ~
\end_inset

15408).
\end_layout

\begin_layout Description
MISRA
\begin_inset space ~
\end_inset

C conjunto de directrices para el desarrollo de software en el lenguaje
 de programación
\begin_inset space ~
\end_inset

C, desarrollado por la 
\lang english
Motor Industry Software Reliability Association
\lang spanish
 (MISRA) y usada ampliamente en la industria de la automoción.
\end_layout

\begin_layout Standard
Puesto que la verificación de un programa completo suele ser muy costosa,
 es común que se verifiquen solo algunas partes del mismo, por ejemplo,
 algún módulo crítico.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
QUE QUEDE CLARO LA PARTE INVESTIGADORA AQUI (bibliografia!!)
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:TLS"

\end_inset

El protocolo TLS
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Revisar notación:
\end_layout

\begin_layout Plain Layout
traducir TLS Record Protocol y TLS Handshake Protocol?
\end_layout

\begin_layout Plain Layout
usar siempre TLS Record Protocol? (es Record Protocol admisible)?
\end_layout

\begin_layout Plain Layout
revisar cursivas
\end_layout

\begin_layout Plain Layout
queda claro el cálculo de MAC?
\end_layout

\begin_layout Plain Layout
uso de la 1a pers plural?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\lang english
Transport Layer Security
\lang spanish
 (TLS)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Transport Layer Security (TLS)
\end_layout

\end_inset

 es un protocolo de red cuyo principal objetivo es establecer una comunicación
 segura entre dos nodos de una red que no tiene por qué ser segura
\begin_inset Note Note
status open

\begin_layout Plain Layout
 (
\emph on
aunque sí reliable
\emph default
)
\end_layout

\end_inset

.
 Es el sucesor de 
\lang english
Secure Sockets Layer
\lang spanish
 (SSL), por lo que comparte muchas características con el mismo.
\end_layout

\begin_layout Standard
El protocolo, cuya versión más reciente es TLS
\begin_inset space ~
\end_inset

1.2, se compone de dos capas principales, denominadas 
\emph on
TLS Record Protocol
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
TLS Record Protocol
\end_layout

\end_inset

 y 
\emph on
TLS Handshake Protocol
\emph default
.
 En el nivel más bajo, justo por encima de algún protocolo de transmisión
 confiable
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Un protocolo de red confiable es aquel que garantiza que los datos serán
 entregados en su destino sin errores y en el mismo orden en que se transmitiero
n.
\end_layout

\end_inset

 (como TCP), se encuentra el 
\emph on
TLS Record Protocol
\emph default
.
 Este protocolo proporciona la seguridad de la conexión, que tiene dos propiedad
es básicas:
\end_layout

\begin_layout Itemize

\series bold
La conexión es privada
\series default
.
 Los datos son encriptados con algoritmos de criptografía simétrica (como
 AES, RC4, etc).
 Las claves usadas en esta encriptación simétrica se generan de forma única
 para cada conexión, a través de una negociación secreta que lleva a cabo
 otro protocolo (el 
\emph on
TLS Handshake Protocol
\emph default
).
 Aunque no es común, el 
\emph on
TLS Record Protocol
\emph default
 también puede ser usado sin encriptación.
\end_layout

\begin_layout Itemize

\series bold
La conexión es confiable
\series default
.
 El transporte de mensajes incluye una comprobación de la integridad del
 mensaje, que se basa en un código MAC
\begin_inset Index idx
status open

\begin_layout Plain Layout
message authentication code (MAC)
\end_layout

\end_inset

.
 El cálculo del código MAC se lleva a cabo haciendo uso de funciones de
 hash seguras (como SHA-1).
 Aunque no es común, el 
\emph on
TLS Record Protocol
\emph default
 también puede operar sin el uso de códigos MAC.
\end_layout

\begin_layout Standard
El 
\emph on
TLS Record Protocol
\emph default
 es usado para encapsular otros protocolos de más alto nivel.
 Uno de estos protocolos es el 
\emph on
TLS Handshake Protocol
\emph default
, que permite la autenticación mutua de servidor y cliente y les permite
 negociar los algoritmos de encriptación y las claves antes de que comience
 la transmisión de los datos de aplicación.
 El 
\emph on
TLS Handshake Protocol
\emph default
 proporciona seguridad en la conexión que tiene tres características principales
:
\end_layout

\begin_layout Itemize
Permite autenticar la identidad de los extremos, usando criptografía asimétrica
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Existe una modalidad que permite usar criptografía simétrica en la autenticación
, a través de un sistema de claves compartidas (PSK) 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc4279-TLS+PSK,rfc4285-TLS+PSK-NULL"

\end_inset

.
 Esto puede ser útil en determinadas circunstancias, por ejemplo, si se
 requiere autenticación y los recursos computacionales son muy limitados.
\end_layout

\end_inset

 (como RSA, DSA, etc.).
 Esta autenticación puede ser requerida por la aplicación, o alternativamente,
 hacerse de forma opcional.
\end_layout

\begin_layout Itemize
Garantiza la seguridad en la negociación de una clave secreta.
 La clave simétrica negociada no puede ser interceptada, ni siquiera por
 un atacante que se coloque entre los nodos y escuche toda la comunicación.
\end_layout

\begin_layout Itemize
Garantiza la integridad de la negociación, que será confiable, de forma
 que ningún atacante puede modificar la negociación sin ser detectado por
 los nodos.
\end_layout

\begin_layout Standard
TLS se sitúa en la capa de aplicación del modelo OSI.
 Esto quiere decir que son las aplicaciones las que deben incorporar una
 biblioteca 
\begin_inset Note Note
status open

\begin_layout Plain Layout
no hablar de biblioteca: mejor algoritmos o protocolos.
 La biblioteca es la implementación
\end_layout

\end_inset

que les habilite las capacidades de encriptación y de comunicación segura
 que proporciona este protocolo.
 Esto tiene varias implicaciones.
 Por un lado, los datos viajarán seguros desde la aplicación, sin que exista
 la posibilidad de que estos sean interceptados en una capa de red inferior.
 Por otro lado, el establecimiento de la conexión TLS deberá ser gestionado
 por la misma aplicación, no pudiéndose delegar al sistema operativo.
 Una ventaja de TLS es que es un protocolo independiente de la aplicación.
 Esto quiere decir que sobre él puede situarse cualquier protocolo de nivel
 superior de forma transparente.
\end_layout

\begin_layout Section
Criterios de diseño del protocolo
\end_layout

\begin_layout Standard
De acuerdo a las especificaciones del protocolo TLS
\begin_inset space ~
\end_inset

v1.2, los objetivos del mismo, en orden de prioridad, son los siguientes
 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5246-TLSv1.2"

\end_inset

:
\end_layout

\begin_layout Enumerate
Seguridad criptográfica: TLS debería usarse para establecer una conexión
 segura entre dos partes
\end_layout

\begin_layout Enumerate
Interoperabilidad: Programadores independientes deberían poder desarrollar
 aplicaciones usando TLS que puedan intercambiar parámetros criptográficos
 sin tener conocimiento del código de la otra parte.
\end_layout

\begin_layout Enumerate
Extensibilidad: TLS busca proveer una infraestructura en la que puedan incorpora
rse nuevos métodos de encriptación según sea necesario.
 De esta forma, se evita tener que definir nuevos protocolos de seguridad,
 con las consecuencias que esto tiene: la posibilidad de encontrar brechas
 de seguridad en el nuevo protocolo y la necesidad de implementarlo como
 una nueva biblioteca.
\end_layout

\begin_layout Enumerate
Eficiencia: Las operaciones criptográficas tienden a ser computacionalmente
 costosas, sobre todo cuando se trata de encriptación de clave pública.
 Por este motivo, el protocolo TLS trata de reducir el número de conexiones
 que se establecen desde cero, así como reducir la actividad de red.
\end_layout

\begin_layout Section
El 
\lang english
TLS Record Protocol
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
TLS Record Protocol
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Como hemos explicado anteriormente, e
\end_layout

\end_inset

El 
\lang english
TLS Record Protocol
\lang spanish
 es la capa más baja del protocolo TLS, y garantiza la comunicación segura
 entre los extremos.
 Los mensajes que van a ser transmitidos son procesados por el 
\lang english
TLS Record Protocol
\lang spanish
 en los siguientes pasos: los mensajes son fragmentados en bloques de un
 tamaño manejable, luego estos bloques pueden ser comprimidos, al resultado
 se le aplica un código MAC y finalmente es encriptado, quedando listo para
 la transmisión.
 En el otro extremo, los datos recibidos son desencriptados, verificados,
 descomprimidos (si procede), reagrupados en los bloques originales y entregados
 a la capa superior.
\end_layout

\begin_layout Standard
Existen cuatro protocolos que hacen uso inmediato del 
\lang english
TLS Record Protocol
\lang spanish
, y se presentan a continuación.
 Destacaremos que aunque estos son los protocolos definidos en la actualidad,
 el 
\emph on
TLS Record Protocol
\emph default
 puede dar soporte a otros tipos de mensaje (
\lang english
content types
\lang spanish
).
\end_layout

\begin_layout Subsubsection

\lang english
Handshake Protocol
\end_layout

\begin_layout Standard
Los parámetros criptográficos que se usarán en la sesión son acordados mediante
 el 
\lang english
TLS
\begin_inset space ~
\end_inset

Handshake Protocol
\lang spanish
.
 Este protocolo implica el intercambio de varios mensajes entre cliente
 y servidor, en los que se establece un secreto compartido, se lleva a cabo
 la autenticación de los nodos y finalmente, si se verifica que no se ha
 producido ningún intento de ataque, se configuran los parámetros del 
\lang english
TLS
\begin_inset space ~
\end_inset

Record Protocol
\lang spanish
 para que pueda comenzar la transmisión de los datos de aplicación.
\end_layout

\begin_layout Standard
Puesto que este protocolo está íntimamente relacionado con 
\begin_inset Note Note
status open

\begin_layout Plain Layout
el establecimiento de
\end_layout

\end_inset

 los parámetros criptográficos que se usarán en la sesión, y dado que el
 uso de estos parámetros requiere que estén disponibles en la implementación
 TLS a usar, dedicaremos una sección completa al 
\lang english
TLS
\begin_inset space ~
\end_inset

Handshake Protocol
\lang spanish
 más adelante en este mismo capítulo.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Pequeña descripción
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Se comentará en más detalle más adelante (cross ref)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\lang english
Alert Protocol
\end_layout

\begin_layout Standard
Los mensajes de alerta comunican la severidad de una alerta (
\lang english
warning
\lang spanish
 o 
\lang english
fatal
\lang spanish
) y su descripción.
 Un mensaje de alerta fatal resulta en la conclusión inmediata de la conexión.
 Como con el resto de protocolos, los mensajes de alerta son encriptados
 y comprimidos siguiendo las especificaciones del estado actual de la conexión.
\end_layout

\begin_layout Subsubsection

\lang english
Change Cipher Spec Protocol
\end_layout

\begin_layout Standard
El 
\lang english
TLS Change Cipher Spec Protocol
\lang spanish
 es usado para notificar un cambio en las estrategias de cifrado.
 El protocolo consiste en un mensaje único, que se comprime y encripta haciendo
 uso de los parámetros de cifrado actuales.
\end_layout

\begin_layout Standard
El mensaje 
\emph on
ChangeCipherSpec
\emph default
 es enviado tanto por el cliente como por el servidor para notificar que
 los mensajes enviados a continuación estarán protegidos atendiendo a las
 nuevas especificaciones de cifrado (
\emph on
CipherSpec
\emph default
) y claves establecidas.
\end_layout

\begin_layout Standard
Para ser más específicos, si un handshake tiene lugar durante una transmisión
 de datos, las partes pueden continuar comunicándose usando los parámetros
 establecidos en la anterior negociación.
 Es el mensaje 
\emph on
ChangeCipherSpec
\emph default
 el que señala el momento en el que las nuevas especificaciones serán usadas,
 por lo que cualquier mensaje recibido después de este deberá atender a
 los nuevos parámetros y claves de cifrado.
\end_layout

\begin_layout Subsubsection

\lang english
Application Protocol
\end_layout

\begin_layout Standard
Los datos de aplicación son transportados directamente por la 
\lang english
TLS
\begin_inset space ~
\end_inset

Record Layer
\lang spanish
, donde son fragmentados, comprimidos y encriptados atendiendo al estado
 de la conexión y a sus parámetros.
 De esta manera, los mensajes provenientes de la capa de aplicación son
 tratados de forma transparente por la 
\lang english
TLS
\begin_inset space ~
\end_inset

Record Layer
\lang spanish
.
\end_layout

\begin_layout Section
El 
\lang english
TLS Handshake Protocol
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
TLS Handshake Protocol
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
TLS cuenta con tres subprotocolos que permiten a los nodos negociar los
 parámetros de seguridad que serán usados en la Record Layer.
 Estos protocolos, además, permiten que los nodos puedan autenticarse, 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como se ha visto anteriormente, TLS tiene tres subprotocolos con los que
 los extremos de la conexión pueden acordar los parámetros de seguridad
 para la 
\lang english
TLS
\begin_inset space ~
\end_inset

Record Layer
\lang spanish
, autenticarse e informarse sobre errores producidos en la conexión.
\end_layout

\begin_layout Standard
El 
\lang english
TLS
\begin_inset space ~
\end_inset

Handshake Protocol
\lang spanish
 es responsable de negociar la sesión, cuyos principales elementos son:
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
session
\begin_inset space ~
\end_inset

identifier
\lang spanish
 secuencia de bytes arbitrarios elegidos por el servidor para identificar
 la sesión activa.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
peer
\begin_inset space ~
\end_inset

certificate
\lang spanish
 certificado del cliente o del servidor, definido por el estándar X.509 V3.
 Este elemento puede no estar presente.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
compression
\begin_inset space ~
\end_inset

method
\lang spanish
 algoritmo utilizado para comprimir datos antes de la encriptación.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
cipher
\begin_inset space ~
\end_inset

spec
\lang spanish
 especifica la función pseudo-aleatoria (
\lang english
pseudo-random function
\lang spanish
, PRF) que se usará para generar las claves, el algoritmo de encriptación
 simétrica (como AES, etc.) y el algoritmo de MAC (como HMAC-SHA1).
 También define los atributos criptográficos como la longitud de MAC, entre
 otros.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
master
\begin_inset space ~
\end_inset

secret
\lang spanish
 clave de 48 bytes compartida entre el cliente y el servidor.
\end_layout

\begin_layout Standard
Estos elementos son usados para crear los parámetros de seguridad que la
 
\lang english
TLS
\begin_inset space ~
\end_inset

Record Layer
\lang spanish
 usará para proteger los datos de aplicación.
 Distintas conexiones pueden ser instanciadas usando la misma sesión, gracias
 a la característica de reanudación del protocolo 
\lang english
TLS
\begin_inset space ~
\end_inset

Handshake Protocol
\lang spanish
.
\end_layout

\begin_layout Subsubsection
Descripción funcional del 
\lang english
TLS
\begin_inset space ~
\end_inset

Handshake Protocol
\end_layout

\begin_layout Standard
Los parámetros criptográficos del estado de la sesión son establecidos por
 el 
\lang english
TLS
\begin_inset space ~
\end_inset

Handshake Protocol
\lang spanish
, el cuál opera sobre la capa 
\lang english
TLS
\begin_inset space ~
\end_inset

Record Layer
\lang spanish
.
 Cuando un cliente y un servidor TLS comienzan a comunicarse por primera
 vez, negocian una versión del protocolo, eligen los algoritmos criptográficos,
 se autentican mutuamente (de forma opcional), y usan técnicas de criptografía
 asimétrica para generar claves compartidas.
\end_layout

\begin_layout Standard
El 
\lang english
TLS
\begin_inset space ~
\end_inset

Handshake Protocol
\lang spanish
 implica los siguientes pasos:
\end_layout

\begin_layout Itemize
Intercambio de mensajes 
\lang english
hello
\lang spanish
 para negociar los algoritmos, intercambiar valores aleatorios y comprobar
 si debe reanudarse una sesión anterior.
\end_layout

\begin_layout Itemize
Intercambio de los parámetros criptográficos necesarios para permitir que
 cliente y servidor puedan compartir una clave 
\emph on
pre-maestra
\emph default
 (
\lang english
pre-master secret
\lang spanish
).
\end_layout

\begin_layout Itemize
Intercambio de los certificados e información criptográfica para permitir
 que cliente y servidor puedan autenticarse mutuamente.
\end_layout

\begin_layout Itemize
Generación de una clave maestra (
\lang english
master secret
\lang spanish
) a partir de la clave pre-maestra e intercambiar valores aleatorios.
\end_layout

\begin_layout Itemize
Proporcionar parámetros de seguridad para la 
\lang english
TLS
\begin_inset space ~
\end_inset

Record Layer
\lang spanish
.
\end_layout

\begin_layout Itemize
Permitir que cliente y servidor verifiquen que el otro extremo ha calculado
 los mismos parámetros de seguridad y que por tanto el handshake se ha llevado
 a cabo sin la manipulación de un atacante.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/q009930a.gif
	lyxscale 60
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:TLS-Handshake"

\end_inset

Establecimiento de la conexión por el 
\lang english
TLS
\begin_inset space ~
\end_inset

Handshake Protocol
\lang spanish
 
\begin_inset CommandInset citation
LatexCommand cite
key "IBM:SSL-handshake"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
La 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:TLS-Handshake"

\end_inset

 muestra los pasos llevados a cabo en el establecimiento de la conexión
 TLS, de la que se encarga el 
\lang english
TLS
\begin_inset space ~
\end_inset

Handshake Protocol
\lang spanish
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
the handshake protocol, which can be summarized as follows: The client sends
 a ClientHello message to which the server must respond with a ServerHello
 message, or else a fatal error will occur and the connection will fail.
 The ClientHello and ServerHello are used to establish security enhancement
 capabilities between client and server.
 The ClientHello and ServerHello establish the following attributes: Protocol
 Version, Session ID, Cipher Suite, and Compression Method.
 Additionally, two random values are generated and exchanged: ClientHello.random
 and ServerHello.random.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Resumen
\end_layout

\begin_layout Standard
TLS
\begin_inset Index idx
status open

\begin_layout Plain Layout
Transport Layer Security (TLS)
\end_layout

\end_inset

 permite conexiones seguras a nivel de la capa de aplicación.
 El establecimiento de la conexión se lleva a cabo de forma segura, usando
 criptografía asimétrica para el intercambio de las claves compartidas,
 que serán usadas en el cifrado de los mensajes de aplicación.
 Durante el establecimiento de la conexión, conocido como handshake, los
 nodos pueden autenticarse mutuamente usando certificados digitales X.509.
\end_layout

\begin_layout Standard
El siguiente esquema resume las funcionalidades básicas de los distintos
 subprotocolos de TLS.
\end_layout

\begin_layout Enumerate
Handshake
\end_layout

\begin_deeper
\begin_layout Standard
Se encarga del establecimiento de la conexión entre dos nodos (cliente y
 servidor).
 El handshake conlleva:
\end_layout

\begin_layout Enumerate
Definición de los parámetros de seguridad a usar en la sesión (algoritmos
 de cifrado, clave, compresión, etc.), que son negociados entre cliente y
 servidor, de acuerdo con las funciones criptográficas implementadas en
 cada uno.
\end_layout

\begin_layout Enumerate
Autenticación mutua de los nodos cliente y servidor (opcional, puede llevarse
 a cabo en una única dirección).
\end_layout

\begin_layout Standard
El establecimiento de la conexión implica un esquema de criptografía asimétrica,
 usando claves relativamente largas generadas exclusivamente para la conexión
 a partir de una fuente de entropía.
 Este esquema es computacionalmente muy costoso, pero también muy seguro.
\end_layout

\begin_layout Enumerate
Gracias al esquema de criptografía asimétrica, el contenido del propio handshake
 queda oculto para un observador externo, haciendo imposible deducir los
 parámetros de la sesión.
\end_layout

\begin_layout Enumerate
El handshake cuenta con mecanismos de detección de 
\lang english
tampering
\lang spanish
, por lo que un ataque sería detectado.
\end_layout

\end_deeper
\begin_layout Enumerate
Intercambio de datos de aplicación
\end_layout

\begin_deeper
\begin_layout Standard
Los datos de la capa superior son transmitidos de forma transparente, usando
 los parámetros de seguridad establecidos.
\end_layout

\begin_layout Enumerate
Estos datos son cifrados usando criptografía simétrica, haciendo uso de
 la clave acordada durante el handshake.
\end_layout

\begin_layout Enumerate
Los datos de aplicación son comprimidos (de forma opcional) y fragmentados
 para optimizar el uso de la red.
\end_layout

\end_deeper
\begin_layout Enumerate
Cambios de especificación y alertas
\end_layout

\begin_deeper
\begin_layout Standard
Los nodos pueden cambiar los parámetros de seguridad en cualquier momento.
 Además, pueden intercambiar avisos o incluso cerrar la sesión si se detecta
 un problema serio de seguridad.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
QUE QUEDE CLARO LA PARTE INVESTIGADORA AQUI (bibliografia!!)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TLS se ha convertido en una referencia en cuanto a protocolos de seguridad,
 llegando a inspirar a otros protocolos, como 
\lang english
Datagram Transport Layer Security
\lang spanish
 (DTLS) 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc6347-dtls,rfc6347-dtls-1.2"

\end_inset

.
 DTLS tiene la ventaja de que puede operar a pesar de que se pierdan algunos
 paquetes en la conexión, por lo que no requiere un canal de comunicación
 confiable.
 Esta característica lo hace ideal para proporcionar seguridad a las aplicacione
s que hacen uso del protocolo UDP.
\end_layout

\begin_layout Standard
En el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Análisis-implementacions-TLS"

\end_inset

 hablaremos de distintas implementaciones de TLS.
 Cabe destacar aquí que una buena implementación del estándar debe cumplir
 con todos los requisitos definidos en el mismo.
 Sin embargo, no todas las implementaciones de TLS abarcan el amplio abanico
 de parámetros de seguridad disponibles, tales como funciones de cifrado
 simétrico, algoritmos de clave pública, funciones de hash, etc.
 Por este motivo, hablaremos de los conjuntos de funciones criptográficas,
 o 
\lang english
ciphersuites
\lang spanish

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ciphersuite
\end_layout

\end_inset

, para referirnos al conjunto de parámetros de seguridad disponibles en
 una implementación determinada
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Algunas implementaciones de TLS disponen de un gran conjunto de funciones
 criptográficas, pero permiten elegir un subconjunto de las mismas en tiempo
 de compilación.
 Esta forma de elegir el 
\lang english
ciphersuite
\lang spanish
 en tiempo de compilación será muy conveniente a la hora de integrar una
 implementación de TLS en un sistema empotrado, pues reduce el uso de recursos
 computacionales sin comprometer sin comprometer la versatilidad del protocolo.
\end_layout

\end_inset

.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:X509"

\end_inset

Certificados digitales X.509
\begin_inset Index idx
status open

\begin_layout Plain Layout
certificado digital
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La criptografía de clave pública hace posible que las personas que no comparten
 una clave común de antemano puedan comunicarse de forma segura.
 También hace que la firma de mensajes sea posible sin la presencia de un
 tercero confiable.
 Finalmente, la firma de los 
\lang english
message digests
\lang spanish
 hace posible que el destinatario verifique la integridad de los mensajes
 recibidos de forma fácil y segura.
 Sin embargo, hay un problema que no hemos resuelto aún.
 Se trata de la verificación de la identidad y de la obtención de la clave
 pública asociada a una entidad.
 Si fuéramos a intercambiar una clave privada con cualquier persona o entidad,
 lo primero que necesitaremos es su clave pública.
 Sin embargo, si esta clave se hace disponible en una web sin más, corremos
 el riesgo de que un posible atacante intercepte la comunicación con la
 web y nos haga creer que la clave es otra (la del propio atacante, por
 ejemplo).
 De esta forma, el atacante podría interceptar todo el intercambio de claves,
 quebrando la confidencialidad (y posiblemente la integridad) de la comunicación.
 Claramente, necesitamos algún mecanismo para garantizar que las claves
 públicas puedan intercambiarse de forma segura 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
\end_layout

\begin_layout Standard
Los certificados digitales de clave pública se fundamentan en la confianza
 depositada en una organización, la autoridad certificadora (
\lang english
certification authority
\lang spanish
, CA), de la que conocemos su identidad y clave pública.
 La CA certificará las claves públicas que pertenecen a personas, empresas
 y otras organizaciones, de forma que podamos verificar la correspondencia
 entre entidad y clave pública.
 El papel de la CA será verificar la identidad de una persona a través de
 un documento físico oficial (como el pasaporte) y emitir un documento que
 contendrá los datos del solicitante (principalmente su nombre), su clave
 pública, y un hash SHA firmado con la clave privada de la CA.
 Este documento es denominado certificado digital, y como vemos su trabajo
 fundamental es vincular una clave pública con el nombre de un sujeto (individuo
, empresa, etc.).
 
\end_layout

\begin_layout Standard
Los certificados en sí no son secretos ni están protegidos, pudiendo ser
 publicados sin riesgo alguno.
 Si un atacante tratara de modificar un certificado durante su transmisión,
 nos daríamos cuenta de que la firma no se corresponde con el hash de los
 campos del certificado.
 De igual forma, si el atacante introdujera un certificado válido, podríamos
 comprobar que este no contiene el nombre de la entidad que intentamos autentica
r.
 Una ventaja de este esquema es que la CA no tiene por qué estar en línea
 permanentemente.
 En cambio, su función se limita a proporcionar la firma de los certificados
 digitales, lo cuál se lleva a cabo con cada solicitud, tras la verificación
 de la identidad física de la persona o empresa en cuestión.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Copiar de Tanenbaum
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Certificados muy estándar (X.509 v3).
 Son intercambiado durante el handshake de TLS, para verificar la identidad.
 Es interesante conocer el contenido de estos certificados, y cómo funciona
 la verificación de la identidad.
\end_layout

\begin_layout Plain Layout
ITU-T Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
X.509
\end_layout

\end_inset

!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Contenido de los certificados
\end_layout

\begin_layout Standard
El estándar X.509 aprobado por la ITU (
\lang english
International Telecommunication Union
\lang spanish
) define el formato en el que deben presentarse los certificados digitales.
 Este estándar, que es usado ampliamente en Internet, ha pasado por tres
 versiones desde la estandarización inicial en 1988.
 Discutiremos la versión más reciente del mismo (X.509 V3), tal y como está
 definido por la IETF 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc2459-X509-1999,rfc5280-X509-2008"

\end_inset

.
 Los campos principales en un certificado se enumeran en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:X509-fields"

\end_inset

.
 A continuación se describe la función general de cada campo 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
Version
\lang spanish
 versión de X.509 con la que se ha generado el certificado.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
Serial
\begin_inset space ~
\end_inset

number
\lang spanish
 este número, junto con el nombre de la CA, identifica el certificado de
 forma unívoca.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
Signature
\begin_inset space ~
\end_inset

algorithm
\lang spanish
 el algoritmo usado para firmar el certificado.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
Issuer
\lang spanish
 nombre de la CA (en formado X.500).
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
Validity
\begin_inset space ~
\end_inset

period
\lang spanish
 fecha y hora del comienzo y fin de la validez del certificado.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
Subject
\begin_inset space ~
\end_inset

name
\lang spanish
 la entidad cuya clave está siendo certificada (en formado X.500).
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
Public
\begin_inset space ~
\end_inset

key
\lang spanish
 la clave pública del sujeto y la ID del algoritmo que hace uso de la misma.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
Issuer
\begin_inset space ~
\end_inset

ID
\lang spanish
 un ID opcional que identifica de forma unívoca al 
\lang english
issuer
\lang spanish
 del certificado.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
Subject
\begin_inset space ~
\end_inset

ID
\lang spanish
 un ID opcional que identifica de forma unívoca al sujeto del certificado.
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
Extensions
\lang spanish
 extensiones opcionales (existe una gran variedad de ellas).
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset


\lang english
Signature
\lang spanish
 firma del certificado (firmado con la clave privada de la CA).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/cert-digital.gif
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:X509-fields"

\end_inset

Campos principales de los certificados X.509 V3 
\begin_inset CommandInset citation
LatexCommand cite
key "Microsoft-X509-fields"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Cadena de confianza
\begin_inset Index idx
status open

\begin_layout Plain Layout
cadena de confianza
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
trust chain
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tener una única CA para emitir todos los certificados del mundo obviamente
 no funcionaría.
 Se colapsaría bajo la carga y también sería un punto crítico central.
 Una posible solución podría ser tener múltiples CA, todas gestionadas por
 la misma organización y todas usando la misma clave privada para firmar
 certificados.
 Si bien esto resolvería los problemas de carga y error, introduce un nuevo
 problema: la pérdida de la clave.
 Si hubiera docenas de servidores repartidos por todo el mundo, todos con
 la clave privada de la CA, la probabilidad de que la clave privada sea
 robada o se escape sería mucho mayor.
 Dado que el compromiso de esta clave arruinaría la infraestructura de cibersegu
ridad mundial, tener una CA central única es muy arriesgado.
 Además, es difícil imaginar una autoridad que sea aceptada en todo el mundo
 como legítima y confiable.
 En algunos países, insistirían en que esta autoridad fuera un gobierno,
 mientras que en otros países insistirían en que no sea un gobierno.
 
\end_layout

\begin_layout Standard
Por estos motivos, se ha desarrollado una forma diferente de certificar
 claves públicas, que se conoce con el nombre general de infraestructura
 de clave pública (
\lang english
public key infrastructure
\lang spanish
, PKI).
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
En esta sección, resumiremos cómo funciona de forma general.
\end_layout

\end_inset

 Una PKI tiene múltiples componentes, en los que se incluyen usuarios, CA,
 certificados y directorios.
 Lo que la PKI hace es proporcionar una forma de estructurar estos componentes
 y definir estándares para los diversos documentos y protocolos.
 Una forma particularmente simple de PKI es una jerarquía de CA, como la
 representada en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:pki-tanenbaum"

\end_inset

.
 En este ejemplo, se muestran tres niveles, pero en la práctica puede haber
 menos o más.
 La CA de nivel superior, denominada raíz (
\lang english
root CA
\lang spanish
), certifica las CA de segundo nivel, que aquí llamamos autoridades regionales
 (
\lang english
regional authorities
\lang spanish
, RA) porque podrían cubrir alguna región geográfica.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, como un país o continente.
 Sin embargo, este término no es estándar; de hecho, ningún término es realmente
 estándar para los diferentes niveles del árbol.
\end_layout

\end_inset

 Estos a su vez certifican las CA reales, que emiten los certificados X.509
 a organizaciones y particulares.
 Cuando la CA raíz autoriza una nueva RA, genera un certificado X.509, en
 el cual la CA declara que ha aprobado la RA, incluye la nueva clave pública
 de la RA, la firma y se la entrega a la RA.
 De forma similar, cuando un RA aprueba una nueva CA, produce y firma un
 certificado que indica su aprobación y que contiene la clave pública de
 la CA.
 A continuación resumimos el funcionamiento de la PKI del ejemplo.
\end_layout

\begin_layout Standard
Cuando queremos comunicarnos de forma segura con una organización concreta
 O, es posible que esta tenga un certificado firmado por, digamos, CA
\begin_inset space ~
\end_inset

5.
 Pero como es muy probable que no tengamos información sobre CA
\begin_inset space ~
\end_inset

5, deberemos dirigirnos hacia esta autoridad y solicitar que nos demuestre
 su legitimidad.
 La CA
\begin_inset space ~
\end_inset

5 responderá con el certificado que recibió de la RA
\begin_inset space ~
\end_inset

2, que contiene la clave pública de CA
\begin_inset space ~
\end_inset

5.
 Ahora podremos verificar que el certificado de la organización O gracias
 a la clave pública de CA
\begin_inset space ~
\end_inset

5.
 Sin embargo, si no tenemos información previa sobre CA
\begin_inset space ~
\end_inset

5, nos será difícil confiar en la legitimidad de O, por lo que el siguiente
 paso será solicitar a la RA
\begin_inset space ~
\end_inset

2 que demuestre que CA
\begin_inset space ~
\end_inset

5 es legítimo.
 La respuesta esta consulta es un certificado firmado por la raíz y que
 contiene la clave pública de RA
\begin_inset space ~
\end_inset

2.
 Ahora podremos estar seguros de que O tiene un certificado legítimo, por
 lo que podremos confiar en que la comunicación se llevará a cabo con la
 organización en cuestión y no con un atacante.
 
\end_layout

\begin_layout Standard
En este ejemplo solo queda una pregunta por responder, y es de dónde obtenemos
 la clave pública de la CA raíz.
 Esta es una pregunta difícil de responder, ya que se supone que todos conocen
 la clave pública de la CA raíz.
 La forma habitual, cuando se trata de páginas web, es que el navegador
 incorpore la clave pública de la CA raíz por defecto.
\end_layout

\begin_layout Standard
Una forma que tienen las organizaciones de agilizar el proceso de verificación
 es aportar todos (o alguno) de los certificados necesarios para la misma
 junto al certificado propio.
 De esta forma podremos verificar el certificado de la organización sin
 tener que establecer una nueva conexión con cada una de las CA intermediarias,
 ya que dispondremos de todos los certificados de la cadena.
 Además, como todos los certificados están firmados, será posible detectar
 fácilmente cualquier intento de manipular sus contenidos.
\end_layout

\begin_layout Standard
Una cadena de certificados que retrocede hasta la CA raíz, como la del ejemplo,
 se denomina cadena de confianza (
\lang english
trust chain
\lang spanish
) o ruta de certificación (
\lang english
certification path
\lang spanish
).
 Esta técnica es ampliamente utilizada en la práctica.
 Por supuesto, todavía tenemos el problema de quién va a gestionar la CA
 raíz.
 La solución no es tener una CA raíz única, sino tener muchas CA raíces,
 cada una con sus propias RA y CA.
 De hecho, los navegadores modernos vienen preconfigurados con las claves
 públicas para más de 100 raíces.
 De esta forma, se puede evitar tener una única autoridad de confianza en
 todo el mundo.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Pero ahora existe la cuestión de cómo el proveedor del navegador decide
 qué supuestas anclas de confianza son confiables y cuáles son sórdidas.
 Todo se reduce a que el usuario confíe en el proveedor del navegador para
 tomar decisiones acertadas y no simplemente aprobar todos los anclajes
 de confianza dispuestos a pagar su tarifa de inclusión.
 
\end_layout

\end_inset

Además, la mayoría de los navegadores permiten a los usuarios inspeccionar
 las claves raíz, pudiendo eliminar las que parecen oscuras o añadiendo
 claves nuevas.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/pki-tanenbaum.eps
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pki-tanenbaum"

\end_inset

(a) Ejemplo de infraestructura de clave pública jerárquica.
 (b) Cadena de certificados en esta PKI 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/chain-of-trust.png
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cadena de confianza con certificados X.509 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki:chain-of-trust"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Estructura y tipos de fichero
\end_layout

\begin_layout Standard
Los certificados digitales X.509 usan la codificación denominada 
\lang english
Abstract Syntax Notation
\lang spanish
 1 (ASN.1), definida por OSI.
 Este tipo de codificación es una especie de struct de
\begin_inset space ~
\end_inset

C, salvo porque tiene una notación mucho más verbosa y peculiar.
 Haciendo uso de esta notación los campos de los certificados se encapsulan
 en forma de ficheros.
 Existen dos extensiones comúnmente usadas para estos ficheros, dependiendo
 de si este se encuentra en formato binario (DER) o con una codificación
 ASCII adicional (PEM).
 Esta codificación adicional usa un conjunto de 64 caracteres ASCII con
 los que se codifica el contenido del binario usando palabras de 6 bits
 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc4648-Base64-encoding"

\end_inset

.
 La idea detrás de este tipo de codificación es maximizar la compatibilidad
 en el almacenamiento y la transmisión.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://en.wikipedia.org/wiki/X.690#BER_encoding
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://stackoverflow.com/questions/22743415/what-are-the-differences-between-pem
-cer-and-der
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
DER (Distinguished Encoding Rules) is the method of encoding the data that
 makes up the certificate.
 DER itself could represent any kind of data, but usually it describes an
 encoded certificate or a CMS container.
 The structure of a certificate is described using the ASN.1 data representation
 language.
 BER and DER are binary encoding methods for data described by ASN.1.
\end_layout

\begin_layout Plain Layout
PEM is a method of encoding binary data as a string (ASCII armor).
 It contains a header and a footer line (specifying the type of data that
 is encoded and showing begin/end if the data is chained together) and the
 data in the middle is the base 64 data.
 In the case that it encodes a certificate it would simply contain the base
 64 encoding of the DER certificate.
 PEM stands for Privacy Enhanced Mail; mail cannot contain unencoded binary
 values such as DER directly.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:AWS-IoT"

\end_inset

Amazon Web Services IoT
\end_layout

\begin_layout Standard
En este capítulo describiremos la arquitectura de la plataforma de Amazon
 para Internet de las Cosas (AWS
\begin_inset space ~
\end_inset

IoT
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
AWS IoT
\end_layout

\end_inset


\end_layout

\end_inset

), explorando su potencial y las particularidades que presenta.
\end_layout

\begin_layout Standard
Como se describe en la documentación oficial, AWS
\begin_inset space ~
\end_inset

IoT proporciona una
\emph on
 comunicación bidireccional segura
\emph default
 entre dispositivos conectados a Internet (ya sean sensores, actuadores,
 microcontroladores, electrodomésticos inteligentes, etc.) y la nube de Amazon
 (
\lang english
AWS
\begin_inset space ~
\end_inset

Cloud
\lang spanish
) 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-What-is-AWS-IoT"

\end_inset

.
 Esto nos permite recoger, almacenar y analizar datos de una gran variedad
 de dispositivos.
 Del mismo modo, nos permite crear aplicaciones para controlar estos dispositivo
s a través de un
\emph on
 
\emph default
\lang english
smartphone
\lang spanish
 o
\emph on
 
\emph default
\lang english
tablet
\lang spanish
.
\end_layout

\begin_layout Standard
En este sentido, AWS
\begin_inset space ~
\end_inset

IoT actúa como una pasarela a la cuál pueden conectarse tanto dispositivos
 como aplicaciones de terceros.
 Además, ofrece una interfaz sencilla para procesar los datos recogidos
 a través de los demás servicios de AWS.
 Este modo de operación hace que Amazon haya concentrado sus esfuerzos en
 una plataforma robusta y segura, dando soporte a empresas que desean construir
 aplicaciones complejas y escalables.
\begin_inset Note Note
status open

\begin_layout Plain Layout
 Por este motivo, AWS
\begin_inset space ~
\end_inset

IoT cuenta con un panel de control relativamente complejo, que nos permitirá
 gestionar una multitud de opciones.
 No obstante, esta plataforma no proporciona por sí misma herramientas para
 representar los datos obtenidos.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Componentes de AWS IoT
\end_layout

\begin_layout Standard
La plataforma AWS
\begin_inset space ~
\end_inset

IoT está formada por diversos módulos que trabajan orquestados para proporcionar
 la funcionalidad completa ofrecida por este servicio
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
proporcionar todas sus funcionalidades
\end_layout

\end_inset

.
 Con el fin de hacer un uso eficaz de la plataforma, conviene tener una
 imagen global de su arquitectura.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Solo de este modo entenderemos el significado de las configuraciones llevadas
 a cabo en la siguiente sección.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../../../Internet-de-las-Cosas/doc/img/AWS_IoT23._CB520207442_.png
	lyxscale 60
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Componentes-AWS"

\end_inset

Principales componentes de AWS
\begin_inset space ~
\end_inset

IoT 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-Alexa-Blog"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Componentes-AWS"

\end_inset

 muestra los componentes principales de AWS
\begin_inset space ~
\end_inset

IoT.
 Los elementos que quedan dentro del recuadro amarillo constituyen la plataforma
 propiamente dicha.
 Fuera del recuadro quedan los
\emph on
 dispositivos
\emph default
, las
\emph on
 aplicaciones
\emph default
 y los
\emph on
 servicios
\emph default
, tanto los de AWS como los de terceras partes.
 A continuación describimos los principales componentes de AWS
\begin_inset space ~
\end_inset

IoT 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-What-is-AWS-IoT"

\end_inset

.
\end_layout

\begin_layout Description
Pasarela
\begin_inset space ~
\end_inset

para
\begin_inset space ~
\end_inset

dispositivos
\begin_inset space ~
\end_inset

(
\lang english
Device
\begin_inset space ~
\end_inset

gateway
\lang spanish
) se encarga de establecer la comunicación entre la nube de Amazon y cada
 dispositivo.
 El 
\lang english
Device
\begin_inset space ~
\end_inset

gateway
\lang spanish
 es el responsable de que esta comunicación se lleve a cabo de forma eficiente
 y segura.
\end_layout

\begin_deeper
\begin_layout Description
Agente
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

mensajes
\begin_inset space ~
\end_inset

(
\lang english
Message
\begin_inset space ~
\end_inset

broker
\lang spanish
) proporciona un mecanismo seguro para que los dispositivos y las aplicaciones
 de AWS
\begin_inset space ~
\end_inset

IoT publiquen y reciban mensajes entre sí, basándose en el protocolo MQTT
 
\begin_inset CommandInset citation
LatexCommand cite
key "iso:mqtt"

\end_inset

 o en MQTT sobre WebSocket.
\end_layout

\end_deeper
\begin_layout Description
Motor
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

reglas
\begin_inset space ~
\end_inset

(
\lang english
Rules
\begin_inset space ~
\end_inset

engine
\lang spanish
) proporciona funciones de procesamiento de mensajes y de integración con
 otros servicios de la nube de Amazon.
 También permite usar el 
\lang english
Message
\begin_inset space ~
\end_inset

broker
\lang spanish
 para volver a publicar mensajes para otros suscriptores.
\end_layout

\begin_layout Description
Registro
\begin_inset space ~
\end_inset

(
\lang english
Registry
\lang spanish
) organiza los recursos asociados a cada dispositivo en la nube de Amazon.
 Es necesario registrar los dispositivos y asociar hasta tres atributos
 personalizados a cada uno.
 Este componente también es responsable de asociar los certificados digitales
 y los IDs de clientes MQTT a cada dispositivo.
\end_layout

\begin_deeper
\begin_layout Description
Registro
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

grupos
\begin_inset space ~
\end_inset

(
\lang english
Group
\begin_inset space ~
\end_inset

registry
\lang spanish
) permite administrar varios dispositivos a la vez clasificándolos en grupos.
\end_layout

\end_deeper
\begin_layout Description
Sombra
\begin_inset space ~
\end_inset

del
\begin_inset space ~
\end_inset

dispositivo
\begin_inset space ~
\end_inset

(
\lang english
Device
\begin_inset space ~
\end_inset

shadow
\lang spanish
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
sombra del dispositivo
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
device shadow
\end_layout

\end_inset

 documento JSON utilizado para
\begin_inset Note Note
status open

\begin_layout Plain Layout
almacenar y recuperar información
\end_layout

\end_inset

 representar el estado de un dispositivo.
 También es usado para solicitar una acción al dispositivo.
\end_layout

\begin_layout Standard
AWS
\begin_inset space ~
\end_inset

IoT dispone de otros componentes y servicios con los que el desarrollador
 puede interactuar para realizar algunas tareas de interés, como actualizar
 el firmware de sus dispositivos de forma remota, por ejemplo.
 No obstante, su uso es más avanzado y quedan fuera de los objetivos de
 este proyecto.
\end_layout

\begin_layout Standard
Cabe mencionar que tanto el agente de mensajes como el motor de reglas utilizan
 las características de seguridad de AWS.
 De este modo, solo los dispositivos y aplicaciones convenientemente autorizados
 pueden establecer una comunicación con AWS
\begin_inset space ~
\end_inset

IoT.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Esquema-de-funcionamiento"

\end_inset

Descripción funcional
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
un poco de blabla: ahora que conocemos los elementos básicos de la plataforma,
 vamos a ver cómo funcionan y cómo se relacionan con el exterior (nuestro
 dispositivo).
\end_layout

\end_inset

En esta sección describiremos el esquema general de funcionamiento de AWS
\begin_inset space ~
\end_inset

IoT.
 Será aquí donde desarrollaremos la relación entre los distintos elementos
 definidos anteriormente, así como su interacción con el mundo exterior.
\end_layout

\begin_layout Standard
Por un lado, tendremos dispositivos físicos ejecutando el
\emph on
 kit de desarrollo de software del dispositivo
\emph default
 (
\lang english
AWS
\begin_inset space ~
\end_inset

IoT
\begin_inset space ~
\end_inset

Device
\begin_inset space ~
\end_inset

SDK
\lang spanish
).
 Cada uno de estos dispositivos debe disponer de unas credenciales con las
 que se identificará y se autenticará ante la Nube.
 En general, estas credenciales vienen dadas por un certificado digital
 único para cada dispositivo.
 De forma adicional, el dispositivo debe incluir el certificado raíz de
 autoridad certificadora (
\lang english
CA root certificate
\lang spanish
), de modo que pueda autenticar a los servidores de Amazon.
\end_layout

\begin_layout Standard
Por otro lado, tendremos que definir estos dispositivos en la plataforma,
 usando el Servicio de registro (
\lang english
Registry
\lang spanish
) anteriormente descrito.
 Cada uno de estos dispositivos virtuales dispondrá de un
\emph on
 nombre único
\emph default
, que servirá para identificarlo, y de unos
\emph on
 atributos estáticos
\emph default
 a modo de descripción.
 Estos atributos estáticos pueden ser compartidos por dispositivos del mismo
 
\emph on
tipo
\emph default
, por lo que AWS
\begin_inset space ~
\end_inset

IoT proporciona esta unidad de organización a tal efecto.
 De forma adicional, el dispositivo puede tener uno o varios certificados
 asociados.
 En general, cada dispositivo virtual tendrá asociado el mismo certificado
 digital que instalemos en el dispositivo físico correspondiente, de forma
 que AWS
\begin_inset space ~
\end_inset

IoT pueda autenticarlo.
 Los certificados digitales definidos en la consola pueden tener asociadas
 una o varias políticas de uso (
\lang english
policies
\lang spanish
).
 Gracias a estas políticas de uso, distintos dispositivos tendrán permisos
 para realizar diferentes acciones, como puede ser publicar o suscribirse
 en determinados 
\lang english
topics
\lang spanish
, actualizar su sombra, etc.
\end_layout

\begin_layout Standard
Cabe destacar que los 
\emph on
Atributos estáticos
\emph default
 sirven para describir al dispositivo en sí, por lo que su función no debe
 confundirse con aquélla de la 
\emph on
Sombra del dispositivo
\emph default
.
 Mientras que estos atributos se almacenan de forma estática en el Registro,
 la sombra es un documento dinámico que contiene los valores de los sensores
 y el estado de los actuadores.
 Ejemplos de atributos estáticos son el número de serie, la versión de firmware,
 una breve descripción del dispositivo, etc.
 El siguiente epígrafe está dedicado a la sombra del dispositivo.
\end_layout

\begin_layout Subsection
Sombra del dispositivo
\begin_inset Index idx
status open

\begin_layout Plain Layout
sombra del dispositivo
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
device shadow
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El estado del dispositivo se guarda en un fichero JSON especial denominado
 sombra del dispositivo (
\lang english
device shadow
\lang spanish
).
 La sombra del dispositivo actúa como un intermediario entre dispositivos
 y aplicaciones, permitiendo que ambas partes tengan acceso al estado del
 dispositivo, pudiendo actualizarlo en ambos sentidos.
 Para que el estado del dispositivo pueda ser modificado por las aplicaciones,
 cada parámetro definido en la sombra podrá estar bajo una de las categorías
 
\lang english
reported
\lang spanish
 y 
\lang english
desired
\lang spanish
 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-Shadow-Syntax"

\end_inset

.
 
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "shadow.json"

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Ejemplo-de-sombra"

\end_inset

Ejemplo de sombra de dispositivo 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-Shadow-MQTT-Topics"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bajo la categoría 
\lang english
reported
\lang spanish
 tendremos un informe del estado confeccionado por el dispositivo.
 De este modo, podemos decir que los parámetros encontrados en esta categoría
 tienen un significado informativo del estado del dispositivo, y solo el
 dispositivo debería escribir en ellos.
 Es en esta sección donde encontraremos los valores de los sensores y el
 estado de los actuadores reportado por el dispositivo.
\end_layout

\begin_layout Standard
En la categoría 
\lang english
desired
\lang spanish
, en cambio, tendremos instrucciones para el dispositivo, como el cambio
 de color de un LED o el accionamiento de un motor.
 Como puede intuirse, esta categoría es confeccionada por la aplicación,
 debiendo ser revisada por el dispositivo para ejecutar las acciones solicitadas.
 Una vez completada la acción, el dispositivo actualizará el estado del
 actuador en el apartado 
\lang english
reported
\lang spanish
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../../../Internet-de-las-Cosas/doc/img/AWS_IoT_Shadow_Flow.png
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Flujo-de-mensajes-sombra"

\end_inset

Flujo de mensajes en la interacción entre el dispositivo y una aplicación
 a través de la sombra 
\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Flujo-de-mensajes-sombra"

\end_inset

 muestra el flujo de mensajes intercambiados entre el dispositivo y la aplicació
n, usando la sombra de intermediario.
 Como puede comprobarse, el estado publicado por el dispositivo (1) se almacena
 en un fichero JSON, la sombra del dispositivo, en la nube de Amazon (2).
 Este fichero será proporcionado a la aplicación cuando ésta realice una
 petición del estado del dispositivo (3).
 Cada vez que el usuario solicite un cambio de estado a través de la aplicación
 (4), estos cambios se almacenarán en el fichero JSON, hasta que el dispositivo
 se conecte a la Nube y ejecute una actualización de su estado (5).
 Será entonces cuando el dispositivo recibirá la acción solicitada bajo
 el apartado 
\lang english
desired
\lang spanish
 de la sombra.
 Una vez realizada la acción, con éxito o no, el dispositivo reportará su
 nuevo estado en el apartado 
\lang english
reported
\lang spanish
 (6).
 La aplicación será informada de inmediato, siempre y cuando esté en línea
 (7).
 El 
\begin_inset CommandInset ref
LatexCommand formatted
reference "alg:Ejemplo-de-sombra"

\end_inset

 muestra un ejemplo sencillo de sombra de dispositivo, en el que la aplicación
 requiere un cambio de color en el LED del dispositivo.
\end_layout

\begin_layout Standard
Una ventaja de la existencia de la sombra del dispositivo con respecto a
 otras implementaciones es que puede conocerse el estado del dispositivo
 aunque este se encuentre sin conexión.
 Evidentemente, en este caso no contaremos con el estado actualizado, pero
 podremos visualizar el último estado registrado.
 Además, la sombra cuenta con una serie de metadatos, en los que se incluye
 un sello temporal (
\lang english
timestamp
\lang spanish
) con la última actualización en cada uno de los sentidos de la comunicación.
 Del mismo modo, será posible enviar instrucciones a nuestro dispositivo
 independientemente de su conectividad.
\end_layout

\begin_layout Subsection
Esquema de conexión
\end_layout

\begin_layout Standard
Como en cualquier esquema IoT, el dispositivo se comunicará con la plataforma
 a través de una conexión a Internet.
 En el caso de AWS
\begin_inset space ~
\end_inset

IoT, la comunicación se lleva a cabo a través del protocolo MQTT, sobre
 un canal seguro TLS.
 Esta conexión se produce en varios pasos.
\end_layout

\begin_layout Standard
En primer lugar, el dispositivo, que tendrá el rol de cliente, inicia una
 comunicación segura TLS con el servidor de AWS
\begin_inset space ~
\end_inset

IoT.
 En esta primera comunicación servidor y cliente intercambian y verifican
 el certificado digital de la otra parte.
 De esta forma, la plataforma identifica y autentica el dispositivo, y el
 dispositivo se asegura de la autenticidad del servidor.
 En este proceso se establece una clave con la que se encriptarán todos
 los mensajes.
\end_layout

\begin_layout Standard
Una vez establecida la comunicación segura, el dispositivo puede publicar
 mensajes siguiendo el protocolo MQTT.
 Cuando el dispositivo trata de publicar un mensaje en un 
\lang english
topic
\lang spanish
, la plataforma verifica si este tiene permiso para publicar en dicho 
\lang english
topic
\lang spanish
.
 En caso afirmativo, el 
\lang english
message
\begin_inset space ~
\end_inset

broker 
\lang spanish
retransmite este mensaje a cualquier elemento de la red suscrito a este
 
\lang english
topic
\lang spanish
.
 Del mismo modo, el dispositivo puede suscribirse a cualquier 
\lang english
topic
\lang spanish
 siempre y cuando tenga permisos para ello.
\end_layout

\begin_layout Subsubsection
Actualización de la sombra
\begin_inset Index idx
status open

\begin_layout Plain Layout
sombra del dispositivo
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
device shadow
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La actualización de la sombra se lleva a cabo publicando mensajes en unos
 
\lang english
topics
\lang spanish
 especiales, destinados a este fin.
 En concreto, están definidos los siguientes 
\lang english
topics
\lang spanish
, donde el dispositivo queda identificado por la variable 
\family typewriter
thingName
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-Shadow-MQTT-Topics"

\end_inset

.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/shadow/update
\family default
 Tanto las aplicaciones como los dispositivos pueden publicar mensajes a
 este 
\lang english
topic
\lang spanish
 para actualizar la sombra.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/update/accepted
\family default
 AWS
\begin_inset space ~
\end_inset

IoT publica un mensaje en este 
\lang english
topic
\lang spanish
 para confirmar la actualización de la sombra.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/update/rejected
\family default
 AWS
\begin_inset space ~
\end_inset

IoT publica un mensaje en este 
\lang english
topic
\lang spanish
 para indicar que la actualización de la sombra no tuvo éxito.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/get
\family default
 Tanto las aplicaciones como los dispositivos pueden publicar un mensaje
 vacío a este 
\lang english
topic
\lang spanish
 para obtener la sombra.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/get/accepted
\family default
 AWS
\begin_inset space ~
\end_inset

IoT publica un mensaje en este 
\lang english
topic
\lang spanish
 para con la sombra actual.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/get/rejected
\family default
 AWS
\begin_inset space ~
\end_inset

IoT publica un mensaje de error en este 
\lang english
topic
\lang spanish
 para indicar que no se pudo recuperar la sombra.
\end_layout

\begin_layout Standard
De forma adicional, existen otros 
\lang english
topics
\lang spanish
 especiales relacionados con la sombra, cuyo uso es más avanzado.
\end_layout

\begin_layout Subsubsection
RESTful API
\end_layout

\begin_layout Standard
AWS
\begin_inset space ~
\end_inset

IoT dispone de una API
\begin_inset space ~
\end_inset

RESTful para permitir que las aplicaciones puedan conectarse e interactuar
 con la sombra a través del protocolo HTTPS.
 En este caso, la seguridad es similar a la llevada a cabo en el caso del
 dispositivo.
 La diferencia es que la aplicación puede tener una credencial basada en
 una tupla (ID,
\begin_inset space ~
\end_inset

clave) en vez de un certificado 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-Shadow-RESTful-API"

\end_inset

.
\end_layout

\begin_layout Section
Disparadores y reglas
\end_layout

\begin_layout Standard
Aunque no se han usado en la consecución de este proyecto, destacamos que
 AWS
\begin_inset space ~
\end_inset

IoT permite definir reglas con las que pueden realizarse diversas acciones
 al detectar eventos determinados.
 De este modo, es posible redireccionar mensajes entre distintos 
\lang english
topics
\lang spanish
 MQTT, detectar la superación de un umbral en un determinado parámetro,
 detectar la aparición de un mensaje concreto en un 
\lang english
topic
\lang spanish
, etc.
 Las acciones que pueden asociarse a un evento son muy variopintas, pero
 siempre implican una interacción con otros servicios de la nube de Amazon.
 Así, por ejemplo, es posible insertar un nuevo registro en una base de
 datos 
\emph on
AWS
\begin_inset space ~
\end_inset

DynamoDB
\emph default
, invocar una función 
\emph on
AWS
\begin_inset space ~
\end_inset

Lambda
\emph default
 o enviar mensajes específicos a 
\emph on
AWS
\begin_inset space ~
\end_inset

Salesforce
\emph default
 .
\end_layout

\begin_layout Section
Opciones de facturación
\end_layout

\begin_layout Standard
Amazon Web Services ofrece un amplio abanico de servicios de computación
 en la nube.
 Para cada servicio, el usuario debe abonar el precio correspondiente a
 los recursos consumidos.
 Aunque existen varias modalidades de facturación, todas ellas requieren
 que el usuario proporcione un método de pago.
 Sin embargo, existen dos alternativas gratuitas.
\end_layout

\begin_layout Subsubsection
\begin_inset space ~
\end_inset


\lang english
AWS Free Tier
\end_layout

\begin_layout Standard
Amazon establece un período de prueba gratuito para atraer nuevos clientes
 y dar a conocer su tecnología.
 En este período, es posible utilizar la mayoría de los servicios ofrecidos
 por AWS sin incurrir en gastos.
 No obstante, es necesario configurar un método de pago para comenzar a
 usar los servicios.
 Todos los detalles sobre 
\lang english
AWS
\begin_inset space ~
\end_inset

Free
\begin_inset space ~
\end_inset

Tier
\lang spanish
 están disponibles en 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://aws.amazon.com/free/
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-Free"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset space ~
\end_inset


\lang english
AWS Educate
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\lang english
AWS
\begin_inset space ~
\end_inset

Educate
\lang spanish
 proporciona a profesores y alumnos acceso a muchos de los servicios de
 AWS.
 Además, incluye ventajas como programas de capacitación y rutas profesionales
 en la nube de Amazon.
 Esta modalidad, que está disponible en 47 países, requiere que el usuario
 esté vinculado a alguna institución académica y procese una solicitud que
 será tratada de forma personalizada por Amazon
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Deberá usarse el correo institucional en la solicitud.
\end_layout

\end_inset

.
 Los detalles de esta modalidad están disponibles en 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://aws.amazon.com/education/
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-Education"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Nosotros hemos optado por esta segunda opción.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hablar de tarifas después del período gratuito!
\end_layout

\begin_layout Plain Layout
Comparar con: google, ibm, microsoft?
\end_layout

\end_inset


\end_layout

\end_body
\end_document
