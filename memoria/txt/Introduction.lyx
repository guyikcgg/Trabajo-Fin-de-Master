#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\master content.lyx
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Presentación del proyecto
\end_layout

\begin_layout Section
Motivación
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Here is a problem • It’s an interesting problem • It’s an unsolved problem
 • Here is my idea • My idea works (details, data) • Here’s how my idea
 compares to other people’s approaches
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Describe the problem • State your contributions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
De entre todas las revoluciones de Internet, el Internet de las Cosas (Internet
 of Things, IoT) es probablemente la que tiene mayor impacto en la actualidad.
 
\end_layout

\begin_layout Standard
IoT es muy guay, y está creciendo mucho -> Referencias académicas aquí!
\end_layout

\begin_layout Standard
Algunas empresas se lo toman en serio.
 Uno de los referentes, AWS 
\begin_inset Note Note
status open

\begin_layout Plain Layout
buscar otros
\end_layout

\end_inset

, no permite conexiones no seguras.
 Esto fuerza a las empresas que quieren trabajar con estos proveedores de
 servicio profesionales/robustos, que quieren hacer un buen producto, a
 integrar seguridad en sus sistemas.
 Es el ejemplo de eesy innovation, que tiene una gama de productos SmartHome
 (H2) usando tecnología IoT.
\end_layout

\begin_layout Section
Objetivos
\end_layout

\begin_layout Standard
El presente trabajo tiene como objetivo interconectar los productos de IoT
 de una empresa (eesy) con una plataforma bien conocida de IoT (AWS).
 Para ello, sera necesario integrar seguridad y conectividad a la plataforma.
\end_layout

\begin_layout Standard
El objetivo principal de este proyecto es integrar una implementación existente
 del protocolo TLS en un dispositivo IoT basado en microcontrolador.
 Este dispositivo es, en realidad, un pasarela (gateway) que permite la
 conexión entre una red local de sensores/actuadores instalada en una Smarthome
 e Internet.
 De este modo, conseguiremos que la transmisión de datos entre la red local
 y la nube se lleve a cabo de forma segura
\begin_inset Note Note
status open

\begin_layout Plain Layout
, permitiendo que el usuario y la casa se sientan seguros ;)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
De forma más concreta, los objetivos perseguidos en este trabajo fin de
 máster son los siguientes:
\end_layout

\begin_layout Enumerate
Estudio de los conceptos de seguridad en redes, en especial los que aplican
 a sistemas empotrados y al nuevo paradigma IoT.
 Breve presentación de TLS.
\end_layout

\begin_layout Enumerate
Análisis de las implementaciones TLS para sistemas empotrados.
 Elección de una de estas implementaciones.
\end_layout

\begin_layout Enumerate
Integración de la biblioteca TLS seleccionada en el sistema objetivo.
\end_layout

\begin_layout Enumerate
Estudio y presentación de la nube Amazon AWS.
 Breve presentación de MQTT.
\end_layout

\begin_layout Enumerate
Integración del AWS IoT SDK en el sistema objetivo.
 Prueba de concepto.
\end_layout

\begin_layout Standard
La pasarela está diseñada entorno a un microcontrolador XMC4500 de Infineon,
 que a su vez está basado en un núcleo ARM Cortex-M3.
 Esta pasarela deberá comunicarse con la nube de Amazon AWS IoT, con la
 que intercambiará mensajes mediante el protocolo MQTT.
\end_layout

\begin_layout Section
Metodología de trabajo
\end_layout

\begin_layout Standard
primero pc y luego microcontrolador
\end_layout

\begin_layout Standard
Tests a cada paso
\end_layout

\begin_layout Standard
El proyecto ha sido puesto bajo control de versiones, usando Git.
 Los sistemas de control de versiones permiten conservar un registro histórico
 de las acciones realizadas, pudiendo volver a estados pasados cuando se
 desee.
 Otra de las ventajas de usar un control de versiones es la posibilidad
 de crear ramas para gestionar las distintas características del proyecto.
 En este trabajo, para cada nueva línea de investigación se ha creado una
 rama, uniéndose los beneficios obtenidos a las ramas comunes.
 En concreto, el sistema de ramificaciones está basado en 
\begin_inset CommandInset citation
LatexCommand cite
key "Successful-Git"

\end_inset

.
 Git es además un sistema distribuido, siendo muy sencillo crear un repositorio
 de trabajo y compartirlo para permitir el trabajo en equipo, fundamental
 en cualquier ámbito de desarrollo, ya sea software o hardware.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Fácil integración con el resto del código del gateway: Diseño modular +
 control de versiones
\end_layout

\end_inset


\end_layout

\begin_layout Standard
IDE: DAVE (ver 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Entorno-de-trabajo"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Decir que se han entregado reports y código a la empresa de forma periódica,
 que el trabajo se ha realizado bajo su supervisión.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Estructura de la memoria
\end_layout

\begin_layout Standard
La memoria se estructura en tres grandes partes, que describimos a continuación.
\end_layout

\begin_layout Paragraph
Fundamentos teóricos y presentación de la tecnología
\end_layout

\begin_layout Standard
La primera parte está dedicada 
\begin_inset Note Note
status open

\begin_layout Plain Layout
a una breve introducción y
\end_layout

\end_inset

 a la presentación de las bases teóricas que permitirán una mejor comprensión
 del desarrollo del proyecto.
\end_layout

\begin_layout Standard
En primer lugar, llevaremos a cabo una exposición de los principios básicos
 de seguridad (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Principios-seguridad"

\end_inset

), prestando especial atención a los requisitos de seguridad en sistemas
 empotrados (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Seguridad-en-sist-empotrados"

\end_inset

).
\end_layout

\begin_layout Standard
A continuación presentaremos brevemente el protocolo TLS (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:TLS"

\end_inset

), los certificados digitales X.509 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:X509"

\end_inset

) y la estructura de la nube de Amazon AWS
\begin_inset space ~
\end_inset

IoT (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:AWS-IoT"

\end_inset

).
\end_layout

\begin_layout Paragraph
Trabajo realizado
\end_layout

\begin_layout Standard
En la segunda parte desarrollaremos con detalle el trabajo realizado durante
 la consecución de este proyecto.
\end_layout

\begin_layout Standard
Comenzaremos esta parte con una presentación pormenorizada del sistema objetivo
 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Descripción-del-sistema"

\end_inset

), a la que seguirá el anális de las imprementaciones TLS existentes y se
 justificará la eleción de mbedTLS (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Análisis-implementacions-TLS"

\end_inset

).
\end_layout

\begin_layout Standard
También presentaremos aquí los detalles de la integración de TLS en el sistema,
 así como los problemas que hemos tenido que resolver durante la misma (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementación-TLS"

\end_inset

).
 Pondremos fin a esta parte con los detalles de la integración del Kit de
 Desarrollo de Software para dispositivos embebidos programados en C de
 Amazon, AWS
\begin_inset space ~
\end_inset

IoT Device
\begin_inset space ~
\end_inset

SDK for embedded C (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Implementación-AWS-IoT"

\end_inset

).
 En cada uno de estos capítulos explicaremos las verificaciones y tests
 llevados a cabo, exponiendo los resultados obtenidos y planteando los problemas
 que hemos enfrentado.
\end_layout

\begin_layout Paragraph
Conclusiones y trabajo futuro
\end_layout

\begin_layout Standard
Para terminar, presentaremos las conclusiones obtenidas de la realización
 de este proyecto y disertaremos acerca de las posibles mejoras que podemos
 llevar a cabo en nuestro sistema (
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Conclusiones-y-trabajo-futuro"

\end_inset

)
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
incluyendo una prueba de concepto en la que veremos la comunicación entre
 el dispositivo y la nube IoT (capítulo
\begin_inset space ~
\end_inset

#)
\end_layout

\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 También expondremos las futuras líneas de trabajo (capítulo
\begin_inset space ~
\end_inset

#).
\end_layout

\end_inset


\end_layout

\begin_layout Part
Fundamentos teóricos y presentación de la tecnología
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Principios-seguridad"

\end_inset

Principios básicos de criptografía
\end_layout

\begin_layout Standard
El propósito de la criptografía es convertir un mensaje o fichero (
\emph on
texto plano
\emph default
) en algo que a priori carece de sentido (
\emph on
criptograma
\emph default
), de forma que solo las personas autorizadas pueden realizar la transformación
 inversa para acceder al contenido original.
 La operación de transformar el texto plano en un criptograma es conocida
 como 
\emph on
encriptación
\emph default
 o 
\emph on
cifrado
\emph default
, mientras que la operación inversa se denomina 
\emph on
desencriptación
\emph default
 o 
\emph on
descifrado
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Por su similitud al idioma anglosajón, preferiremos los términos encriptación
 (
\lang english
encryption
\lang spanish
) y desencriptación (
\lang english
decryption
\lang spanish
), a pesar de la disonancia de los mismos.
\end_layout

\end_inset

.
 Al contrario de lo que nos dice la intuición, uno de los fundamentos de
 la criptografía moderna, el principio de Kerckhoff, afirma que los algoritmos
 de cifrado y descifrado deben ser públicos.
 El uso de algoritmos secretos es una táctica conocida como 
\emph on
seguridad por oscuridad
\emph default
, y suele acarrear severos problemas de seguridad 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-ModernOS"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
 En su lugar, el único elemento que debe permanecer en secreto es la 
\emph on
clave
\emph default
, que se usa como parámetro de entrada en los algoritmos de cifrado y descifrado.
 De este modo, aunque los algoritmo de cifrado y descifrado sean conocidos,
 un potencial atacante que tenga acceso al criptograma no podrá descifrar
 el mensaje original si no posee la clave.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Introducir Two fundamental cryptographic principles: redundancy and freshness
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
La seguridad de un sistema criptográfico puede estudiarse 
\end_layout

\begin_layout Plain Layout
Para que un sistema criptográfico sea considerado seguro, este debe abordar
 una serie de problemasque le confieran las características listadas a continuac
ión.
\end_layout

\begin_layout Description
Confidencialidad los mensajes no deberán 
\end_layout

\begin_layout Plain Layout
que impidan deducir el contenido del mensaje a partir del criptograma (confidenc
ialidad), que per.
 También se deben evitar otros tipos de ataque, como replay attacks, etc
 (ver sección
\begin_inset space ~
\end_inset

#Requisitos generales de seguridad#).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A continuación formalizaremos los procesos de encriptación y desencriptación.
 Esto será útil para discurrir acerca de las diferentes técnicas de cifrado
 de las que haremos uso en este trabajo.
 Llamemos 
\begin_inset Formula $P$
\end_inset

 al texto plano, 
\begin_inset Formula $K_{E}$
\end_inset

 a la clave de encriptación, 
\begin_inset Formula $C$
\end_inset

 al criptograma y 
\begin_inset Formula $E$
\end_inset

 al algoritmo o función de encriptación.
 De esta forma, podemos definir el proceso de encriptación con la ecuación
 
\begin_inset Formula $C=E\left(P,K_{E}\right)$
\end_inset

.
 Esto sugiere que para obtener el criptograma es necesario aplicar el algoritmo
 de encriptación sobre el texto plano y la clave de encriptación, que son
 tomados como parámetros.
 De forma similar, podemos definir el proceso de desencriptación con la
 ecuación 
\begin_inset Formula $P=D\left(C,K_{D}\right)$
\end_inset

, donde 
\begin_inset Formula $D$
\end_inset

 es el algoritmo de desencriptación y 
\begin_inset Formula $K_{D}$
\end_inset

 es la clave de desencriptación, que puede sr distinta a la clave de encriptació
n.
 Esto indica que la obtención del texto plano a partir del criptograma pasa
 por aplicar la función de desencriptación a este criptograma, tomando como
 segundo parámetro la clave de desencriptación.
 La relación entre estas operaciones queda ilustrada en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Relacion-plaintext-ciphertext"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/relacion-plain-cipher.eps
	lyxscale 80
	width 86col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Relacion-plaintext-ciphertext"

\end_inset

Relación entre el texto plano y el texto cifrado.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aunque existe una multitud de algoritmos de encriptación y desencriptación
 disponibles, todos ellos caen en alguna de estas dos categorías: criptografía
 de clave simétrica y criptografía de clave pública.
 Estos dos tipos de cifrado se expondrán con detalle en los siguientes epígrafes.
\end_layout

\begin_layout Section
Criptografía de clave simétrica
\end_layout

\begin_layout Standard
Los algoritmos de cifrado de 
\emph on
clave simétrica
\emph default
 son llamados así porque usan la misma clave en la encriptación y en la
 desencriptación.
 Algunos de los algoritmos criptográficos de clave simétrica más conocidos
 son DES (
\lang english
Data Encription Standard
\lang spanish
, en desuso) y AES (
\lang english
Advanced Encription Standard
\lang spanish
).
 A continuación presentaremos los fundamentos de los algoritmos de 
\emph on
cifrado por bloques
\emph default
, que consiste en encriptar el texto plano dividiéndolo en bloques de 
\begin_inset Formula $n$
\end_inset

 bits, produciendo así el criptograma en bloques de la misma longitud.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Los algoritmos de cifrado por bloques pueden implementarse en hardware (para
 mayor velocidad) o en software (mayor flexibilidad).
 A continuación tratamos algunos aspectos de implementación en hardware
 para ilustrar los principios del cifrado por bloques.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para ilustrar los principios del cifrado por bloques, recurriremos a algunos
 aspectos de su implementación en hardware.
 De este modo, podemos decir que que cualquier método de cifrado por bloques
 puede descomponerse en una sucesión de dos elementos hardware muy sencillos:
 las 
\emph on
cajas de permutación
\emph default
 (P-box) y las 
\emph on
cajas de sustitución
\emph default
 (S-box), que se ilustran en la 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:P-box,S-box"

\end_inset

.
\end_layout

\begin_layout Standard
Las cajas de permutación producen una reordenación entre los bits de su
 entrada y de su salida, sin modificar el número de ceros o de unos presentes.
 Esto puede conseguirse a través de un cableado arbitrario entre cada uno
 de los bits de entrada y de salida.
 De esta forma, la operación de permutación solo requiere la propagación
 de la señal, que se lleva a cabo sin coste computacional alguno.
 Una caja de permutación correctamente diseñada será capaz de efectuar cualquier
 permutación deseada, reconfigurando su cableado.
 Como puede comprobarse, las cajas de permutación obedecen al principio
 de Kerckhoff: el método utilizado (la permutación de bits) es público,
 lo que se reserva es el orden en que se realiza este cableado, que hará
 las veces de clave.
\end_layout

\begin_layout Standard
Por otro lado, las cajas de sustitución cuentan con tres etapas.
 La primera de ellas es un decodificador, que 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/block-ciphers.eps
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:P-box,S-box"

\end_inset

Elementos básicos del cifrado por bloques 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
 (a)
\begin_inset space ~
\end_inset

P-box.
 (b)
\begin_inset space ~
\end_inset

S-box.
 (c)
\begin_inset space ~
\end_inset

Producto.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Cualquier método de cifrado por bloques puede verse como un diccionario
 que relaciona de forma única todas las posibles combinaciones de 
\begin_inset Formula $n$
\end_inset

 bits de texto plano con otra combinación (normalmente distinta) del mismo
 número de bits en el criptograma.
 De este modo, podemos decir que, 
\end_layout

\begin_layout Plain Layout
En su modo de operación más básico, cualquier cifrado por bloques actúa
 como un diccionario que permite 
\begin_inset Quotes fld
\end_inset

traducir
\begin_inset Quotes frd
\end_inset

 cualquier bloque de texto plano a otro bloque de la misma longitud del
 criptograma.
 Cuando los bloques 
\end_layout

\begin_layout Plain Layout
Dentro de esta categoría podemos distinguir dos estrategias: por un lado,
 tenemos el cifrado por bloques, que opera sobre bloques de un número 
\begin_inset Formula $n$
\end_inset

 de bits de texto plano, produciendo el criptograma en bloques de la misma
 longitud.
 Por otro lado, tenemos el cifrado de flujo, en los que los dígitos del
 texto plano se combinan con dígitos pseudoaleatorios where plaintext digits
 are combined with a pseudorandom cipher digit stream (keystream).
 In a stream cipher, each plaintext digit is encrypted one at a time with
 the corresponding digit of the keystream, to give a digit of the ciphertext
 stream
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Modos de cifrado
\end_layout

\begin_layout Subsubsection
Modo Electronic Code Book (ECB)
\end_layout

\begin_layout Standard
Cualquier método de cifrado por bloques, sin importar lo complejo que sea,
 puede verse como un diccionario que relaciona de forma única todas las
 posibles combinaciones de 
\begin_inset Formula $n$
\end_inset

 bits de texto plano con otra combinación (normalmente distinta) del mismo
 número de bits en el criptograma.
 De este modo, podemos decir que cualquier cifrado por bloques actúa como
 un diccionario que permite 
\begin_inset Quotes fld
\end_inset

traducir
\begin_inset Quotes frd
\end_inset

, en función de la clave utilizada, cualquier bloque de texto plano a otro
 bloque de la misma longitud del criptograma.
\end_layout

\begin_layout Standard
Este modo de cifrado es conocido como Electronic Code Book y es el más directo
 y el más eficiente en su implementación.
 Sin embargo, presenta una vulnerabilidad, que se hace más importante cuanto
 menor es tamaño del bloque.
 Puesto que 
\end_layout

\begin_layout Subsubsection
Modo Cipher Block Chaining (CBC)
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
To thwart this type of attack, all block ciphers can be chained in various
 ways so that replacing a block the way Leslie did will cause the plaintext
 decrypted starting at the replaced block to be garbage.
 One way of chaining is cipher block chaining.
 In this method, shown in Fig.
 8-12, each plaintext block is XORed with the previous ciphertext block
 before being encrypted.
 Consequently, the same plaintext block no longer maps onto the same ciphertext
 block, and the encryption is no longer a big monoalphabetic substitution
 cipher.
 The first block is XORed with a randomly chosen IV (Initialization Vector),
 which is transmitted (in plain- text) along with the ciphertext.
\end_layout

\begin_layout Plain Layout
We can see how cipher block chaining mode works by examining the example
 of Fig.
 8-12.
 We start out by computing C 0 = E(P 0 XOR IV).
 Then we compute C 1 = E(P 1 XOR C 0 ), and so on.
 Decryption also uses XOR to reverse the proc- ess, with P 0 = IV XOR D(C
 0 ), and so on.
 Note that the encryption of block i is a function of all the plaintext
 in blocks 0 through 
\begin_inset Formula $i-1$
\end_inset

, so the same plaintext gener- ates different ciphertext depending on where
 it occurs.
 A transformation of the type Leslie made will result in nonsense for two
 blocks starting at Leslie’s bonus field.
 To an astute security officer, this peculiarity might suggest where to
 start the ensuing investigation.
\end_layout

\begin_layout Plain Layout
Cipher block chaining also has the advantage that the same plaintext block
 will not result in the same ciphertext block, making cryptanalysis more
 difficult.
 In fact, this is the main reason it is used.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/CBC-mode-tanenbaum.eps
	width 85col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Modo de encriptación Cipher Block Chaining 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
 (a) Encriptación.
 (b) Desencriptación.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Criptografía de clave pública
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Historically, distributing the keys has always been the weakest link in
 most cryptosystems.
 No matter how strong a cryptosystem was, if an intruder could steal the
 key, the system was worthless.
 Cryptologists always took for granted that the encryption key and decryption
 key were the same (or easily derived from one another).
 But the key had to be distributed to all users of the system.
 Thus, it seemed as if there was an inherent problem.
 Keys had to be protected from theft, but they also had to be distributed,
 so they could not be locked in a bank vault.
 
\end_layout

\begin_layout Plain Layout
In 1976, two researchers at Stanford University, Diffie and Hellman (1976),
 proposed a radically new kind of cryptosystem, one in which the encryption
 and decryption keys were so different that the decryption key could not
 feasibly be derived from the encryption key.
 In their proposal, the (keyed) encryption algo- rithm, E, and the (keyed)
 decryption algorithm, D, had to meet three requirements.
 These requirements can be stated simply as follows:
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $D\left(E\left(P\right)\right)=P$
\end_inset


\end_layout

\begin_layout Enumerate
Es extremadamente difícil deducir 
\begin_inset Formula $D$
\end_inset

 a partir de 
\begin_inset Formula $E$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $E$
\end_inset

 debe resistir ataques de texto plano escogido (
\lang english
chosen-plaintext attack
\lang spanish
).
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
The first requirement says that if we apply D to an encrypted message, E(P),
 we get the original plaintext message, P, back.
 Without this property, the legitimate receiver could not decrypt the ciphertext.
 The second requirement speaks for it- self.
 The third requirement is needed because, as we shall see in a moment, in-
 truders may experiment with the algorithm to their hearts’ content.
 Under these conditions, there is no reason that the encryption key cannot
 be made public.
\end_layout

\begin_layout Plain Layout
The method works like this.
 A person, say, Alice, who wants to receive secret messages, first devises
 two algorithms meeting the above requirements.
 The en- cryption algorithm and Alice’s key are then made public, hence
 the name public- key cryptography.
 Alice might put her public key on her home page on the Web, for example.
 We will use the notation E A to mean the encryption algorithm parameterized
 by Alice’s public key.
 Similarly, the (secret) decryption algorithm parameterized by Alice’s private
 key is D A .
 Bob does the same thing, publicizing E B but keeping D B secret.
\end_layout

\begin_layout Plain Layout
Now let us see if we can solve the problem of establishing a secure channel
 between Alice and Bob, who have never had any previous contact.
 Both Alice’s encryption key, E A , and Bob’s encryption key, E B , are
 assumed to be in publicly readable files.
 Now Alice takes her first message, P, computes E B (P), and sends it to
 Bob.
 Bob then decrypts it by applying his secret key D B [i.e., he computes D
 B (E B (P)) = P].
 No one else can read the encrypted message, E B (P), because the encryption
 system is assumed to be strong and because it is too difficult to derive
 D B from the publicly known E B .
 To send a reply, R, Bob transmits E A (R).
 Alice and Bob can now communicate securely.
\end_layout

\begin_layout Plain Layout
A note on terminology is perhaps useful here.
 Public-key cryptography re- quires each user to have two keys: a public
 key, used by the entire world for en- crypting messages to be sent to that
 user, and a private key, which the user needs for decrypting messages.
 We will consistently refer to these keys as the public and private keys,
 respectively, and distinguish them from the secret keys used for conventional
 symmetric-key cryptography.
\end_layout

\begin_layout Plain Layout
RSA
\end_layout

\begin_layout Plain Layout
The only catch is that we need to find algorithms that indeed satisfy all
 three requirements.
 Due to the potential advantages of public-key cryptography, many researchers
 are hard at work, and some algorithms have already been published.
 One good method was discovered by a group at M.I.T.
 (Rivest et al., 1978).
 It is known by the initials of the three discoverers (Rivest, Shamir, Adleman):
 RSA.
 It has survived all attempts to break it for more than 30 years and is
 considered very strong.
 Much practical security is based on it.
 For this reason, Rivest, Shamir, and Adleman were given the 2002 ACM Turing
 Award.
 Its major disadvantage is that it requires keys of at least 1024 bits for
 good security (versus 128 bits for symmetric-key algorithms), which makes
 it quite slow.
\end_layout

\begin_layout Plain Layout
Other Public-Key Algorithms
\end_layout

\begin_layout Plain Layout
Other public-key schemes are based on the difficulty of computing discrete
 logarithms.
 Algorithms that use this principle have been invented by El Gamal (1985)
 and Schnorr (1991).
\end_layout

\begin_layout Plain Layout
A few other schemes exist, such as those based on elliptic curves (Menezes
 and Vanstone, 1993), but the two major categories are those based on the
 diffi- culty of factoring large numbers and computing discrete logarithms
 modulo a large prime.
 These problems are thought to be genuinely difficult to solve— mathematicians
 have been working on them for many years without any great breakthroughs.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Firmas digitales
\begin_inset Index idx
status open

\begin_layout Plain Layout
firma digital
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
digital signature
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
The authenticity of many legal, financial, and other documents is determined
 by the presence or absence of an authorized handwritten signature.
 And photocopies do not count.
 For computerized message systems to replace the physical transport of paper-and
-ink documents, a method must be found to allow documents to be signed in
 an unforgeable way.
\end_layout

\begin_layout Plain Layout
The problem of devising a replacement for handwritten signatures is a diffi-
 cult one.
 Basically, what is needed is a system by which one party can send a signed
 message to another party in such a way that the following conditions hold:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las firmas tradicionales se llevan usando mucho tiempo, para resolver los
 problemas:
\end_layout

\begin_layout Enumerate
The receiver can verify the claimed identity of the sender.
 
\end_layout

\begin_layout Enumerate
The sender cannot later repudiate the contents of the message.
 
\end_layout

\begin_layout Enumerate
The receiver cannot possibly have concocted the message himself.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
The first requirement is needed, for example, in financial systems.
 When a customer’s computer orders a bank’s computer to buy a ton of gold,
 the bank’s computer needs to be able to make sure that the computer giving
 the order really belongs to the customer whose account is to be debited.
 In other words, the bank has to authenticate the customer (and the customer
 has to authenticate the bank).
\end_layout

\begin_layout Plain Layout
The second requirement is needed to protect the bank against fraud.
 Suppose that the bank buys the ton of gold, and immediately thereafter
 the price of gold drops sharply.
 A dishonest customer might then proceed to sue the bank, claiming that
 he never issued any order to buy gold.
 When the bank produces the message in court, the customer may deny having
 sent it.
 The property that no party to a contract can later deny having signed it
 is called nonrepudiation.
 The digital sig- nature schemes that we will now study help provide it.
\end_layout

\begin_layout Plain Layout
The third requirement is needed to protect the customer in the event that
 the price of gold shoots up and the bank tries to construct a signed message
 in which the customer asked for one bar of gold instead of one ton.
 In this fraud scenario, the bank just keeps the rest of the gold for itself.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Estos problemas son de gran importancia con las transacciones bancarias,
 etc.
 Sin embargo, cuando nos movemos al mundo digital, tenemos un puñado de
 ceros y unos.
 cómo saber si un documento es auténtico? firmas digitales.
 Las firmas digitales resuelven estos problemas (authenticity, non repudiation
 y ...).
 Existen varias modalidades de firmas digitales, la más usada hoy en día
 #ref# es la que se basa en clave pública.
\end_layout

\begin_layout Subsection
Firmas digitales de clave pública
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
A structural problem with using symmetric-key cryptography for digital sig-
 natures is that everyone has to agree to trust Big Brother.
 Furthermore, Big Brother gets to read all signed messages.
 The most logical candidates for running the Big Brother server are the
 government, the banks, the accountants, and the lawyers.
 Unfortunately, none of these inspire total confidence in all citizens.
 Hence, it would be nice if signing documents did not require a trusted
 authority.
\end_layout

\begin_layout Plain Layout
Fortunately, public-key cryptography can make an important contribution
 in this area.
 Let us assume that the public-key encryption and decryption algorithms
 have the property that E(D(P)) = P, in addition, of course, to the usual
 property that D(E(P)) = P.
 (RSA has this property, so the assumption is not unrea- sonable.) Assuming
 that this is the case, Alice can send a signed plaintext mes- sage, P,
 to Bob by transmitting E B (D A (P)).
 Note carefully that Alice knows her own (private) key, D A , as well as
 Bob’s public key, E B , so constructing this mes- sage is something Alice
 can do.
\end_layout

\begin_layout Plain Layout
When Bob receives the message, he transforms it using his private key, as
 usual, yielding D A (P), as shown in Fig.
 8-19.
 He stores this text in a safe place and then applies E A to get the original
 plaintext.
\end_layout

\begin_layout Plain Layout
To see how the signature property works, suppose that Alice subsequently
 denies having sent the message P to Bob.
 When the case comes up in court, Bob can produce both P and D A (P).
 The judge can easily verify that Bob indeed has a valid message encrypted
 by D A by simply applying E A to it.
 Since Bob does not know what Alice’s private key is, the only way Bob could
 have acquired a mes- sage encrypted by it is if Alice did indeed send it.
 While in jail for perjury and fraud, Alice will have much time to devise
 interesting new public-key algorithms.
\end_layout

\begin_layout Plain Layout
Although using public-key cryptography for digital signatures is an elegant
 scheme, there are problems that are related to the environment in which
 they oper- ate rather than to the basic algorithm.
 For one thing, Bob can prove that a mes- sage was sent by Alice only as
 long as D A remains secret.
 If Alice discloses her secret key, the argument no longer holds, because
 anyone could have sent the message, including Bob himself.
\end_layout

\begin_layout Plain Layout
The problem might arise, for example, if Bob is Alice’s stockbroker.
 Suppose that Alice tells Bob to buy a certain stock or bond.
 Immediately thereafter, the price drops sharply.
 To repudiate her message to Bob, Alice runs to the police claiming that
 her home was burglarized and the PC holding her key was stolen.
 Depending on the laws in her state or country, she may or may not be legally
 liable, especially if she claims not to have discovered the break-in until
 getting home from work, several hours after it allegedly happened.
\end_layout

\begin_layout Plain Layout
Another problem with the signature scheme is what happens if Alice decides
 to change her key.
 Doing so is clearly legal, and it is probably a good idea to do so periodically.
 If a court case later arises, as described above, the judge will apply
 the current E A to D A (P) and discover that it does not produce P.
 Bob will look pretty stupid at this point.
\end_layout

\begin_layout Plain Layout
In principle, any public-key algorithm can be used for digital signatures.
 The de facto industry standard is the RSA algorithm.
 Many security products use it.
 However, in 1991, NIST proposed using a variant of the El Gamal public-key
 al- gorithm for its new Digital Signature Standard (DSS).
 El Gamal gets its securi- ty from the difficulty of computing discrete
 logarithms, rather than from the diffi- culty of factoring large numbers.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El proceso explicado también puede llevarse a cabo empleando un hash del
 mensaje, en vez del mensaje completo.
 Este método tiene dos ventajas: por un lado, el hash será más corto que
 el mensaje, por lo que será más eficiente de (des)cifrar; por otro lado,
 separamos los pasos/funciones de autenticación y confidencialidad.
\end_layout

\begin_layout Section
Funciones hash criptográficas
\begin_inset Index idx
status open

\begin_layout Plain Layout
hash
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
message digest
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
One criticism of signature methods is that they often couple two distinct
 func- tions: authentication and secrecy.
 Often, authentication is needed but secrecy is not always needed.
 Also, getting an export license is often easier if the system in question
 provides only authentication but not secrecy.
 Below we will describe an authentication scheme that does not require encryptin
g the entire message.
\end_layout

\begin_layout Plain Layout
This scheme is based on the idea of a one-way hash function that takes an
 arbitrarily long piece of plaintext and from it computes a fixed-length
 bit string.
 This hash function, MD, often called a message digest, has four important
 proper- ties:
\end_layout

\begin_layout Enumerate
Given P, it is easy to compute MD(P).
 
\end_layout

\begin_layout Enumerate
Given MD(P), it is effectively impossible to find P.
 
\end_layout

\begin_layout Enumerate
Given P, no one can find P' such that MD (P') = MD(P).
 
\end_layout

\begin_layout Enumerate
A change to the input of even 1 bit produces a very different output.
\end_layout

\begin_layout Plain Layout
To meet criterion 3, the hash should be at least 128 bits long, preferably
 more.
 To meet criterion 4, the hash must mangle the bits very thoroughly, not
 unlike the symmetric-key encryption algorithms we have seen.
\end_layout

\begin_layout Plain Layout
Computing a message digest from a piece of plaintext is much faster than
 en- crypting that plaintext with a public-key algorithm, so message digests
 can be used to speed up digital signature algorithms.
 To see how this works, consider the signature protocol of Fig.
 8-18 again.
 Instead, of signing P with K BB (A, t, P), BB now computes the message
 digest by applying MD to P, yielding MD(P).
 BB then encloses K BB (A, t, MD(P)) as the fifth item in the list encrypted
 with K B that is sent to Bob, instead of K BB (A, t, P).
\end_layout

\begin_layout Plain Layout
If a dispute arises, Bob can produce both P and K BB (A, t, MD(P)).
 After Big Brother has decrypted it for the judge, Bob has MD(P), which
 is guaranteed to be genuine, and the alleged P.
 However, since it is effectively impossible for Bob to find any other message
 that gives this hash, the judge will easily be convinced that Bob is telling
 the truth.
 Using message digests in this way saves both encryption time and message
 transport costs.
\end_layout

\begin_layout Plain Layout
Message digests work in public-key cryptosystems, too, as shown in Fig.
 8- 20.
 Here, Alice first computes the message digest of her plaintext.
 She then signs the message digest and sends both the signed digest and
 the plaintext to Bob.
 If Trudy replaces P along the way, Bob will see this when he computes MD(P).
\end_layout

\begin_layout Plain Layout
SHA-1 y SHA-2
\end_layout

\begin_layout Plain Layout
A variety of message digest functions have been proposed.
 One of the most widely used functions is SHA-1 (Secure Hash Algorithm 1)
 (NIST, 1993).
 Like all message digests, it operates by mangling bits in a sufficiently
 complicated way that every output bit is affected by every input bit.
 SHA-1 was developed by NSA and blessed by NIST in FIPS 180-1.
 It processes input data in 512-bit blocks, and it generates a 160-bit message
 digest.
 A typical way for Alice to send a nonsecret but signed message to Bob is
 illustrated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Uso-de-SHA-1"

\end_inset

.
 Here, her plaintext message is fed into the SHA-1 algorithm to get a 160-bit
 SHA-1 hash.
 Alice then signs the hash with her RSA private key and sends both the plaintext
 message and the signed hash to Bob.
\end_layout

\begin_layout Plain Layout
After receiving the message, Bob computes the SHA-1 hash himself and also
 applies Alice’s public key to the signed hash to get the original hash,
 H.
 If the two agree, the message is considered valid.
 Since there is no way for Trudy to modify the (plaintext) message while
 it is in transit and produce a new one that hashes to H, Bob can easily
 detect any changes Trudy has made to the message.
 For messages whose integrity is important but whose contents are not secret,
 the scheme of Fig.
 8-21 is widely used.
 For a relatively small cost in computation, it guarantees that any modification
s made to the plaintext message in transit can be detected with very high
 probability.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/sha1-tanenbaum.eps
	width 85col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Uso-de-SHA-1"

\end_inset

Uso de SHA-1 y RSA para la firma de un documento no confidencial 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-Computer-Networks"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Seguridad-en-sist-empotrados"

\end_inset

Seguridad en sistemas empotrados
\end_layout

\begin_layout Standard
Como hemos visto en el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Principios-seguridad"

\end_inset

, una parte importante de la ciberseguirdad depende del uso de funciones
 y algoritmos complejos, que suelen estar relacionados con operaciones computaci
onalmente muy costosas.
 Sin embargo, los sistemas empotrados, como los usados en los nodos finales
 y en las pasarelas de las infraestructuras IoT, suelen disponer de recursos
 muy limitados.
 Esta escasez de recursos impondrá una serie de limitaciones, que van desde
 limitaciones computacionales (baja frecuencia de la CPU, escasa memoria)
 hasta limitaciones energéticas (sistemas autónomos alimentados por baterías)
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, que a su vez se traduce en limitaciones en el tiempo de cómputo empleable
\end_layout

\end_inset

.
 Por otro lado, los sistemas embebidos son responsables, en numerosas ocasiones,
 de llevar a cabo funciones críticas, que podrían poner en peligro la integridad
 física del usuario en caso de fallo.
 Debido a estos factores, la seguridad en sistemas empotrados debe ser tratada
 de un modo especial.
\end_layout

\begin_layout Standard
Aunque a continuación hablaremos de requisitos generales de seguridad, conviene
 mencionar que son muchas las entidades involucradas en la cadena de diseño,
 fabricación y uso de un sistema embebido típico.
 Los requisitos de seguridad dependerán de la perspectiva que consideremos,
 tal y como ilustra la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Actores-implicados-requisitos-seguridad"

\end_inset

, con el ejemplo de un teléfono móvil.
 En el ejemplo, el usuario estará interesado en mantener la confidencialidad
 y la integridad de los datos que almacena o transmite haciendo uso del
 sistema.
 El proveedor de hardware, por su parte, tratará de proteger la propiedad
 intelectual de los módulos provistos al diseñador del dispositivo.
 El proveedor de contenidos, en cambio, tratará de evitar la copia ilegal
 de los contenidos multimedia ofrecidos al usuario.
 De esta forma, las entidades no confiables (potencialmente maliciosas)
 también variarán dependiendo de la perspectiva considerada 
\begin_inset CommandInset citation
LatexCommand cite
key "ravi2004security"

\end_inset

.
\end_layout

\begin_layout Standard
En las siguientes secciones daremos una definición para los sistemas empotrados
 y estudiaremos sus características más relevantes.
 También presentaremos algunos de los requisitos de seguridad fundamentales
 en cualquier sistema informático.
 Finalmente, introduciremos las soluciones de seguridad con las que se abordan
 estos requisitos.
 Con esto habremos dado las primeras pinceladas en la definición de los
 requisitos de seguridad de nuestro sistema.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
unas pinceladas con las que empezaremos a comprender cuáles serán los requisitos
 de seguridad de nuestro sistema.
\end_layout

\begin_layout Plain Layout
pretendemos ofrecer una imagen más definida de los que serán los requisitos
 de seguridad de nuestro sistema.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/actores-implicados-seguridad.png
	lyxscale 10
	width 55col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Actores-implicados-requisitos-seguridad"

\end_inset

Actores implicados y requisitos de seguridad de un terminal móvil 
\begin_inset CommandInset citation
LatexCommand cite
key "ravi2004security"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Particularidades de los sistemas empotrados
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Como hemos introducido anteriormente, los sistemas empotrados presentan
 varias particularidades que nos harán .
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los sistemas empotrados
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
sistema empotrado
\end_layout

\end_inset

 (también conocidos como sistemas embebidos
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
sistema embebido
\end_layout

\end_inset

 o 
\emph on
embedded system
\emph default
s
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
embedded system
\end_layout

\end_inset

) son sistemas basados en computador y que están diseñados para realizar
 una función concreta.
 Muchos sistemas empotrados llevan a cabo tareas a tiempo real, siendo frecuente
 su uso en el control de sistemas mecánicos, como ascensores o cadenas de
 montaje 
\begin_inset CommandInset citation
LatexCommand cite
key "EmbeddedSysDesign"

\end_inset

.
\end_layout

\begin_layout Standard
Además, estos sistemas están presentes en muchos electrodomésticos, como
 hornos microondas, lavadoras o reproductores de música.
 En este contexto, también los encontramos en el núcleo de muchos dispositivos
 cotidianos, como la calculadora, la cámara de fotos o el marcapasos 
\begin_inset CommandInset citation
LatexCommand cite
key "Tanenbaum-ModernOS"

\end_inset

.
\end_layout

\begin_layout Standard
Podría discutirse si algunos dispositivos como los 
\emph on
smartpohnes
\emph default
 o las videoconsolas de última generación son también sistemas empotrados.
 No obstante, estos dispositivos cuentan con un sistema operativo (
\lang english
OS
\lang spanish
) que les permite ejecutar aplicaciones de terceros bajo demanda del usuario.
 Por este motivo, estos dispositivos serán considerados en este trabajo
 como computadores de propósito general, a pesar de compartir algunas caracterís
ticas con los sistemas empotrados.
\end_layout

\begin_layout Standard
Estas son las principales características que consideraremos para decir
 que un sistema es empotrado 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
Se trata de un sistema electrónico basado en microprocesador (normalmente
 microcontrolador).
\end_layout

\begin_layout Itemize
El sistema está diseñado para llevar a cabo una aplicación o tarea específica,
 ejecutando un software concreto que es instalado en el proceso de producción.
 El sistema no está diseñado para ejecutar software de terceros.
\end_layout

\begin_layout Itemize
El sistema cuenta con los periféricos necesarios para llevar a cabo su función.
 El sistema está diseñado para controlar este hardware específico, no permitiend
o que se añadan nuevos periféricos.
\end_layout

\begin_layout Itemize
El sistema puede ser el núcleo de un dispositivo autónomo (como un mando
 a distancia), o puede formar parte de un sistema mayor (como las distintas
 unidades de control electrónico de un automóvil).
\end_layout

\begin_layout Standard
En aras de la exhaustividad, y aunque no es un problema que afecte directamente
 a este proyecto, destacaremos los requisitos temporales de algunos sistemas
 empotrados.
 En numerosas ocasiones, las tareas deben ser realizadas en tiempo real,
 proporcionando respuestas a ciertos eventos en un intervalo de tiempo controlad
o y reducido.
 Esto tiene gran relación con la tendencia a usar sistemas empotrados en
 la implementación de sistemas críticos.
 Los sistemas críticos deben ser altamente fiables, llevando a cabo su función
 de forma rigurosa y precisa.
 En caso de error, un sistema crítico puede desencadenar un fallo general
 del sistema, incurrir en enormes pérdidas económicas o incluso poner en
 riesgo la vida de personas.
\end_layout

\begin_layout Section
Requisitos generales de seguridad
\end_layout

\begin_layout Standard
Como hemos mencionado anteriormente, los recursos computacionales de los
 sistemas empotrados suelen ser muy limitados.
 Esto supone un abaratamiento de costes que se hace muy relevante en la
 producción en masa de los dispositivos.
 Sin embargo, esta escasez de recursos, junto al 
\begin_inset Quotes fld
\end_inset

propósito no general
\begin_inset Quotes frd
\end_inset

 de estos sistemas, hace que estos carezcan de un sistema operativo propiamente
 dicho, con todas las consecuencias que esto conlleva.
\end_layout

\begin_layout Standard
En los sistemas empotrados más complejos es frecuente el uso de un planificado
 de tareas (
\lang english
scheduler
\lang spanish
) sencillo, o de un sistema operativo de tiempo real (
\lang english
real-time operating system
\lang spanish
, RTOS), con los que se facilita el desarrollo y ejecución de procesos concurren
tes.
 Estas herramientas suelen permitir una buena gestión de las tareas de tiempo
 real, sin embargo no cuentan con los servicios proporcionados por un sistema
 operativo, como una pila de red, un sistema de ficheros, o la posibilidad
 de ejecutar software de terceros.
 Por este motivo, tendremos que estudiar cuidadosamente los requisitos de
 seguridad del sistema, ya que todos ellos deberán ser implementados por
 el equipo de desarrollo del mismo.
\end_layout

\begin_layout Standard
A continuación presentamos los requisitos de seguridad más relevantes en
 cualquier sistema informático 
\begin_inset CommandInset citation
LatexCommand cite
key "ravi2004security"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Qué se debe asegurar y cuáles son las dificultades (escasa CPU, RAM, batería,
 etc).
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Identificación de usuarios
\end_layout

\begin_layout Standard
Se trata del proceso de validar a los usuarios antes de permitirles usar
 es sitema.
 Este requisito es fundamental cuando el sistema proporciona el acceso a
 datos sensibles (como los valores de sensores en un
\emph on
 SmartHome
\emph default
), a servicios restringidos (como llamadas telefónicas) o permite el control
 de otro sistema (como una cerradura electrónica o la calefacción).
\end_layout

\begin_layout Standard
La identificación de usuarios es especialmente importante cuando el sistema
 empotrado puede ser accedido con facilidad por personas no autorizadas,
 como son aquellos que están conectados a Internet.
\end_layout

\begin_layout Subsubsection
Acceso seguro a la red
\end_layout

\begin_layout Standard
Consiste en proporcionar acceso a una conexión de red o a un servicio solo
 si el dispositivo está autorizado.
 Por ejemplo, un router doméstico no debería permitir el acceso a ningún
 dispositivo que no haya sido autorizado a usar la red.
 Del mismo modo, una pasarela IoT no deberá retransmitir datos de una red
 de sensores ajena.
\end_layout

\begin_layout Subsubsection
Comunicación segura
\end_layout

\begin_layout Standard
La comunicación segura incluye varias funciones, que se listan a continuación.
 También proporcionamos explicaciones con ejemplos concernientes al presente
 proyecto.
\end_layout

\begin_layout Enumerate
Autenticar
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
autenticación
\end_layout

\end_inset

 las partes a los extremos de la comunicación, ya sean personas o sistemas
 informáticos.
\end_layout

\begin_deeper
\begin_layout Standard
En el caso que nos ocupa, necesitaremos un mecanismo para verificar la identidad
 de los nodos de la red.
 Solo así podremos asegurarnos que los datos mostrados en la terminal son,
 efectivamente, los medidos por nuestros dispositivos.
\end_layout

\end_deeper
\begin_layout Enumerate
Garantizar la confidencialidad
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
confidencialidad
\end_layout

\end_inset

 de los datos comunicados, evitando que puedan ser leídos por entidades
 no autorizadas.
\end_layout

\begin_deeper
\begin_layout Standard
En un 
\lang english
SmartHome
\lang spanish
, la disponibilidad de los datos de temperatura o de presencia de personas
 podrían ser usados para atentar contra la propiedad privada.
\end_layout

\end_deeper
\begin_layout Enumerate
Garantizar la integridad
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
integridad
\end_layout

\end_inset

 de los datos comunicados, evitando que puedan ser modificados por entidades
 no autorizadas.
\end_layout

\begin_deeper
\begin_layout Standard
Un posible atacante podría causar severas molestias, e incluso sembrar el
 terror en el hogar, enviando comandos aleatorios a las lámparas o a la
 caldera.
 A pesar de que el atacante no entendería el contenido de los mensajes,
 los habitantes de la casa podrían creerse víctimas de un 
\emph on
poltergeist
\emph default
.
\end_layout

\end_deeper
\begin_layout Enumerate
Evitar el repudio
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
no repudio
\end_layout

\end_inset

 de transacciones ejecutadas de forma efectiva, como puede ser una transferencia
 bancaria.
\end_layout

\begin_deeper
\begin_layout Standard
Como puede ser, también, el pedido de víveres efectuado de forma autónoma
 por un frigorífico inteligente correctamente configurado.
\end_layout

\end_deeper
\begin_layout Subsubsection
Almacenamiento seguro de datos
\end_layout

\begin_layout Standard
Consiste en asegurar la confidencialidad y la integridad de la información
 sensible almacenada en el sistema.
 Esta información solo podrá ser leída por usuarios o dispositivos autorizados
 a ello.
 Del mismo modo, solo los usuarios o dispositivos autorizados podrán modificar
 determinados datos.
 Por ejemplo, en el caso de una tarjeta bancaria, solo el usuario debería
 poder modificar la clave, y solo el banco debería poder modificar el saldo.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Ejemplo IoT!!
\end_layout

\end_inset

 En el caso que nos ocupa, solo el usuario del sistema podrá leer la información
 de los sensores almacenada en la Nube, y solo los sensores podrán actualizar
 dicha información.
\end_layout

\begin_layout Subsubsection
Disponibilidad
\end_layout

\begin_layout Standard
Debe garantizarse que el sistema pueda realizar la función para la que fue
 diseñado y dar servicio a los usuarios legítimos en todo momento, no interrumpi
éndose a causa de ataques de denegación de servicio (DoS).
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
ensures that the system can perform its intended function and service legitimate
 users at all times, without being disrupted by denial-of- service attacks.
 -> el sistema que le da de comer al gato no debe quedarse colgado, y la
 camarita debe funcionar y estar disponible en todo momento (un DoS sería
 desastroso en este caso)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "ravi2004security"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
PERO TAMBIÉN...
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset Note Note
status collapsed

\begin_layout Subsubsection
Resistencia a la manipulación
\emph on
(Tamper resistance)
\end_layout

\begin_layout Plain Layout
Los ataques perpetrados contra los sistemas empotrados pueden explotar vulneravi
lidades a distintos niveles, incluyendo aquellas presentes en el sistema
 operativo y las aplicaciones.
 Estos ataques pueden manipular datos o procesos sensibles (ataques a la
 integridad), revelar información confidencial (ataques a la privacidad)
 o denegar el acceso a los recursos del sistema (ataques a la disponibilidad).
 Por tanto, es necesario desarrollar y desplegar diversas medidas contra
 estos ataques, tanto a nivel software como a nivel hardware.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Comment
status open

\begin_layout Plain Layout
attacks can exploit vul- nerabilities in the operating system (OS) or applicatio
n software.
 attacks manipulate sensitive data or processes (integrity attacks), disclose
 confidential information (privacy attacks), and/or deny access to system
 re- sources (availability attacks), it is necessary to develop and deploy
 various HW/SW countermeasures against these attacks.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fiabilidad del sistema
\end_layout

\begin_layout Standard
Para afirmar que un sistema es realmente fiable, no basta con que este funcione
 de forma correcta la mayor parte del tiempo, sino que debe verificarse
 que su funcionamiento es el esperado en todo momento.
 Si además el sistema ha de ser seguro, este debe funcionar incluso cuando
 es sometido a ataques de seguridad.
 La fiabilidad es un requisito fundamental cuando se trata de 
\emph on
sistemas críticos
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
La implementación y testeo de sistemas altamente fiables son mucho más complejas
 que las de aquellos sistemas que simplemente funcionan correctamente la
 mayor parte del tiempo.
 Los sistemas seguros se enfrentan a un desafío aún mayor: deben operar
 de forma fiable incluso cuando
\end_layout

\begin_layout Plain Layout
It is well known that truly reliable systems are much more difficult to
 build than those that merely work most of the time.
 Secure systems face an even greater challenge: they must continue to operate
 reliably despite attacks.
 As systems become more complicated, there are inevitably more possible
 failure modes.
 PUES NECESITAREMOS VERIFICAR DE ALGÚN MODO!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Soluciones de seguridad
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Usando las técnicas explicadas en el cap 2, se pueden elaborar soluciones
 completas de seguridad
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Existen múltiples técnicas con las que se trata de satisfacer los requisitos
 de seguridad presentados en la sección anterior.
 A continuación se presentan algunos de ellos, prestando especial atención
 a los que tienen más relevancia en la realización de este trabajo.
\end_layout

\begin_layout Subsubsection
Protocolos de seguridad
\end_layout

\begin_layout Standard
Los protocolos de seguridad proporcionan formas de establecer canales de
 comunicación seguros entre dispositivos.
 Esto se consigue cifrando los datos a transmitir, estableciendo mecanismos
 para asegurar la integridad de los mensajes y autenticando cada uno de
 los extremos de la comunicación.
 De esta forma, dos dispositivos pueden comunicarse de forma segura a través
 de una red 
\emph on
a priori 
\emph default
no segura.
\end_layout

\begin_layout Standard
Tal vez los protocolos de seguridad más conocidos sean IPSec y TLS (antes
 SSL), cuyo uso está muy extendido: el primero, en el despliegue de redes
 privadas virtuales (VPN), el segundo, en la realización de transacciones
 web seguras.
 Estos protocolos son prácticamente transparentes para las capas de comunicación
 superiores.
 De este modo, una aplicación que se comunica en red de forma no segura
 puede pasar a establecer una comunicación segura con pocas modificaciones,
 sin necesidad de ser rediseñada desde cero.
 No obstante, los requisitos computacionales que supone el uso de estos
 protocolos pueden comprometer la capacidad computacional del sistema con
 gran facilidad.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
DATOS EN TLS: WolfSSL (memoria) y estudio de esta gente (CPU y tamaño del
 paquete)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:TLS"

\end_inset

 presentamos las características principales del protocolo TLS.
\end_layout

\begin_layout Subsubsection
Certificados digitales
\end_layout

\begin_layout Standard
Los certificados digitales proporcionan formas de asociar una identidad
 digital con una entidad física, basándose en criptografía asimétrica.
 Se trata de un fichero usado para validar la propiedad de una clave pública.
 El certificado incluye información sobre la clave, la identidad de su propietar
io (sujeto del certificado) y sobre la firma digital de la entidad
\end_layout

\begin_layout Standard
Esto se cosigue gracias a un documento electrónico (fichero), el propio
 certificado, el cuál contiene información sobre la identidad del usuario/entida
d certificada y su clave pública.
 Este certificado también contiene una firma, emitida por la entidad certificado
ra.
 Se establece una cadena de confianza.
\end_layout

\begin_layout Standard
Dada la importancia de los certificados digitales en este proyecto, dedicaremos
 el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:X509"

\end_inset

 a estudiarlos más a fondo.
\end_layout

\begin_layout Subsubsection
Almacenamiento y ejecución seguros
\end_layout

\begin_layout Standard
Requieren que la arquitectura del sistema sea diseñada teniendo en cuenta
 la seguridad.
 Ejemplos de soluciones de ejecución segura incluyen 
\end_layout

\begin_layout Standard
el uso de hardware para monitorizar transacciones en un bus, bloqueando
 accesos ilegales a regiones de memoria protegidas.
\end_layout

\begin_layout Standard
autenticación del firmware que se ejecuta en el sistema.
\end_layout

\begin_layout Standard
aislamiento de aplicaciones con el fin de mantener la privacidad y la integridad
 de las instrucciones y de los datos.
\end_layout

\begin_layout Standard
ejecución de código encriptado
\end_layout

\begin_layout Standard
En embebidos: Algunas arquitecturas hardware están diseñadas para la ejecución
 segura [#ref ARM-TrustZone#].
 Existen sistemas operativos de tiempo real diseñados para esta ejecución
 segura #ref!!#.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "ravi2004security"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
QUE QUEDE CLARO LA PARTE INVESTIGADORA AQUI (bibliografia!!)
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:TLS"

\end_inset

El protocolo TLS
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
TLS
\end_layout

\end_inset

En este capítulo, presentamos una introducción al protocolo TLS, en el que
 se revisarán las características principales del mismo.
\end_layout

\begin_layout Standard
Transport Layer Security (TLS) es un protocolo de red cuyo principal objetivo
 es establecer una comunicación segura entre dos nodos de una red que no
 tiene por qué ser segura
\begin_inset Note Note
status open

\begin_layout Plain Layout
 (
\emph on
aunque sí reliable
\emph default
)
\end_layout

\end_inset

.
 Es el sucesor de Secure Sockets Layer, por lo que comparte muchas característic
as con el mismo.
\end_layout

\begin_layout Standard
El protocolo se compone de dos capas, denominadas 
\emph on
TLS Record Protocol
\emph default
 y 
\emph on
TLS Handshake Protocol
\emph default
.
 En el nivel más bajo, justo por encima de algún protocolo de transmisión
 confiable
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Un protocolo de red confiable es aquel que garantiza que los datos serán
 entregados en su destino sin errores y en el mismo orden en que se transmitiero
n.
\end_layout

\end_inset

 (como TCP), se encuentra el 
\emph on
TLS Record Protocol
\emph default
.
 Este protocolo proporciona la seguridad de la conexión, que tiene dos propiedad
es básicas:
\end_layout

\begin_layout Itemize

\series bold
La conexión es privada
\series default
.
 Los datos son encriptados con algoritmos de criptografía simétrica (como
 AES, RC4, etc).
 Las claves usadas en esta encriptación simétrica se generan de forma única
 para cada conexión, a través de una negociación secreta que lleva a cabo
 otro protocolo (como el 
\emph on
TLS Handshake Protocol
\emph default
).
 Aunque no es común, el 
\emph on
TLS Record Protocol
\emph default
 también puede ser usado sin encriptación.
\end_layout

\begin_layout Itemize

\series bold
La conexión es confiable
\series default
.
 El transporte de mensajes incluye una comprobación de la integridad del
 mensaje, que se basa en un código MAC (
\emph on
Message Authentication Code
\emph default
).
 El cálculo del código MAC se lleva a cabo haciendo uso de funciones de
 hash seguras (como SHA).
 Aunque no es común, el 
\emph on
TLS Record Protocol
\emph default
 también puede operar sin el uso de códigos MAC.
\end_layout

\begin_layout Standard
El 
\emph on
TLS Record Protocol
\emph default
 es usado para encapsular otros protocolos de más alto nivel.
 Uno de estos protocolos es el 
\emph on
TLS Handshake Protocol
\emph default
, que permite la autenticación mutua de servidor y cliente y les permite
 negociar los algoritmos de encriptación y las claves antes de que comience
 la transmisión de los datos de aplicación.
 El 
\emph on
TLS Handshake Protocol
\emph default
 proporciona seguridad en la conexión que tiene tres características principales
:
\end_layout

\begin_layout Itemize
Permite autenticar la identidad de los extremos, usando criptografía asimétrica
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Existe una modalidad que permite usar criptografía simétrica en la autenticación
, a través de un sistema de claves compartidas (PSK) 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc4279-TLS+PSK,rfc4285-TLS+PSK-NULL"

\end_inset

.
 Esto puede ser útil en determinadas circunstancias, por ejemplo, si se
 requiere autenticación y los recursos computacionales son muy limitados.
\end_layout

\end_inset

 (como RSA, DSA, etc.).
 Esta autenticación puede ser requerida por la aplicación, o alternativamente,
 hacerse de forma opcional.
\end_layout

\begin_layout Itemize
La negociación de una clave secreta es segura: la clave simétrica negociada
 no puede ser interceptada, ni siquiera por un atacante que se coloque entre
 los nodos y escuche toda la comunicación.
\end_layout

\begin_layout Itemize
La negociación es confiable, de forma que ningún atacante puede modificar
 la negociación sin ser detectado por los nodos.
\end_layout

\begin_layout Standard
TLS se sitúa en la capa de aplicación del modelo OSI.
 Esto quiere decir que son las aplicaciones las que deben incorporar una
 biblioteca 
\begin_inset Note Note
status open

\begin_layout Plain Layout
no hablar de biblioteca: mejor algoritmos o protocolos.
 La biblioteca es la implementación
\end_layout

\end_inset

que les habilite las capacidades de encriptación y de comunicación segura
 que proporciona este protocolo.
 Esto tiene varias implicaciones: Por un lado, los datos viajarán seguros
 desde la aplicación, sin que exista la posibilidad de que estos sean intercepta
dos en una capa de red inferior.
 Por otro lado, el establecimiento de la conexión TLS deberá ser gestionado
 por la misma aplicación, no pudiéndose delegar al sistema operativo.
 Una ventaja de TLS es que es un protocolo independiente de la aplicación.
 Esto quiere decir que sobre él puede situarse cualquier protocolo de nivel
 superior de forma transparente.
\end_layout

\begin_layout Section
Criterios de diseño
\end_layout

\begin_layout Standard
De acuerdo a las especificaciones del protocolo TLS v1.2 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5246-TLSv1.2"

\end_inset

, los objetivos del mismo, en orden de prioridad, son los siguientes:
\end_layout

\begin_layout Enumerate
Seguridad criptográfica: TLS debería usarse para establecer una conexión
 segura entre dos partes
\end_layout

\begin_layout Enumerate
Interoperabilidad: Programadores independientes deberían poder desarrollar
 aplicaciones usando TLS que puedan intercambiar parámetros criptográficos
 sin tener conocimiento del código de la otra parte.
\end_layout

\begin_layout Enumerate
Extensibilidad: TLS busca proveer una infraestructura en la que puedan incorpora
rse nuevos métodos de encriptación según sea necesrario.
 De esta forma, se evita tener que definir nuevos protocolos de seguridad,
 con las consecuencias que esto tiene: la posibilidad de encontrar brechas
 de seguridad en el nuevo protocolo y la necesidad de implementarlo como
 una nueva biblioteca.
\end_layout

\begin_layout Enumerate
Eficiencia
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
 relativa
\end_layout

\end_inset

: Las operaciones criptográficas tienden a ser computacionalmente costosas,
 sobre todo cuando se trata de encripación de clave pública.
 Por este motivo, el protocolo TLS trata de reducir el número de conexiones
 que se establecen desde cero, así como reducir la actividad de red.
\end_layout

\begin_layout Section
El 
\emph on
TLS Record Protocol
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
TLS Record Protocol
\end_layout

\end_inset

Como hemos explicado anteriormente, el 
\emph on
TLS Record Protocol
\emph default
 es la capa más baja del protocolo TLS, y garantiza la comunicación segura
 entre los extremos.
 Los mensajes que van a ser transmitidos son procesados por el 
\emph on
TLS Record Protocol
\emph default
 en los siguientes pasos: los mensajes son fragmentados en bloques de un
 tamaño manejable, luego estos bloques pueden ser comprimidos, al resultado
 se le aplica un código MAC antes de ser encriptado, quedando listo para
 la transmisión.
 En el otro extremo, los datos recibidos son desencriptados, verificados,
 descomprimidos (si procede), reagrupados en los bloques originales y entregados
 a la capa superior.
\end_layout

\begin_layout Standard
Existen cuatro protocolos que hacen uso inmediato del 
\emph on
TLS Record Protocol
\emph default
, que se presentan a continuación.
 Destacaremos que aunque estos son los protocolos definidos en la actualidad,
 el 
\emph on
TLS Record Protocol
\emph default
 puede dar soporte a otros tipos de mensaje (
\emph on
content types
\emph default
).
\end_layout

\begin_layout Paragraph
Handshake Protocol
\end_layout

\begin_layout Standard
Los parámetros criptográficos que se usarán en la sesión son acordados mediante
 el Handshake Protocol.
 Este protocolo implica el intercambio de varios mensajes entre cliente
 y servidor, en los que se establece un secreto compartido, se lleva a cabo
 la autenticación de los nodos y finalmente, si se verifica que no se ha
 producido ningún intento de ataque, se configuran los parámetros del record
 protocol para que pueda comenzar la transmisión de los datos de aplicación.
\end_layout

\begin_layout Standard
Puesto que este protocolo está íntimamente relacionado con 
\begin_inset Note Note
status open

\begin_layout Plain Layout
el establecimiento de
\end_layout

\end_inset

 los parámetros criptográficos que se usarán en la sesión, y dado que el
 uso de estos parámetros requiere que estén disponibles en la implementación
 TLS a usar, dedicaremos una sección completa al Handshake Protocol más
 adelante en este mismo capítulo.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Pequeña descripción
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Se comentará en más detalle más adelante (cross ref)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Alert Protocol
\end_layout

\begin_layout Standard
Los mensajes de alerta comunican la severidad de una alerta (
\emph on
warning
\emph default
 o 
\emph on
fatal
\emph default
) y su descripción.
 Un mensaje de alerta fatal resulta en la conclusión inmediata de la conexión.
 Como con el resto de protocolos, los mensajes de alerta son encriptados
 y comprimidos sigiuiendo las especificaciones del estado actual de la conexión.
\end_layout

\begin_layout Paragraph
Change Cipher Spec Protocol
\end_layout

\begin_layout Standard
El 
\lang english
Change Cipher Spec Protocol
\lang spanish
 es usado para notificar un cambio en las estrategias de cifrado.
 El protocolo consiste en un mensaje único, que se comprime y encripta haciendo
 uso de los parámetros de cifrado actuales.
\end_layout

\begin_layout Standard
El mensaje 
\emph on
ChangeCipherSpec
\emph default
 es enviado tanto por el cliente como por el servidor para notificar que
 los mensajes enviados a continuación estarán protegidos atendiendo a las
 nuevas especificaciones de cifrado (
\emph on
CipherSpec
\emph default
) y claves establecidas.
\end_layout

\begin_layout Standard
Para ser más específicos, si un handshake tiene lugar durante una transmisión
 de datos, las partes pueden continuar comunicándose usando los parámetros
 establecidos en la anterior negociación.
 Es el mensaje ChangeCipherSpec el que señala el momento en el que las nuevas
 especificaciones serán usadas, por lo que cualquier mensaje recibido después
 de este deberá atender a los nuevos parámetros y claves de cifrado.
\end_layout

\begin_layout Paragraph
Application Protocol
\end_layout

\begin_layout Standard
Los datos de aplicación son transportados directamnete por la 
\emph on
Record Layer
\emph default
, donde son fragmentados, comprimidos y encriptados atendiendo al estado
 de la conexión y a sus parámetros.
 De esta manera, los mensajes provenientes de la capa de aplicación son
 tratados de forma transparente por la 
\emph on
Record Layer
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status collapsed

\begin_layout Plain Layout
6.2.
 Record Layer
\end_layout

\begin_layout Plain Layout
The TLS record layer receives uninterpreted data from higher layers in non-empty
 blocks of arbitrary size.
\end_layout

\begin_layout Plain Layout
6.2.1.
 Fragmentation
\end_layout

\begin_layout Plain Layout
The record layer fragments information blocks into TLSPlaintext records
 carrying data in chunks of 2^14 bytes or less.
 Client message boundaries are not preserved in the record layer (i.e., multiple
 client messages of the same ContentType MAY be coalesced into a single
 TLSPlaintext record, or a single message MAY be fragmented across several
 records).
\end_layout

\begin_layout Plain Layout
6.2.3.
 Record Payload Protection
\end_layout

\begin_layout Plain Layout
The encryption and MAC functions translate a TLSCompressed structure into
 a TLSCiphertext.
 The decryption functions reverse the process.
 The MAC of the record also includes a sequence number so that missing,
 extra, or repeated messages are detectable.
\end_layout

\end_inset


\end_layout

\begin_layout Section
El 
\emph on
TLS Handshak Protocol
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
TLS Handshake Protocol
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
TLS cuenta con tres subprotocolos que permiten a los nodos negociar los
 parámetros de seguridad que serán usados en la Record Layer.
 Estos protocolos, además, permiten que los nodos puedan autenticarse, 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como se ha visto anteriormente, TLS tiene tres subprotocolos con los que
 los extremos de la conexión pueden acordar los parámetros de seguridad
 para la record layer, autenticarse e informarse sobre errores producidos
 en la conexión.
\end_layout

\begin_layout Standard
El Handshake Protocol es responsable de negociar la sesión, cuyos principales
 elementos son:
\end_layout

\begin_layout Description
session
\begin_inset space ~
\end_inset

identifier Una secuencia de bytes arbitrarios elegidos por el servidor para
 identificar la sesión activa.
\end_layout

\begin_layout Description
peer
\begin_inset space ~
\end_inset

certificate Certificado del cliente o del servidor, definido por el estándar
 X509v3.
 Este elemento puede no estar presente.
\end_layout

\begin_layout Description
compression
\begin_inset space ~
\end_inset

method El algoritmo utilizado para comprimir datos antes de la encriptación.
\end_layout

\begin_layout Description
cipher
\begin_inset space ~
\end_inset

spec Especifica la función pseudo-aleatoria (pseudorandom function PRF)
 que se usará para usar las claves, el algoritmo de encriptación simétrica
 (como AES, etc.) y el algoritmo de MAC (como HMAC-SHA1).
 También define los atributos criptográficos como la longitud de MAC, entre
 otros.
\end_layout

\begin_layout Description
master
\begin_inset space ~
\end_inset

secret Clave de 48 bytes compartido entre el cliente y el servidor.
\end_layout

\begin_layout Standard
Estos elementos son usados para crear los parámetros de seguridad que la
 Record Layer usará para proteger los datos de aplicación.
 Distintas conexiones pueden ser instanciadas usando la misma sesión, gracias
 a la característica de reanudación del protocolo TLS Handshake Protocol.
\end_layout

\begin_layout Paragraph
Descripción funcinal del Handshake Protocol
\end_layout

\begin_layout Standard
Los parámetros criptográficos del estado de la sesión son establecidos por
 el TLS Handshake Protocol, el cuál opera sobre la capa TLS record layer.
 Cuando un cliente y un servidor TLS comienzan a comunicarse por primera
 vez, negocian una versión del protocolo, eligen los algoritmos criptográficos,
 se autentican mutuamente (de forma opcional), y usan técnicas de criptografía
 asimétrica para generar claves compartidas.
\end_layout

\begin_layout Standard
El TLS Handshake Protocol implica los siguientes pasos:
\end_layout

\begin_layout Itemize
Intercambio de mensajes 
\emph on
hello
\emph default
 para negociar los algoritmos, intercambiar valores aleatorios y comprobar
 si debe reanudarse una sesión anterior.
\end_layout

\begin_layout Itemize
Intercambio de los parámetros criptográficos necesarios para permitir que
 cliente y servidor puedan compartir una clave 
\emph on
pre-maestra
\emph default
 (
\lang english
pre-master secret
\lang spanish
).
\end_layout

\begin_layout Itemize
Intercambio de los certificados e información criptográfica para permitir
 que cliente y servidor puedan autenticarse mutuamente.
\end_layout

\begin_layout Itemize
Generación de una clave maestra (
\lang english
master secret
\lang spanish
) a partir de la clave pre-maestra e intercambiar valores aleatorios.
\end_layout

\begin_layout Itemize
Proporcionar parámetros de seguridad para la record layer.
\end_layout

\begin_layout Itemize
Permitir que cliente y servidor verifiquen que el otro extremo ha calculado
 los mismos parámetros de seguridad y que por tanto el handshake se ha llevado
 a cabo sin la manipulación de un atacante.
\end_layout

\begin_layout Standard
La 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
figura_#
\end_layout

\end_inset

 muestra los pasos llevados a cabo en el establecimiento de la conexión
 TLS, de la que se encarga el Handshake Protocol.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
the handshake protocol, which can be summarized as follows: The client sends
 a ClientHello message to which the server must respond with a ServerHello
 message, or else a fatal error will occur and the connection will fail.
 The ClientHello and ServerHello are used to establish security enhancement
 capabilities between client and server.
 The ClientHello and ServerHello establish the following attributes: Protocol
 Version, Session ID, Cipher Suite, and Compression Method.
 Additionally, two random values are generated and exchanged: ClientHello.random
 and ServerHello.random.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Resumen
\end_layout

\begin_layout Standard
TLS
\begin_inset Index idx
status open

\begin_layout Plain Layout
TLS
\end_layout

\end_inset

 permite conexiones seguras a nivel de la capa de aplicación.
 El establecimiento de la conexión se lleva a cabo de forma segura, usando
 criptografía asimétrica para el intercambio de las claves compartidas,
 que serán usadas en el cifrado de los mensajes de aplicación.
 Durante el establecimiento de la conexión, conocido como handshake, los
 nodos pueden autenticarse mutuamente usando certificados digitales X.509.
\end_layout

\begin_layout Standard
El siguiente esquema resume las funcionalidades básicas de los distintos
 subprotocolos de TLS.
\end_layout

\begin_layout Enumerate
Handshake
\end_layout

\begin_deeper
\begin_layout Standard
Se encarga del establecimiento de la conexión entre dos nodos (cliente y
 servidor).
 El handshake conlleva:
\end_layout

\begin_layout Enumerate
Definición de los parámetros de seguridad a usar en la sesión (algoritmos
 de cifrado, clave, compresión, etc.), que son negociados entre cliente y
 servidor, de acuerdo con las funciones criptográficas implementadas en
 cada uno.
\end_layout

\begin_layout Enumerate
Autenticación mutua de los nodos cliente y servidor (opcional, puede llevarse
 a cabo en una única dirección).
\end_layout

\begin_layout Standard
El establecimiento de la conexión implica un esquema de criptografía asimétrica,
 usando claves relativamente largas generadas exclusivamente para la conexión
 a partir de una fuente de entropía.
 Este esquema es computacionalmente muy costoso, pero también muy seguro.
\end_layout

\begin_layout Enumerate
Gracias al esquema de criptografía asimétrica, el contenido del propio handshake
 queda oculto para un observador externo, haciendo imposible deducir los
 parámetros de la sesión.
\end_layout

\begin_layout Enumerate
El handshake cuenta con mecanismos de detección de 
\begin_inset Quotes fld
\end_inset

tampering
\begin_inset Quotes frd
\end_inset

, por lo que un ataque sería detectado.
\end_layout

\end_deeper
\begin_layout Enumerate
Intercambio de datos de aplicación
\end_layout

\begin_deeper
\begin_layout Standard
Los datos de la capa superior son transmitidos de forma transparente, usando
 los parámetros de seguridad establecidos.
\end_layout

\begin_layout Enumerate
Estos datos son cifrados usando criptografía simétrica, haciendo uso de
 la clave acordada durante el handshake.
\end_layout

\begin_layout Enumerate
Los datos de aplicación son comprimidos (de forma opcional) y fragmentados
 para optimizar el uso de la red.
\end_layout

\end_deeper
\begin_layout Enumerate
Cambios de especificación y alertas
\end_layout

\begin_deeper
\begin_layout Standard
Los nodos pueden cambiar los parámetros de seguridad en cualquier momento.
 Además, pueden intercambiar avisos o incluso cerrar la sesión si se detecta
 un problema serio de seguridad.
\end_layout

\end_deeper
\begin_layout Enumerate
Terminación de la sesisión
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Eventualmente, cualquiera de los extremos puede terminar la sesión.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
QUE QUEDE CLARO LA PARTE INVESTIGADORA AQUI (bibliografia!!)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este protocolo (TLS) ha inspirado a otros, como DTLS 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

, que no requiere una comunicacion reliable, sino que puede operar sobre
 protocolos como UDP.
 (INTRODUCIR DTLS SI NO SE HA HECHO ANTES).
\end_layout

\begin_layout Standard
En los siguientes capítulos hablaremos de distintas implementaciones de
 TLS.
 Cabe destacar aquí que una buena implementación del estándar debe cumplir
 con todos los requisitos definidos en el mismo.
 Sin embargo, no tiene por qué abarcar el amplio abanico de parámetros de
 seguridad disponibles.
 Por este motivo, hablaremos de ciphersuites
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ciphersuite
\end_layout

\end_inset

 para referirnos al conjunto de parámetros de seguridad (funciones de encriptaci
ón/desencriptación, algoritmos de encriptación, funciones de hash...) disponibles
 en una implementación determinada.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Record layer VS Handshake
\end_layout

\begin_layout Plain Layout
Ciphersuites
\end_layout

\begin_layout Plain Layout
Criptografía asimétrica
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:X509"

\end_inset

Certificados digitales X.509
\begin_inset Index idx
status open

\begin_layout Plain Layout
certificado digital
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Public-key cryptography makes it possible for people who do not share a
 common key in advance to nevertheless communicate securely.
 It also makes signing messages possible without the presence of a trusted
 third party.
 Finally, signed message digests make it possible for the recipient to verify
 the integrity of received messages easily and securely.
 However, there is one problem that we have glossed over a bit too quickly:
 if Alice and Bob do not know each other, how do they get each other’s public
 keys to start the communication process? The obvious solution—put your
 public key on your Web site—does not work, for the following reason.
 Suppose that Alice wants to look up Bob’s public key on his Web site.
 How does she do it? She starts by typing in Bob’s URL.
 Her browser then looks up the DNS address of Bob’s home page and sends
 it a GET request, as shown in Fig.
 8-23.
 Unfortunate- ly, Trudy intercepts the request and replies with a fake home
 page, probably a copy of Bob’s home page except for the replacement of
 Bob’s public key with Trudy’s public key.
 When Alice now encrypts her first message with E T , Trudy decrypts it,
 reads it, re-encrypts it with Bob’s public key, and sends it to Bob, who
 is none the wiser that Trudy is reading his incoming messages.
 Worse yet, Trudy could modify the messages before reencrypting them for
 Bob.
 Clearly, some mechanism is needed to make sure that public keys can be
 exchanged securely.
\end_layout

\begin_layout Plain Layout
As a first attempt at distributing public keys securely, we could imagine
 a KDC key distribution center available online 24 hours a day to provide
 public keys on demand.
 One of the many problems with this solution is that it is not scalable,
 and the key distribution center would rapidly become a bottleneck.
 Also, if it ever went down, Internet security would suddenly grind to a
 halt.
 For these reasons, people have developed a different solution, one that
 does not require the key distribution center to be online all the time.
 In fact, it does not have to be online at all.
 Instead, what it does is certify the public keys belonging to people, companies
, and other organizations.
 An organization that certifies pub- lic keys is now called a CA (Certification
 Authority).
 As an example, suppose that Bob wants to allow Alice and other people he
 does not know to communicate with him securely.
 He can go to the CA with his public key along with his passport or driver’s
 license and ask to be certified.
 The CA then issues a certificate similar to the one in Fig.
 8-24 and signs its SHA-1
\end_layout

\begin_layout Plain Layout
hash with the CA’s private key.
 Bob then pays the CA’s fee and gets a CD-ROM containing the certificate
 and its signed hash.
\end_layout

\begin_layout Plain Layout
The fundamental job of a certificate is to bind a public key to the name
 of a principal (individual, company, etc.).
 Certificates themselves are not secret or protected.
 Bob might, for example, decide to put his new certificate on his Web site,
 with a link on the main page saying: Click here for my public-key certificate.
 The resulting click would return both the certificate and the signature
 block (the signed SHA-1 hash of the certificate).
 Now let us run through the scenario of Fig.
 8-23 again.
 When Trudy inter- cepts Alice’s request for Bob’s home page, what can she
 do? She can put her own certificate and signature block on the fake page,
 but when Alice reads the contents of the certificate she will immediately
 see that she is not talking to Bob because Bob’s name is not in it.
 Trudy can modify Bob’s home page on the fly, replacing Bob’s public key
 with her own.
 However, when Alice runs the SHA-1 algorithm on the certificate, she will
 get a hash that does not agree with the one she gets when she applies the
 CA’s well-known public key to the signature block.
 Since Trudy does not have the CA’s private key, she has no way of generating
 a signa- ture block that contains the hash of the modified Web page with
 her public key on it.
 In this way, Alice can be sure she has Bob’s public key and not Trudy’s
 or someone else’s.
 And as we promised, this scheme does not require the CA to be online for
 verification, thus eliminating a potential bottleneck.
 While the standard function of a certificate is to bind a public key to
 a princi- pal, a certificate can also be used to bind a public key to an
 attribute.
 For ex- ample, a certificate could say: ‘‘This public key belongs to someone
 over 18.’’ It could be used to prove that the owner of the private key was
 not a minor and thus allowed to access material not suitable for children,
 and so on, but without dis- closing the owner’s identity.
 Typically, the person holding the certificate would send it to the Web
 site, principal, or process that cared about age.
 That site, prin- cipal, or process would then generate a random number
 and encrypt it with the public key in the certificate.
 If the owner were able to decrypt it and send it back,
\end_layout

\begin_layout Plain Layout
that would be proof that the owner indeed had the attribute stated in the
 certifi- cate.
 Alternatively, the random number could be used to generate a session key
 for the ensuing conversation.
 Another example of where a certificate might contain an attribute is in
 an ob- ject-oriented distributed system.
 Each object normally has multiple methods.
 The owner of the object could provide each customer with a certificate
 giving a bit map of which methods the customer is allowed to invoke and
 binding the bit map to a public key using a signed certificate.
 Again, if the certificate holder can prove possession of the corresponding
 private key, he will be allowed to perform the methods in the bit map.
 This approach has the property that the owner’s iden- tity need not be
 known, a property useful in situations where privacy is important.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
If everybody who wanted something signed went to the CA with a different
 kind of certificate, managing all the different formats would soon become
 a prob- lem.
 To solve this problem, a standard for certificates has been devised and
 approved by ITU.
 The standard is called X.509 and is in widespread use on the Internet.
 It has gone through three versions since the initial standardization in
 1988.
 We will discuss V3.
 X.509 has been heavily influenced by the OSI world, borrowing some of its
 worst features (e.g., naming and encoding).
 Surprisingly, IETF went along with X.509, even though in nearly every other
 area, from machine addresses to tran- sport protocols to email formats,
 IETF generally ignored OSI and tried to do it right.
 The IETF version of X.509 is described in RFC 5280.
 At its core, X.509 is a way to describe certificates.
 The primary fields in a certificate are listed in Fig.
 8-25.
 The descriptions given there should provide a general idea of what the
 fields do.
 For additional information, please consult the standard itself or RFC 2459.
 For example, if Bob works in the loan department of the Money Bank, his
 X.500 address might be
\end_layout

\begin_layout Plain Layout
/C=US/O=MoneyBank/OU=Loan/CN=Bob/ 
\end_layout

\begin_layout Plain Layout
where C is for country, O is for organization, OU is for organizational
 unit, and CN is for common name.
 CAs and other entities are named in a similar way.
 A substantial problem with X.500 names is that if Alice is trying to contact
 bob@moneybank.com and is given a certificate with an X.500 name, it may not
 be obvious to her that the certificate refers to the Bob she wants.
 Fortunately, start- ing with version 3, DNS names are now permitted instead
 of X.500 names, so this problem may eventually vanish.
 Certificates are encoded using OSI ASN.1 (Abstract Syntax Notation 1), which
 is sort of like a struct in C, except with a extremely peculiar and verbose
 notation.
 More information about X.509 is given by Ford and Baum (2000).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Copiar de Tanenbaum
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Certificados muy estándar (X.509 v3).
 Son intercambiado durante el handshake de TLS, para verificar la identidad.
 Es interesante conocer el contenido de estos certificados, y cómo funciona
 la verificación de la identidad.
\end_layout

\begin_layout Standard
ITU-T Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
X.509
\end_layout

\end_inset

!
\end_layout

\begin_layout Section
Contenido de los certificados
\end_layout

\begin_layout Standard
Los campos
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/cert-digital.gif
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Campos de los certificados X.509 
\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Cadena de confianza
\begin_inset Index idx
status open

\begin_layout Plain Layout
cadena de confianza
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
trust chain
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Having a single CA to issue all the world’s certificates obviously would
 not work.
 It would collapse under the load and be a central point of failure as well.
 A possible solution might be to have multiple CAs, all run by the same
 organization and all using the same private key to sign certificates.
 While this would solve the load and failure problems, it introduces a new
 problem: key leakage.
 If there were dozens of servers spread around the world, all holding the
 CA’s private key, the chance of the private key being stolen or otherwise
 leaking out would be greatly increased.
 Since the compromise of this key would ruin the world’s elec- tronic security
 infrastructure, having a single central CA is very risky.
 In addition, which organization would operate the CA? It is hard to imagine
 any authority that would be accepted worldwide as legitimate and trustworthy.
 In some countries, people would insist that it be a government, while in
 other coun- tries they would insist that it not be a government.
 For these reasons, a different way for certifying public keys has evolved.
 It goes under the general name of PKI (Public Key Infrastructure).
 In this sec- tion, we will summarize how it works in general, although
 there have been many proposals, so the details will probably evolve in
 time.
 A PKI has multiple components, including users, CAs, certificates, and
 direc- tories.
 What the PKI does is provide a way of structuring these components and
 define standards for the various documents and protocols.
 A particularly simple form of PKI is a hierarchy of CAs, as depicted in
 Fig.
 8-26.
 In this example we have shown three levels, but in practice there might
 be fewer or more.
 The top- level CA, the root, certifies second-level CAs, which we here
 call RAs (Regional Authorities) because they might cover some geographic
 region, such as a country or continent.
 This term is not standard, though; in fact, no term is really standard
 for the different levels of the tree.
 These in turn certify the real CAs, which issue the X.509 certificates to
 organizations and individuals.
 When the root authorizes a new RA, it generates an X.509 certificate stating
 that it has approved the RA, in- cludes the new RA’s public key in it,
 signs it, and hands it to the RA.
 Similarly, when an RA approves a new CA, it produces and signs a certificate
 stating its approval and containing the CA’s public key.
\end_layout

\begin_layout Plain Layout
Our PKI works like this.
 Suppose that Alice needs Bob’s public key in order to communicate with
 him, so she looks for and finds a certificate containing it, signed by
 CA 5.
 But Alice has never heard of CA 5.
 For all she knows, CA 5 might be Bob’s 10-year-old daughter.
 She could go to CA 5 and say: ‘‘Prove your legitimacy.’’ CA 5 will respond
 with the certificate it got from RA 2, which con- tains CA 5’s public key.
 Now armed with CA 5’s public key, she can verify that Bob’s certificate
 was indeed signed by CA 5 and is thus legal.
 Unless RA 2 is Bob’s 12-year-old son.
 So, the next step is for her to ask RA 2 to prove it is legitimate.
 The response to her query is a certificate signed by the root and containing
 RA 2’s public key.
 Now Alice is sure she has Bob’s public key.
 But how does Alice find the root’s public key? Magic.
 It is assumed that everyone knows the root’s public key.
 For example, her browser might have been shipped with the root’s public
 key built in.
 Bob is a friendly sort of guy and does not want to cause Alice a lot of
 work.
 He knows that she is going to have to check out CA 5 and RA 2, so to save
 her some trouble, he collects the two needed certificates and gives her
 the two certifi- cates along with his.
 Now she can use her own knowledge of the root’s public key to verify the
 top-level certificate and the public key contained therein to ver- ify
 the second one.
 Alice does not need to contact anyone to do the verification.
\end_layout

\begin_layout Plain Layout
Because the certificates are all signed, she can easily detect any attempts
 to tam- per with their contents.
 A chain of certificates going back to the root like this is sometimes called
 a chain of trust or a certification path.
 The technique is wide- ly used in practice.
 Of course, we still have the problem of who is going to run the root.
 The solution is not to have a single root, but to have many roots, each
 with its own RAs and CAs.
 In fact, modern browsers come preloaded with the public keys for over 100
 roots, sometimes referred to as trust anchors.
 In this way, having a sin- gle worldwide trusted authority can be avoided.
 But there is now the issue of how the browser vendor decides which purported
 trust anchors are reliable and which are sleazy.
 It all comes down to the user trusting the browser vendor to make wise
 choices and not simply approve all trust anchors willing to pay its inclusion
 fee.
 Most browsers allow users to inspect the root keys (usually in the form
 of certificates signed by the root) and delete any that seem shady.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/chain-of-trust.png
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cadena de confianza en certificados X.509 
\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
PKI
\end_layout

\begin_layout Standard
TrustChain
\end_layout

\begin_layout Section
Estructura y tipos de fichero
\end_layout

\begin_layout Standard
Los campos de los certificados X.509 se transmiten como ficheros, que pueden
 presentar distintos formatos.
 A pesar de esto, todos estos ficheros parten de X.690, un estándar de ITU-T
 que especifica diversos formatos ASN.1 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://en.wikipedia.org/wiki/X.690#BER_encoding
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://stackoverflow.com/questions/22743415/what-are-the-differences-between-pem
-cer-and-der
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
DER (Distinguished Encoding Rules) is the method of encoding the data that
 makes up the certificate.
 DER itself could represent any kind of data, but usually it describes an
 encoded certificate or a CMS container.
 The structure of a certificate is described using the ASN.1 data representation
 language.
 BER and DER are binary encoding methods for data described by ASN.1.
\end_layout

\begin_layout Plain Layout
PEM is a method of encoding binary data as a string (ASCII armor).
 It contains a header and a footer line (specifying the type of data that
 is encoded and showing begin/end if the data is chained together) and the
 data in the middle is the base 64 data.
 In the case that it encodes a certificate it would simply contain the base
 64 encoding of the DER certificate.
 PEM stands for Privacy Enhanced Mail; mail cannot contain unencoded binary
 values such as DER directly.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:AWS-IoT"

\end_inset

Amazon Web Services IoT
\end_layout

\begin_layout Standard
En esta sección describimos la arquitectura de la plataforma de Amazon para
 Internet de las Cosas (AWS
\begin_inset space ~
\end_inset

IoT
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
AWS IoT
\end_layout

\end_inset


\end_layout

\end_inset

), explorando su potencial y las particularidades que presenta.
\end_layout

\begin_layout Standard
Como se describe en la documentación oficial, AWS
\begin_inset space ~
\end_inset

IoT proporciona una
\emph on
 comunicación bidireccional segura
\emph default
 entre dispositivos conectados a Internet (ya sean sensores, actuadores,
 microcontroladores, electrodomésticos inteligentes, etc.) y la nube de Amazon
 (
\emph on
AWS
\begin_inset space ~
\end_inset

Cloud
\emph default
) 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-What-is-AWS-IoT"

\end_inset

.
 Esto nos permite recoger, almacenar y analizar datos de una gran variedad
 de dispositivos.
 Del mismo modo, nos permite crear aplicaciones para controlar estos dispositivo
s a través de un
\emph on
 smartphone
\emph default
 o
\emph on
 tablet
\emph default
.
\end_layout

\begin_layout Standard
En este sentido, AWS
\begin_inset space ~
\end_inset

IoT actúa como una pasarela a la cuál pueden conectarse tanto dispositivos
 como aplicaciones de terceros.
 Además, ofrece una interfaz sencilla para procesar los datos recogidos
 a través de los demás servicios de AWS.
 Este modo de operación hace que Amazon haya concentrado sus esfuerzos en
 una plataforma robusta y segura, dando soporte a empresas que desean construir
 aplicaciones complejas y escalables.
\begin_inset Note Note
status open

\begin_layout Plain Layout
 Por este motivo, AWS
\begin_inset space ~
\end_inset

IoT cuenta con un panel de control relativamente complejo, que nos permitirá
 gestionar una multitud de opciones.
 No obstante, esta plataforma no proporciona por sí misma herramientas para
 representar los datos obtenidos.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Componentes de AWS IoT
\end_layout

\begin_layout Standard
La plataforma AWS
\begin_inset space ~
\end_inset

IoT está formada por diversos módulos que trabajan orquestados para proporcionar
 la funcionalidad completa ofrecida por este servicio
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
proporcionar todas sus funcionalidades
\end_layout

\end_inset

.
 Con el fin de hacer un uso eficaz de la plataforma, conviene tener una
 imagen global de su arquitectura.
 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Solo de este modo entenderemos el significado de las configuraciones llevadas
 a cabo en la siguiente sección
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../../../Internet-de-las-Cosas/doc/img/AWS_IoT23._CB520207442_.png
	lyxscale 60
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Componentes-AWS"

\end_inset

Principales componentes de AWS
\begin_inset space ~
\end_inset

IoT 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-Alexa-Blog"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Componentes-AWS"

\end_inset

 muestra los componentes principales de AWS
\begin_inset space ~
\end_inset

IoT.
 Los elementos que quedan dentro del recuadro amarillo constituyen la plataforma
 propiamente dicha.
 Fuera del recuadro quedan los
\emph on
 dispositivos
\emph default
, las
\emph on
 aplicaciones
\emph default
 y los
\emph on
 servicios
\emph default
, tanto los de AWS como los de terceras partes.
 A continuación describimos los principales componentes de AWS
\begin_inset space ~
\end_inset

IoT 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-What-is-AWS-IoT"

\end_inset

.
\end_layout

\begin_layout Description
Pasarela
\begin_inset space ~
\end_inset

para
\begin_inset space ~
\end_inset

dispositivos
\begin_inset space ~
\end_inset

(
\lang english
Device
\begin_inset space ~
\end_inset

gateway
\lang spanish
) se encarga de establecer la comunicación entre la nube de Amazon y cada
 dispositivo.
 El 
\lang english
Device
\begin_inset space ~
\end_inset

gateway
\lang spanish
 es el responsable de que esta comunicación se lleve a cabo de forma eficiente
 y segura.
\end_layout

\begin_deeper
\begin_layout Description
Agente
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

mensajes
\begin_inset space ~
\end_inset

(
\lang english
Message
\begin_inset space ~
\end_inset

broker
\lang spanish
) proporciona un mecanismo seguro para que los dispositivos y las aplicaciones
 de AWS
\begin_inset space ~
\end_inset

IoT publiquen y reciban mensajes entre sí, basándose en el protocolo MQTT
 o en MQTT sobre WebSocket.
\end_layout

\end_deeper
\begin_layout Description
Motor
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

reglas
\begin_inset space ~
\end_inset

(
\lang english
Rules
\begin_inset space ~
\end_inset

engine
\lang spanish
) proporciona funciones de procesamiento de mensajes y de integración con
 otros sevicios de la nube de Amazon.
 También permite usar el 
\lang english
Message
\begin_inset space ~
\end_inset

broker
\lang spanish
 para volver a publicar mensajes para otros suscriptores.
\end_layout

\begin_layout Description
Registro
\begin_inset space ~
\end_inset

(
\lang english
Registry
\lang spanish
) organiza los recursos asociados a cada dispositivo en la nube de Amazon
 (AWS
\begin_inset space ~
\end_inset

Cloud).
 Es necesario registrar los dispositivos y asociar hasta tres atributos
 personalizados a cada uno.
 Este componente también es responsable de asociar los certificados digitales
 y los IDs de clientes MQTT a cada dispositivo.
\end_layout

\begin_deeper
\begin_layout Description
Registro
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

grupos
\begin_inset space ~
\end_inset

(
\lang english
Group
\begin_inset space ~
\end_inset

registry
\lang spanish
) permite administrar varios dispositivos a la vez clasificándolos en grupos.
\end_layout

\end_deeper
\begin_layout Description
Sombra
\begin_inset space ~
\end_inset

del
\begin_inset space ~
\end_inset

dispositivo
\begin_inset space ~
\end_inset

(
\lang english
Device
\begin_inset space ~
\end_inset

shadow
\lang spanish
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
sombra del dispositivo
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
device shadow
\end_layout

\end_inset

 documento JSON utilizado para
\begin_inset Note Note
status open

\begin_layout Plain Layout
almacenar y recuperar información
\end_layout

\end_inset

 representar el estado de un dispositivo.
 También es usado para solicitar una acción al dispositivo.
\end_layout

\begin_layout Standard
AWS
\begin_inset space ~
\end_inset

IoT dispone de otros componentes y servicios con los que el desarrollador
 puede interactuar para realizar algunas tareas de interés, como actualizar
 el firmware de sus dispositivos de forma remota, por ejemplo.
 No obstante, su uso es más avanzado y queda fuera de los objetivos de este
 documento.
\end_layout

\begin_layout Standard
Cabe mencionar que tanto el agente de mensajes como el motor de reglas utilizan
 las características de seguridad de AWS.
 De este modo, solo los dispositivos y aplicaciones convenientemente autorizados
 pueden establecer una comunicación con AWS
\begin_inset space ~
\end_inset

IoT.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Esquema-de-funcionamiento"

\end_inset

Descripción funcional
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
un poco de blabla: ahora que conocemos los elementos básicos de la plataforma,
 vamos a ver cómo funcionan y cómo se relacionan con el exterior (nuestro
 dispositivo).
\end_layout

\end_inset

En esta sección describiremos el esquema general de funcionamiento de AWS
\begin_inset space ~
\end_inset

IoT.
 Será aquí donde desarrollaremos la relación entre los distintos elementos
 definidos anteriormente, así como su interacción con el mundo exterior.
\end_layout

\begin_layout Standard
Por un lado, tendremos dispositivos físicos ejecutando el
\emph on
 kit de desarrollo de software del dispositivo
\emph default
 (
\lang english
AWS
\begin_inset space ~
\end_inset

IoT
\begin_inset space ~
\end_inset

Device
\begin_inset space ~
\end_inset

SDK
\lang spanish
).
 Cada uno de estos dispositivos debe disponer de unas credenciales con las
 que se identificará y se autenticará ante la Nube.
 En general, estas credenciales vienen dadas por un certificado digital
 único para cada dispositivo.
 De forma adicional, el dispositivo debe incluir el certificado raíz de
 autoridad certificadora (
\lang english
CA root certificate
\lang spanish
), de modo que pueda autenticar a los servidores de Amazon.
\end_layout

\begin_layout Standard
Por otro lado, tendremos que definir estos dispositivos en la plataforma,
 usando el Servicio de registro (
\lang english
Registry
\lang spanish
) anteriormente descrito.
 Cada uno de estos dispositivos virtuales dispondrá de un
\emph on
 nombre único
\emph default
, que servirá para identificarlo, y de unos
\emph on
 atributos estáticos
\emph default
 a modo de descripción.
 Estos atributos estáticos pueden ser compartidos por dispositivos del mismo
 
\emph on
tipo
\emph default
, por lo que AWS
\begin_inset space ~
\end_inset

IoT proporciona esta unidad de organización a tal efecto.
 De forma adicional, el dispositivo puede tener uno o varios certificados
 asociados.
 En general, cada dispositivo virtual tendrá asociado el mismo certificado
 digital que instalemos en el dispositivo físico correspondiente, de forma
 que AWS
\begin_inset space ~
\end_inset

IoT pueda autenticarlo.
 Los certificados digitales definidos en la consola pueden tener asociadas
 una o varias Políticas de uso (
\lang english
Policies
\lang spanish
).
 Gracias a estas políticas de uso, distintos dispositivos tendrán permisos
 para realizar diferentes acciones, como puede ser publicar o suscribirse
 en determinados 
\lang english
topics
\lang spanish
, actualizar su sombra, etc.
\end_layout

\begin_layout Standard
Cabe destacar que los Atributos estáticos sirven para describir al dispositivo
 en sí, por lo que su función no debe confundirse con aquélla de la Sombra
 del dispositivo.
 Mientras que estos atributos se almacenan de forma estática en el Registro,
 la sombra es un documento dinámico que contiene los valores de los sensores
 y el estado de los actuadores.
 Ejemplos de atributos estáticos son el número de serie, la versión de firmware,
 una breve descripción del dispositivo, etc.
 El siguiente epígrafe está dedicado a la sombra del dispositivo.
\end_layout

\begin_layout Subsection
Sombra del dispositivo
\begin_inset Index idx
status open

\begin_layout Plain Layout
sombra del dispositivo
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
device shadow
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "shadow.json"

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Ejemplo-de-sombra"

\end_inset

Ejemplo de sombra de dispositivo 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-Shadow-MQTT-Topics"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
El estado del dispositivo se guarda en un fichero JSON especial denominado
 sombra del dispositivo (
\lang english
device shadow
\lang spanish
).
 La sombra del dispositivo actúa como un intermediario entre dispositivos
 y aplicaciones, permitiendo que ambas partes tengan acceso al estado del
 dispositivo, pudiendo actualizarlo en ambos sentidos.
 Para que el estado del dispositivo pueda ser modificado por las aplicaciones,
 cada parámetro definido en la sombra podrá estar bajo una de las categorías
 
\lang english
reported
\lang spanish
 y 
\lang english
desired
\lang spanish
, como puede verse en el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "alg:Ejemplo-de-sombra"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-Shadow-Syntax"

\end_inset

.
\end_layout

\begin_layout Standard
Bajo la categoría 
\lang english
reported
\lang spanish
 tendremos un informe del estado confeccionado por el dispositivo.
 De este modo, podemos decir que los parámetros encontrados en esta categoría
 tienen un significado informativo del estado del dispositivo, y solo el
 dispositivo debería escribir en ellos.
 Es en esta sección donde encontraremos los valores de los sensores y el
 estado de los actuadores reportado por el dispositivo.
\end_layout

\begin_layout Standard
En la categoría 
\lang english
desired
\lang spanish
, en cambio, tendremos instrucciones para el dispositivo, como el cambio
 de color de un LED o el accionamiento de un motor.
 Como puede intuirse, esta categoría es confeccionada por la aplicación,
 debiendo ser revisada por el dispositivo para ejecutar las acciones solicitadas.
 Una vez completada la acción, el dispositivo actualizará el estado del
 actuador en el apartado 
\lang english
reported
\lang spanish
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../../../Internet-de-las-Cosas/doc/img/AWS_IoT_Shadow_Flow.png
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Flujo-de-mensajes-sombra"

\end_inset

Flujo de mensajes en la interacción entre el dispositivo y una aplicación
 a través de la sombra 
\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Flujo-de-mensajes-sombra"

\end_inset

 muestra el flujo de mensajes intercambiados entre el dispositivo y la aplicació
n, usando la sombra de intermediario.
 Como puede comprobarse, el estado publicado por el dispositivo (1) se almacena
 en un fichero JSON, la sombra del dispositivo, en la nube de Amazon (2).
 Este fichero será proporcionado a la aplicación cuando ésta realice una
 petición del estado del dispositivo (3).
 Cada vez que el usuario solicite un cambio de estado a través de la aplicación
 (4), estos cambios se almacenarán en el fichero JSON, hasta que el dispositivo
 se conecte a la Nube y ejecute una actualización de su estado (5).
 Será entonces cuando el dispositivo recibirá la acción solicitada bajo
 el apartado 
\lang english
desired
\lang spanish
 de la sombra.
 Una vez realizada la acción, con éxito o no, el dispositivo reportará su
 nuevo estado en el apartado 
\lang english
reported
\lang spanish
 (6).
 La aplicación será informada de inmediato, siempre y cuando esté en línea
 (7).
\end_layout

\begin_layout Standard
Una ventaja de la existencia de la sombra del dispositivo con respecto a
 otras implementaciones es que puede conocerse el estado del dispositivo
 aunque este se encuentre sin conexión.
 Evidentemente, en este caso no contaremos con el estado actualizado, pero
 podremos visualizar el último estado registrado.
 Además, la sombra cuenta con una serie de metadatos, en los que se incluye
 un sello temporal (
\lang english
timestamp
\lang spanish
) con la última actualización en cada uno de los sentidos de la comunicación.
 Del mismo modo, será posible enviar instrucciones a nuestro dispositivo
 independientemente de su conectividad.
\end_layout

\begin_layout Standard
El 
\begin_inset CommandInset ref
LatexCommand formatted
reference "alg:Ejemplo-de-sombra"

\end_inset

 muestra un ejemplo sencillo de sombra de dispositivo, en el que la aplicación
 requiere un cambio de color en el LED del dispositivo.
\end_layout

\begin_layout Subsection
Esquema de conexión
\end_layout

\begin_layout Standard
Como en cualquier esquema IoT, el dispositivo se comunicará con la plataforma
 a través de una conexión a Internet.
 En el caso de AWS
\begin_inset space ~
\end_inset

IoT, la comunicación se lleva a cabo a través del protocolo MQTT, sobre
 un canal seguro TLS.
 Esta conexión se produce en varios pasos:
\end_layout

\begin_layout Standard
En primer lugar, el dispositivo, que tendrá el rol de cliente, inicia una
 comunicación segura TLS con el servidor de AWS
\begin_inset space ~
\end_inset

IoT.
 En esta primera comunicación servidor y cliente intercambian y verifican
 el certificado digital de la otra parte.
 De esta forma, la plataforma identifica y autentica el dispositivo, y el
 dispositivo se asegura de la autenticidad del servidor.
 En este proceso se establece una clave con la que se encriptarán todos
 los mensajes.
\end_layout

\begin_layout Standard
Una vez establecida la comunicación segura, el dispositivo puede publicar
 mensajes siguiendo el protocolo MQTT.
 Cuando el dispositivo trata de publicar un mensaje en un 
\lang english
topic
\lang spanish
, la plataforma verifica si este tiene permiso para publicar en dicho 
\lang english
topic
\lang spanish
.
 En caso afirmativo, el 
\lang english
message
\begin_inset space ~
\end_inset

broker 
\lang spanish
retransmite este mensaje a cualquier elemento de la red suscrito a este
 
\lang english
topic
\lang spanish
.
 Del mismo modo, el dispositivo puede suscribirse a cualquier 
\lang english
topic
\lang spanish
 simpre y cuando tenga permisos para ello.
\end_layout

\begin_layout Subsubsection
Actualización de la sombra
\begin_inset Index idx
status open

\begin_layout Plain Layout
sombra del dispositivo
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
device shadow
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La actualización de la sombra se lleva a cabo publicando mensajes en unos
 topics especiales, destinados a este fin.
 En concreto, están definidos los siguientes 
\lang english
topics
\lang spanish
, donde el dispositivo queda identificado por la variable 
\family typewriter
thingName
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-Shadow-MQTT-Topics"

\end_inset

.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/shadow/update
\family default
 Tanto las aplicaciones como los dispositivos pueden publicar mensajes a
 este 
\lang english
topic
\lang spanish
 para actualizar la sombra.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/update/accepted
\family default
 AWS
\begin_inset space ~
\end_inset

IoT publica un mensaje en este 
\lang english
topic
\lang spanish
 para confirmar la actualización de la sombra.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/update/rejected
\family default
 AWS
\begin_inset space ~
\end_inset

IoT publica un mensaje en este 
\lang english
topic
\lang spanish
 para indicar que la actualización de la sombra no tuvo éxito.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/get
\family default
 Tanto las aplicaciones como los dispositivos pueden publicar un mensaje
 vacío a este
\lang english
topic
\lang spanish
 para obtener la sombra.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/get/accepted
\family default
 AWS
\begin_inset space ~
\end_inset

IoT publica un mensaje en este 
\lang english
topic
\lang spanish
 para con la sombra actual.
\end_layout

\begin_layout Description

\family typewriter
$aws/things/thingName/get/rejected
\family default
 AWS
\begin_inset space ~
\end_inset

IoT publica un mensaje de error en este 
\lang english
topic
\lang spanish
 para indicar que no se pudo recuperar la sombra.
\end_layout

\begin_layout Standard
De forma adicional, existen otros 
\lang english
topics
\lang spanish
 especiales relacionados con la sombra, cuyo uso es más avanzado.
\end_layout

\begin_layout Subsubsection
RESTful API
\end_layout

\begin_layout Standard
AWS
\begin_inset space ~
\end_inset

IoT dispone de una API RESTful para permitir que las aplicaciones puedan
 conectarse e interactuar con la sombra a través del protocolo HTTPS.
 En este caso, la seguridad es similar a la llevada a cabo en el caso del
 dispositivo.
 La diferencia es que la aplicación puede tener una credencial basada en
 una tupla (ID,
\begin_inset space ~
\end_inset

clave) en vez de un certificado 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-Shadow-RESTful-API"

\end_inset

.
\end_layout

\begin_layout Section
Disparadores y reglas
\end_layout

\begin_layout Standard
Aunque no se han usado en la consecución de este proyecto, destacamos que
 AWS
\begin_inset space ~
\end_inset

IoT permite definir reglas con las que pueden realizarse diversas acciones
 al detectar eventos determinados.
 De este modo, es posible redireccionar mensajes entre distintos 
\lang english
topics
\lang spanish
 MQTT, detectar la superación de un umbral en un determinado parámetro,
 detectar la aparición de un mensaje concreto en un 
\lang english
topic
\lang spanish
, etc.
 Las acciones que pueden asociarse a un evento son muy variopintas, pero
 siempre implican una interacción con otros servicios de la nube de Amazon.
 Así, por ejemplo, es posible insertar un nuevo registro en una base de
 datos 
\emph on
AWS
\begin_inset space ~
\end_inset

DynamoDB
\emph default
, invocar una función 
\emph on
AWS
\begin_inset space ~
\end_inset

Lambda
\emph default
 o enviar mensajes específicos a 
\emph on
AWS
\begin_inset space ~
\end_inset

Salesforce
\emph default
 .
\end_layout

\begin_layout Section
Opciones de facturación
\end_layout

\begin_layout Standard
Amazon Web Services (AWS) ofrece un amplio abanico de servicios de computación
 en la nube.
 Para cada servicio, el usuario debe abonar el precio correspondiente a
 los recursos consumidos.
 Aunque existen varias modalidades de facturación, todas ellas requieren
 que el usuario proporcione un método de pago.
 Sin embargo, existen dos alternativas gratuitas.
\end_layout

\begin_layout Subsubsection
AWS Free Tier
\end_layout

\begin_layout Standard
Amazon establece un período de prueba gratuito para atraer nuevos clientes
 y dar a conocer su tecnología.
 En este período, es posible utilizar la mayoría de los servicios ofrecidos
 por AWS sin incurrir en gastos.
 No obstante, es necesario configurar un método de pago para comenzar a
 usar los servicios.
 Todos los detalles sobre AWS
\begin_inset space ~
\end_inset

Free
\begin_inset space ~
\end_inset

Tier están disponibles en 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://aws.amazon.com/free/
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-Free"

\end_inset

.
\end_layout

\begin_layout Subsubsection
AWS Educate
\end_layout

\begin_layout Standard
AWS
\begin_inset space ~
\end_inset

Educate proporciona a profesores y alumnos acceso a muchos de los servicios
 de AWS.
 Además, incluye ventajas como programas de capacitación y rutas profesionales
 en la nube de Amazon.
 Esta modalidad, que está disponible en 47 países, requiere que el usuario
 esté vinculado a alguna institución académica y procese una solicitud que
 será tratada de forma personalizada por Amazon
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Deberá usarse el correo institucional en la solicitud.
\end_layout

\end_inset

.
 Los detalles de esta modalidad están disponibles en 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://aws.amazon.com/education/
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-Education"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Nosotros hemos optado por esta segunda opción.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Hablar de tarifas después del período gratuito!
\end_layout

\begin_layout Plain Layout
Comparar con: google, ibm, microsoft?
\end_layout

\end_inset


\end_layout

\end_body
\end_document
