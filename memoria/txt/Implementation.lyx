#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\master content.lyx
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part
Trabajo realizado
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Descripción-del-sistema"

\end_inset

Presentación del sistema
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Breve introducción de la Parte II
\end_layout

\end_inset

 Una vez revisados los fundamentos teóricos y las tecnologías usadas en
 este proyecto, pasaremos a describir el trabajo realizado durante la consecució
n del mismo.
 En los próximos cuatro capítulos presentaremos el sistema con el que trabajarem
os y los requisitos que deberá satisfacer, analizaremos las diferentes implement
aciones de TLS disponibles, y finalmente repasaremos el proceso de integración
 de la implementación escogida, así como el proceso de integración del AWS
\begin_inset space ~
\end_inset

IoT Device SDK.
\end_layout

\begin_layout Standard
Este capítulo está dedicado a la descripción detallada del sistema, reparando
 en el funcionamiento general del mismo y en cada uno de los elementos que
 lo forman.
 En primer lugar, presentaremos la estructura general del sistema, profundizando
 en la función llevada a cabo por cada uno de los elementos que lo forman.
 Pasaremos entonces a describir estos elementos en mayor profundidad, a
 fin de comprender mejor los detalles de la posterior integración.
\end_layout

\begin_layout Standard
Comenzaremos por introducir 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
dave
\end_layout

\end_inset

, el entorno de desarrollo integrado (
\lang english
integrated development environment
\lang spanish
, IDE) proporcionado por Infineon para trabajar con sus microcontroladores
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
xmc
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "infineon:DAVE"

\end_inset

.
 Será este IDE el que usaremos para editar el código fuente, compilar el
 proyecto y cargar el firmware en el dispositivo.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
una breve reseña sobre el entorno de trabajo y el workflow
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Entorno-de-trabajo"

\end_inset

El entorno de trabajo 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
DAVE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Trabajar con microcontroladores supone editar código fuente, compilarlo
 a la plataforma de destino, cargar el firmware en el dispositivo y depurar
 el programa en tiempo de ejecución.
 Esto puede hacerse de diferentes formas, usando distintos flujos de trabajo.
 Una de las más populares es usar un entorno de desarrollo integrado que
 reúna las herramientas necesarias para llevar a cabo estas tareas.
 En la realización de este trabajo, hemos usado 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 en su versión 4.3.2.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 es un IDE profesional y gratuito con el cuál podemos llevar a cabo todo
 el proceso de desarrollo, desde la evaluación hasta la producción (
\lang english
evaluation to production
\lang spanish
, E2P) 
\begin_inset CommandInset citation
LatexCommand cite
key "infineon:DAVE"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 está basado en el conocido entorno de desarrollo de código abierto Eclipse
\begin_inset space ~
\end_inset

IDE, e incluye el compilador de C de GNU (
\lang english
GNU C compiler
\lang spanish
, GCC), interfaz de depuración, repositorio de código completo, plug-in
 de generación de código y administración de recursos de hardware.
\end_layout

\begin_layout Standard
Como peculiaridad, resaltaremos que esta IDE incluye las denominadas 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE APPs
\end_layout

\end_inset

, que son componentes software orientados a aplicación que pueden configurarse
 a través de una interfaz gráfica de usuario (
\lang english
graphical user interface
\lang spanish
, GUI).
 Gracias a las mismas, es posible usar muchos de los módulos del microcontrolado
r de forma sencilla y eficiente.
 Al añadir una de estas APPs al proyecto, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 importa el código necesario para usar la biblioteca o módulo hardware proporcio
nados por la misma, colocando los ficheros de la biblioteca en un directorio
 reservado a tal efecto.
 Asímismo, las APPs proporcionan una API homogénea para acceder a los distintos
 recursos del microcontrolador, y están ampliamente documentadas.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/XMC-portfolio.png
	lyxscale 20
	width 75col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Componentes-DAVE"

\end_inset

Componentes de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 y flujo de trabajo.
 
\begin_inset CommandInset citation
LatexCommand cite
key "infineon:DAVE"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Componentes-DAVE"

\end_inset

 muestra los distintos componentes de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

, situando las 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 APPs en el entorno del IDE, además del flujo de trabajo E2P que puede obtenerse
 con el mismo.
 Como puede comprobarse en la misma, las 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 APPs se apoyan en la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
XMC
\end_layout

\end_inset

 Lib, que proporciona acceso a los distintos elementos del microcontrolador
 en un nivel más cercano a la máquina.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 se encarga de gestionar el proceso de compilación, usando GCC con los parámetro
s definidos en la configuración del proyecto.
 Como Eclipse
\begin_inset space ~
\end_inset

IDE, permite excluir algunos directorios o ficheros del proceso de compilación.
 Al final de este proceso, se genera un archivo binario con la extensión
 
\family typewriter
.bin
\family default
 cuyo contenido se ajusta a las regiones de memoria definidas en el 
\lang english
linker script
\lang spanish
.
 Para concluir el proceso, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 permite cargar el binario en los microcontroladores 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
XMC
\end_layout

\end_inset

 conectándose al mismo por USB, a través de un programador 
\begin_inset Note Note
status open

\begin_layout Plain Layout
con el bus
\end_layout

\end_inset

 JTAG.
 El firmware cargado puede depurarse haciendo uso de la interfaz gráfica
 de depuración de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

, la cuál se muestra por defecto después de cada programación.
\end_layout

\begin_layout Section
Objetivo perseguido y arquitectura propuesta
\end_layout

\begin_layout Standard
Como hemos introducido en el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Presentación-del-proyecto"

\end_inset

, el sistema con el que trabajaremos es una pasarela (miniGW) que permitirá
 la interconexión de una red de sensores, instalada en un 
\lang english
SmartHome
\lang spanish
, con la nube de Amazon ASW
\begin_inset space ~
\end_inset

IoT.
 En su versión actual, el miniGW es capaz de comunicarse con los sensores,
 almacenar los datos recibidos en memoria, mostrar los datos a través de
 una interfaz web sencilla, y actualizar la hora del sistema a través del
 protocolo NTP.
 Todos estos procesos están implementados como tareas en un sistema operativo
 de tiempo real denominado CMSIS-RTOS.
 El primer objetivo de este trabajo será integrar una biblioteca TLS con
 un 
\lang english
ciphersuite
\lang spanish
 que permita la conexión con AWS
\begin_inset space ~
\end_inset

IoT.
 Seguidamente, tendremos que integrar el AWS
\begin_inset space ~
\end_inset

IoT Device SDK, que proporcionará los mecanismos necesarios para establecer
 una conexión segura con la Nube y permitir la comunicación bidireccional.
 Esta comunicación, que en este caso se llevará a cabo a través del protocolo
 MQTT, permitirá enviar los datos de los sensores y recibir comandos para
 los actuadores.
\end_layout

\begin_layout Standard
A continuación presentaremos los distintos elementos que componen la arquitectur
a básica del sistema, la cuál se ilustra en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Arquitectura-del-sistema"

\end_inset

.
 Describiremos estos elementos con mayor profundidad en las siguientes secciones.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/esquema-general.eps
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Arquitectura-del-sistema"

\end_inset

Arquitectura general del sistema.
 Las líneas discontinuas representan la conexión inalámbrica a través del
 protocolo propietario de eesy-innovation.
 Las líneas continuas representan conexión IP.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
tenemos red de sensores, gw, Cloud y terminal (App)
\end_layout

\end_inset


\end_layout

\begin_layout Description
miniGW
\begin_inset Index idx
status open

\begin_layout Plain Layout
miniGW
\end_layout

\end_inset

 pasarela IoT, cuya función es comunicar la red de sensores con la nube
 de forma confiable, segura y eficiente.
 También está encargada de almacenar algunos elementos de configuración.
\end_layout

\begin_layout Description
Red
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

sensores
\begin_inset Index idx
status open

\begin_layout Plain Layout
red de sensores
\end_layout

\end_inset

 es el conjunto de sensores y actuadores que proporcionan información sobre
 variables de interés en el hogar y permiten controlarlo.
 Por simplicidad, denominaremos a este conjunto de dispositivos simplimente
 por el término 
\emph on
red de sensores
\emph default
.
\end_layout

\begin_layout Description
Nube se trata de un servicio on-line que permite el almacenamiento y gestión
 de los datos producidos por la red de sensores.
 En el presente proyecto, usaremos el servicio AWS
\begin_inset space ~
\end_inset

IoT para tal fin.
\end_layout

\begin_layout Description
App
\begin_inset space ~
\end_inset

móvil interfaz a través la cuál el usuario interacciona con su SmartHome.
 La App muestra los datos recogidos por los sensores y permite modificar
 el estado de los actuadores, manualmente o a través de reglas.
\end_layout

\begin_layout Section
La pasarela 
\emph on
miniGW
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
miniGW
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El dispositivo con el que trabajaremos será el miniGW introducido en la
 sección anterior.
 Como explicamos anteriormente, el miniGW es la pasarela entre la red de
 sensores y la nube de Amazon, por lo que organiza y traduce los mensajes
 de la red local, para transmitirlos a través de la pila de protocolos de
 Internet.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Ademas de la descripción técnica, asegurarnos de que comentamos las funciones:
 pasar mensajes de un lado a otro de forma reliable (sin perder ningún mensaje)
 y eficiente (lo más rápido posible).
 Características deseabes: bajo consumo, alto throughput, alto alcance en
 la red inalámbrica.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como puede comprobarse en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:miniGW-foto-hardware"

\end_inset

, el miniGW no es más que un pequeño circuito impreso, cuyas dimensiones
 no exceden los 5x5x2
\begin_inset space ~
\end_inset

cm.
 Se trata de un dispositivo basado en microcontrolador, en el que un XMC4500
 hace las veces de cerebro, encargándose de la lógica y de la coordinación
 de las distintas interfaces.
 Es en este circuito donde se encuentra el programa que gestiona las distintas
 tareas de las que el miniGW tiene que hacerse cargo, así como la pila de
 protocolos de Internet y los controladores de las distintas interfaces.
 Entre estas interfaces, cabe destacar el TDA5340, un transceptor de muy
 bajo consumo encargado de mantener la comunicación con los sensores.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/MiniGW_01.jpg
	lyxscale 10
	width 50col%

\end_inset


\begin_inset Graphics
	filename img/MiniGW_02.jpg
	lyxscale 10
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:miniGW-foto-hardware"

\end_inset

Fotografía del hardware del miniGW.
 Pueden observarse distintos componentes electrónicos e interfaces.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Además de estos circuitos principales, que describiremos a continuación,
 el miniGW cuenta con las siguientes interfaces físicas.
 Estas interfaces, representadas en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:miniGW-Arquitectura-hardware"

\end_inset

, permiten que el miniGW se comunique con el mundo exterior:
\end_layout

\begin_layout Description
Puerto
\begin_inset space ~
\end_inset

micro
\begin_inset space ~
\end_inset

USB proporciona alimentación al circuito.
 Además, puede usarse para varios propósitos, como establecer una comunicación
 serial o actualizar el firmware del XMC4500.
\end_layout

\begin_layout Description
Conector
\begin_inset space ~
\end_inset

RJ45 proporciona conexión a Internet a través de Ethernet.
\end_layout

\begin_layout Description
Ranura
\begin_inset space ~
\end_inset

micro
\begin_inset space ~
\end_inset

SD proporciona acceso a una memoria no volátil, sirviendo de almacenamiento
 para los datos de sensores, la interfaz web, etc.
 También puede usarse para cargar un nuevo firmware del XMC4500.
\end_layout

\begin_layout Description
Antena recoge las señales de radio enviadas por los sensores, a la vez que
 permite transmitir señales a los actuadores.
 Está conectada directamente al TDA5340.
\end_layout

\begin_layout Description
Acceso
\begin_inset space ~
\end_inset

a
\begin_inset space ~
\end_inset

pines se trata de un acceso a la interfaz de programación y depuración del
 microcontrolador JTAG.
 Este conector solo se encuentra en la versión de desarrollo del miniGW,
 no soldándose en producción.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/hardware-architecture.eps
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:miniGW-Arquitectura-hardware"

\end_inset

Arquitectura hardware del miniGW.
 Pueden distinguirse los módulos principales y las diferentes interfaces.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A continuación expondremos algunos detalles de interés sobre los dos módulos
 principales del sistema: el microcontrolador XMC4500 y el transceptor TDA5340.
 Posteriormente, introduciremos la estructura del firmware presente en el
 miniGW.
\end_layout

\begin_layout Subsubsection
XMC4500
\end_layout

\begin_layout Standard
XMC4500 es un microcontrolador de la familia de microcontroladores de alto
 rendimiento XMC4000 de Infineon.
 Esta familia, basada en el procesador ARM Cortex-M4, está optimizada para
 tareas tales como el control industrial, conversión de potencia y sensorización
 y control.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/XMC-block-diagram.eps
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:XMC-block-diagram"

\end_inset

Diagrama de bloques del microcontrolador XMC4500 
\begin_inset CommandInset citation
LatexCommand cite
key "infineon:XMC4500"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:XMC-block-diagram"

\end_inset

 muestra el diagrama de bloques de este circuito, que cuenta con numerosos
 módulos de aceleración hardware.
 A continuación presentamos una lista con las características principales
 de este microcontrolador 
\begin_inset CommandInset citation
LatexCommand cite
key "infineon:XMC4500"

\end_inset

.
 Esta lista no es exhaustiva, nos centraremos exclusivamente en aquellas
 características que serán más relevantes en la consecución del presente
 proyecto.
\end_layout

\begin_layout Itemize
Núcleo de procesamiento
\end_layout

\begin_deeper
\begin_layout Itemize
Núcleo ARM Cortex-M4.
 CPU de 32 bits de alto rendimiento, con instrucciones para procesamiento
 digital de señales (DSP).
\end_layout

\begin_layout Itemize
Temporizador del sistema (SysTick) para dar soporte a sistemas operativos.
\end_layout

\begin_layout Itemize
Unidades de acceso directo a memoria (DMA) y de protección de memoria (MPU).
\end_layout

\end_deeper
\begin_layout Itemize
Bancos de memoria integrados
\end_layout

\begin_deeper
\begin_layout Itemize
16 KB 
\lang english
on-chip boot ROM.
\end_layout

\begin_layout Itemize
64 KB 
\lang english
on-chip high-speed program memory.
\end_layout

\begin_layout Itemize
64 KB 
\lang english
on-chip high speed data memory.
\end_layout

\begin_layout Itemize
32 KB 
\lang english
on-chip high-speed communication.
\end_layout

\begin_layout Itemize
1024 KB 
\lang english
on-chip Flash Memory 
\lang spanish
con
\lang english
 4 KB instruction cache.
\end_layout

\end_deeper
\begin_layout Itemize
Periféficos de comunicación
\end_layout

\begin_deeper
\begin_layout Itemize
Módulo Ethernet MAC compatible con las tasas de transmisión 10/100 Mbit/s.
\end_layout

\begin_layout Itemize
Universal Serial Bus, USB 2.0 
\lang english
host
\lang spanish
.
\end_layout

\begin_layout Itemize
Canales de interfaz serial universal (USIC), configurables como interfaces
 UART, double-SPI, quad-SPI, IIC, IIS y LIN.
\end_layout

\begin_layout Itemize
Interfaces SD y Multi-Media Card (SDMMC) para tarjetas de almacenamiento
 de datos.
\end_layout

\begin_layout Itemize
Unidad de interfaz de bus externo (EBU), permitiendo la comunicación con
 memorias externas y otros periféricos 
\lang english
off-chip
\lang spanish
.
\end_layout

\end_deeper
\begin_layout Itemize
Periféricos analógicos
\end_layout

\begin_deeper
\begin_layout Itemize
Conversores analógico-digital (VADC) con 12 bits de resolución.
\end_layout

\begin_layout Itemize
Conversores digital-analógico (DAC) con 12 bits de resolución.
 Estos conversores tienen distintos modos de operación, con los que pueden
 generar distintas formas de onda, incluyendo ruido 
\begin_inset CommandInset citation
LatexCommand cite
key "infineon:XMC4500-reference"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Periféricos de control industrial
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Unidades de captura y comparación (CCU4 y CCU8), que pueden ser configuradas
 como temporizadores o generadores de señal modulada por ancho de pulsos
 (PWM), entre otras muchas configuraciones 
\begin_inset CommandInset citation
LatexCommand cite
key "infineon:CCU8,infineon:CCU8"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Perro guardián (WDT).
\end_layout

\begin_layout Itemize
Reloj de tiempo real (RTC).
\end_layout

\end_deeper
\begin_layout Itemize
Soporte para depuración del firmware
\end_layout

\begin_deeper
\begin_layout Itemize
Interfaces ARM-JTAG y SWD.
\end_layout

\begin_layout Itemize
Soporte para 
\lang english
breakpoints
\lang spanish
.
\end_layout

\end_deeper
\begin_layout Subsubsection
TDA5340
\end_layout

\begin_layout Standard
El TDA5340 es un transceptor de bajo consumo diseñado y producido por Infineon
 para aplicaciones en la industria del automóvil.
 Este circuito integrado permite distintos tipos de modulación, como ASK,
 FSK y GFSK para las bandas de frecuencia 300-320, 415-495 y 863-960 MHz
 
\begin_inset CommandInset citation
LatexCommand cite
key "infineon:TDA5340"

\end_inset

.
 El tipo de modulación, la frecuencia y otros parámetros de transmisión
 son seleccionados a través de un pequeño firmware que se ejecuta en este
 circuito.
 Este firmware permite además llevar a cabo algunas operaciones básicas
 como la entrada en el modo de suspensión.
\end_layout

\begin_layout Standard
Este módulo será el encargado de comunicar el miniGW con la red de sensores,
 recibiendo los datos de los distintos sensores para proporcionárselos al
 XMC4500 a través de un bus SPI.
 De forma análoga, el TDA enviará comandos a los actuadores a petición del
 microcontrolador.
\end_layout

\begin_layout Standard
La comunicación con los sensores y actuadores de la red de sensores se lleva
 a cabo a través de un protocolo propietario, que usa cifrado por bloques
 AES en modo contador (AES-CTR) para garantizar la seguridad.
\end_layout

\begin_layout Subsubsection
Firmware del XMC4500
\end_layout

\begin_layout Standard
La lógica del XMC4500 debe garantizar que el miniGW realiza todas las funciones
 para las que fue diseñado.
 En este firmware se incluyen diversas tareas que deberán ejecutarse en
 paralelo, como la recepción de paquetes de datos de los sensores o la continua
 actualización de la fecha y hora a través del protocolo NTP.
 La arquitectura del firmware puede consultarse en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Arquitectura-firmware"

\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
La estructura del firmware es muy compleja y escapa a los objetivos de esta
 memoria.
\end_layout

\end_inset

 Cabe destacar que la finalidad de este proyecto no es añadir nuevas funcionalid
ades al firmware desarrollado, sino demostrar el uso de AWS
\begin_inset space ~
\end_inset

IoT Device SDK para que eesy-innovation lleve a cabo la integración final.
 Como hemos mencionado ya, este SDK requerirá una capa de seguridad TLS,
 que deberá ser compatible con el resto de elementos del firmware.
 Por este motivo, necesitamos revisar cuáles son los elementos fundamentales
 que estarán incluidos en el sistema final, y que supondrán el marco en
 el cuál deberemos integrar la biblioteca TLS y el AWS IoT SDK.
 A continuación revisamos los elementos software principales.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Explicar mejor cómo funciona el firmware y qué tareas se van a tener (explicació
n exhaustiva de las funciones implementadas en el miniGW -> fuera del scope
 del documento, pero se contarán algunas tareas representativas y qué recursos
 requieren p.ej.
 NTP client ejecutándose cada cierto intervalo de tiempo y actualizando
 el RTC, reenvío de datos de los sensores cada vez que se recibe un paquete
 (TDA->SHEI->JSON->lwIP)).
\end_layout

\begin_layout Plain Layout
En la prueba 1: una tarea sencilla que sea cliente HTTPS.
 
\end_layout

\begin_layout Plain Layout
En la prueba 2: Cliente de AWS IoT, que enviará un mensaje a un canal MQTT
 cada cierto tiempo.
\end_layout

\begin_layout Plain Layout
En el sistema final (fuera de los objetivos de este trabajo): tarea para
 NTP, tarea para recepción de los datos de los sensores, tarea para actualizar
 la sombra, etc.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/firmware-architecture.eps
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Arquitectura-firmware"

\end_inset

Arquitectura del firmware del miniGW.
 Las líneas continuas indican dependencias entre módulos, las líneas discontinua
s indican comunicación entre tareas.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Contar un poco la arquitectura: tareas con funcionalidad específica que
 se sustentan en otras bibliotecas, principalmente las pilas de protocolos
 IP y SHEI (red de sensores) y en los elementos de bajo nivel, proporcionados
 en última instancia por la XMClib.
 Se explican con detalle dos de los módulos más grandes y que serán usados
 posteriormente.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
CMSIS-RTOS
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset

(vX.Y#!)
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
versión del software!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las distintas tareas que debe realizar
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
El firmware d
\end_layout

\end_inset

 el miniGW está construidas sobre un sistema operativo de tiempo real denominado
 CMSIS-RTOS.
 Este RTOS, diseñado especialmente para dispositivos Cortex-M
\begin_inset Note Note
status open

\begin_layout Plain Layout
 #ref#
\end_layout

\end_inset

, permite que las distintas tareas se ejecuten de forma concurrente y proporcion
an herramientas para la gestión de recursos y de la comunicación entre tareas.
\end_layout

\begin_layout Paragraph
lightweight
\begin_inset space ~
\end_inset

IP
\begin_inset space ~
\end_inset

(lwIP)
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset

(vX.Y#!)
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
versión del software!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La pila de protocolos de Internet está proporcionada por lwIP.
 Esta biblioteca está diseñada para reducir el uso de recursos, conservando
 todas las funcionalidades de TCP/IP
\begin_inset Note Note
status open

\begin_layout Plain Layout
 #ref#
\end_layout

\end_inset

.
 Proporciona una interfaz de sockets tipo BSD estándar.
\end_layout

\begin_layout Standard
Tanto CMSIS-RTOS como lwIP están disponibles en el formato de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 APPs, por lo que han sido añadidas al proyecto usando esta herramienta.
\begin_inset Note Note
status open

\begin_layout Plain Layout
, como muestra la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:DAVE-main"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
#missing image#
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:DAVE-main"

\end_inset

Vista principal en 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

.
 En la zona inferior pueden observarse las 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 APPs que se usan en el proyecto de partida.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Red de sensores
\end_layout

\begin_layout Standard
La red de sensores se encarga de monitorizar variables de interés para el
 usuario, transmitiéndolos al miniGW de forma inalámbrica.
 La gama de productos H2 de eesy-innovation incluye una multitud de sensores
 y actuadores, como sensores de presencia, estación meteorológica, enchufe
 inteligente (
\lang english
SmartPlug
\lang spanish
), etc.
 Todos estos nodos se comunican con el miniGW de forma segura a través de
 un protocolo propietario.
 Además, cada uno de estos sensores y actuadores tiene un número de identificaci
ón único (
\lang english
unique identity
\lang spanish
, UID) que lo identifica de forma única, no solo en la red local, sino en
 toda la Internet.
\begin_inset Note Note
status open

\begin_layout Plain Layout
explicar mejor
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una diferencia a destacar entre los sensores y los actuadores es que los
 primeros usan un transmisor (comunicación unidireccional) mientras que
 los segundos hacen uso de un transceptor (comunicación bidireccional).
 Esto fuerza que la topología de red sea en estrella, con el miniGW como
 nodo central.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Gracias al uso de transmisores dede muy bajo consumo, los sensores que les
 permite funcionar con batería durante meses
\end_layout

\end_inset


\end_layout

\begin_layout Section
La nube de Amazon 
\emph on
AWS
\begin_inset space ~
\end_inset

IoT
\end_layout

\begin_layout Standard
El servicio AWS IoT se encarga de almacenar los datos de los sensores, haciendo
 que permanezcan disponibles para que el usuario pueda consultarlos cuando
 desee.
 Esto se consigue gracias a la sombra del dispositivo, descrita en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Esquema-de-funcionamiento"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
deberíamos mencionar las ventajas que tiene esta nube? qué funcionalidad?
 -> almacenamiento de datos recogidos de los sensores, retransmisión de
 datos a la App móvil (y desde la App a los actuadores), servicio siempre
 disponible (puerta de los usuarios a sus datos), seguridad de los datos...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
En los otros hemos dado especificaciones técnicas.
 Dar especificaciones técnicas de AWS IoT otra vez (algunos detalles de
 la web)? referenciar capítulo?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La nube alojará dispositivos virtuales, uno por cada dispositivo físico
 (sensor o actuador), que tendrá que asociar al usuario.
 La definición de estos dispositivos en producción está fuera del alcance
 de este proyecto.
 En la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:AWS-IoT-Verificacion-integracion"

\end_inset

 se definirá un dispositivo de prueba para la propia pasarela haciendo uso
 de la consola de AWS
\begin_inset space ~
\end_inset

IoT, de forma que podamos verificar la comunicación entre el miniGW y la
 Nube.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Brevemente, ya ha sido descrita en cap 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\color red
\begin_inset Note Note
status open

\begin_layout Plain Layout

\color red
Identificar elementos físicos con nombres de Amazon
\end_layout

\end_inset


\end_layout

\begin_layout Section
App móvil
\end_layout

\begin_layout Standard
La App se conecta a la nube de Amazon a través de las APIs pertinentes,
 permitiendo al usuario visualizar los datos.
 Esta App queda fuera del alcance de este proyecto, por lo que usaremos
 la consola de AWS
\begin_inset space ~
\end_inset

IoT para verificar el intercambio de mensajes.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Sin embargo, para comprobar que la conexión entre el miniGW y la nube de
 Amazon se establece correctamente, se ha usado la consola de AWS IoT, como
 se describirá en el capítulo ###.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Análisis-implementacions-TLS"

\end_inset

Análisis de diferentes bibliotecas TLS
\end_layout

\begin_layout Standard
Como vimos en el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Seguridad-en-sist-empotrados"

\end_inset

, las dos características principales de un sistema empotrado son sus limitacion
es de recursos y la ausencia de un sistema operativo real.
 Estas dos características derivan directamente de la definición de sistema
 empotrado (sistema que realiza una tarea específica), y condicionan por
 completo el desarrollo de su software.
\end_layout

\begin_layout Standard
En el tema que nos ocupa, las limitaciones en los recursos computacionales
 nos llevarán a buscar implementaciones del protocolo TLS ligeras, cuya
 configuración se realice, preferiblemente, en tiempo de compilación.
 También tendremos que asegurarnos de que las implementaciones analizadas
 puedan funcionar con los servicios mínimos proporcionados por un RTOS.
\end_layout

\begin_layout Standard
Dedicaremos el presente capítulo al análisis de diversas implementaciones
 TLS, llevado a cabo tras un ejercicio de búsqueda cuyo objetivo ha sido
 conocer las implementaciones TLS más destacadas en el ámbito de los sistemas
 empotrados.
 Realizaremos este análisis mediante la evaluación de una lista de característic
as, que incluye, pero no se limita a: requisitos computacionales, funcionalidade
s, portabilidad y coste de la implementación.
 Elegiremos la biblioteca TLS atendiendo al análisis presentado a continuación,
 que también contará, de forma adicional, con algunos aspectos económicos
 y de licencia.
\color red

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\color red
The aim of this section is to research and analyze the available TLS libraries.
 WolfSSL and mbedTLS will be first considered and analyzed.
 If other libraries with similar characteristics are found will be considered
 in the study also.
 A list of features will be evaluated, including (but not limiting to) computati
onal requirements, functional capabilities, portability, cost implementation,
 etc.
 Choice of the TLS library to be adapted based on the features previously
 evaluated.
 The decision will be justified using engineering criteria.
 The chosen TLS library will also satisfy the requirements regarding intended
 functionality as well as economical and legal conditions.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Alternativas a OpenSSL.
 Más ligeras, gracias a que pueden elegirse las ciphersuites en tiempo de
 compilación.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Hablar brevemente de mi experiencia con las bibliotecas y chips que he usado
 (características, requisitos en cuanto a recursos, opciones de configuración,
 etc).
\end_layout

\end_inset


\end_layout

\begin_layout Section
Criterios de búsqueda y evaluación
\end_layout

\begin_layout Standard
La búsqueda de bibliotecas TLS se ha llevado a cabo usando diversas herramientas
 de búsqueda, entre las que se inclyen el motor genérico de Google, artículos
 de Wikipedia 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki:tls-implementations"

\end_inset

, los repositorios de Github y el foro de desarrolladores Stack
\begin_inset space ~
\end_inset

Exchange.
 Esta búsqueda, en cambio, ha prescindido de bases de datos académicas,
 ya que se solo hemos considerado implementaciones comerciales o que se
 encuentren en producción.
\end_layout

\begin_layout Standard
En nuestra búsqueda, solo hemos considerado aquellas implementaciones de
 TLS que se ajustaran a sistemas embebidos.
 Este criterio supone que las bibliotecas deben estar programadas en lenguaje
\begin_inset space ~
\end_inset

C estándar, y que deben presentar el mínimo número de dependencias.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Estas características son muy deseables a la hora de integrar una biblioteca
 en un sistema embebido.
\end_layout

\end_inset

 Idealmente, la biblioteca seleccionada presentará ciertas facilidades para
 la integración con el sistema objetivo, como la compilación nativa en CMSIS-RTO
S o compatibilidad con la pila de lwIP.
\end_layout

\begin_layout Standard
Además de la compatibilidad con el sistema, será necesario que la implementación
 seleccionada cumpla con los siguientes criterios:
\end_layout

\begin_layout Itemize
Biblioteca en continuo desarrollo: se trata de un requisito de seguridad,
 ya que es frecuente encontrar vulnerabilidades en las implementaciones,
 y estas deben solventarse cuanto antes.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 - presencia en redes sociales / foros y actividad de la comunidad.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\lang english
Ciphersuite
\lang spanish
 compatible con AWS
\begin_inset space ~
\end_inset

IoT.
 Se requiere TLS
\begin_inset space ~
\end_inset

1.2, con alguno de los ciphersuites listados en 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-Security-and-Identity"

\end_inset

.
 En especial, se recomiendan:
\end_layout

\begin_deeper
\begin_layout Itemize
ECDHE-ECDSA-AES128-GCM-SHA256
\end_layout

\begin_layout Itemize
ECDHE-RSA-AES128-GCM-SHA256
\end_layout

\end_deeper
\begin_layout Standard
Los criterios de búsqueda establecidos nos hacen descartar la conocida bibliotec
a de seguridad OpenSSL.
 A pesar de que esta biblioteca cuenta con una larga tradición y sigue siendo
 un marco de referencia para muchas de las aplicaciones que implementan
 TLS, OpenSSL no fue diseñada para sistemas embebidos, por lo que su tamaño
 excede las limitaciones de nuestro sistema.
 Además, presenta dependencias que serían difícilmente salvables, y sus
 desarrolladores no recomiendan compilar OpenSSL en un entorno para el que
 no está preparado 
\begin_inset CommandInset citation
LatexCommand cite
key "OpenSSL-wiki-config"

\end_inset

.
\end_layout

\begin_layout Standard
Además de los requisitos mencionados anteriormente, se evaluarán positivamente
 las siguientes características:
\end_layout

\begin_layout Itemize
Disponibilidad de documentación: será indispensable una buena documentación
 para comprobar la disponibilidad de características y el uso de las distintas
 funciones definidas en la API.
\end_layout

\begin_layout Itemize
Soporte para ingenieros: será conveniente en el caso en que se necesite
 soporte durante la implementación.
\end_layout

\begin_layout Itemize
Disponibilidad del código fuente: se valorará positivamente la disponibilidad
 del código fuente previa adquisición de la licencia, de forma que podamos
 indagar en el mismo para evaluar la implementación.
 Además, tener el código fuente abierto a la comunidad disminuye el riesgo
 de que contenga errores o puertas traseras
\begin_inset Note Note
status open

\begin_layout Plain Layout
 #ref#
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Licencias compatibles con la actividad a realizar, con precios razonables.
\end_layout

\begin_layout Section
Bibliotecas analizadas
\end_layout

\begin_layout Standard
En esta sección presentaremos brevemente cada una de las bibliotecas analizadas,
 revisando algunos datos generales o de especial relevancia.
\end_layout

\begin_layout Subsubsection
mbedTLS
\end_layout

\begin_layout Standard
Esta implementación, lanzada en 2006 bajo la denominación de PolarSSL, da
 soporte a los protocolos y configuraciones de TLS más usados.
 Se centra en la claridad del código y modularidad y está ampliamente documentad
a.
 Se distribuye bajo la licencia de código abierto Apache 2.0, por lo que
 puede usarse de forma gratuita para propósitos comerciales, siempre que
 se respeten los términos de la licencia.
\end_layout

\begin_layout Standard
Además, mbedTLS es la biblioteca de seguridad del proyecto mbed de ARM.
 Este proyecto trata de poner en conjunto una serie de herramientas para
 el desarrollo ágil de sistemas empotrados, incluyendo IoT.
 Con mbedTLS, la compañía apuesta por un mundo de dispositivos interconectados
 de forma segura.
\end_layout

\begin_layout Subsubsection
WolfSSL
\end_layout

\begin_layout Standard
Lanzada en 2006 bajo la denominación de CyaSSL, da soporte a los protocolos
 y configuraciones de TLS más usados.
 Es altamente modular y personalizable, gracias a los diversos Makefiles
 que incluye consigo.
 Se distribuye siguiendo un modelo de doble licencia, incluyendo una licencia
 
\lang english
Open Source
\lang spanish
 y otra comercial, que tiene un precio de license USD $5000.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esta implementación es conocida por su uso en MySQL
\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

, por lo que ha adquirido una presencia considerable.
 Por último, una de las versiones de la biblioteca criptográfica wolfCrypt
 dispone de un certificado de verificación FIPS
\begin_inset space ~
\end_inset

140-2
\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

 (Certificate #2425).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
MatrixSSL
\end_layout

\begin_layout Standard
Lanzada en 2004, da soporte a los protocolos y configuraciones de TLS más
 usados.
 De acuerdo con la web oficial, su 
\lang english
footprint
\lang spanish
 puede ser reducido hasta ~50KB, incluyendo biblioteca de criptografía y
 certificados, o hasta ~10KB en su 
\emph on
Tiny version
\emph default
, que solo soporta PSK
\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
 Se distribuye bajo la licencia de software libre GPLv2, aunque también
 existe una licencia comercial (precio no disponible en la web oficial).
\end_layout

\begin_layout Subsubsection
cryptlib
\end_layout

\begin_layout Standard
Lanzada inicialmente en 1995, da soporte a los protocolos y configuraciones
 de TLS más usados.
 Tiene un modelo de doble licencia, incluyendo una licencia Open Source
 y otra comercial, que puede adquirirse por USD $5000
\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
SharkSSL
\end_layout

\begin_layout Standard
Esta implementación es una propuesta de Real Time Logic, una firma estadounidens
e dedicada a IoT.
 La compañía también distribuye soluciones para HTTPS, MQTT y SMQ, entre
 otras.
 De acuerdo con la web, SharkSSL puede compilarse en menos de 38KB ROM,
 necesitando solo 13KB RAM en tiempo de ejecución
\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
 Se distribuye bajo una licencia privada, cuyo precio no está disponible
 en la web
\begin_inset Note Note
status open

\begin_layout Plain Layout
#ref#
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Análisis comparativo
\end_layout

\begin_layout Standard
La 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparación-general"

\end_inset

 muestra algunos datos generales de las bibliotecas mencionadas anteriormente,
 en los que se incluye la licencia y la compatibilidad con los distintos
 estándares TLS.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
arrayrulewidth=1.3pt
\end_layout

\end_inset


\size small

\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="6">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="2cm">
<column alignment="left" valignment="top" width="2cm">
<column alignment="left" valignment="top" width="2cm">
<column alignment="left" valignment="top" width="2cm">
<column alignment="left" valignment="top" width="2cm">
<column alignment="left" valignment="top" width="2cm">
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
arrayrulecolor{white}
\backslash
rowcolor{head}
\backslash
color{white}
\end_layout

\end_inset


\size small
Implemen-tación
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

WolfSSL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

mbedTLS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

MatrixSSL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

cryptlyb
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

SharkSSL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Desarrollador
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

WolfSSL Inc.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Arm Limited
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

PeerSec Networks
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Peter Gutmann
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Real Time Logic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

License
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset


\size small
GPLv2 / comercial
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset


\size small
Apache Licences 2.0 || GPLv2 / comercial
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset


\size small
GPLv2 / comercial
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset


\size small
Licencia Sleepycat / comercial
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset


\size small
Privativa (distribución comercial)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Precio para uso comercial
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

USD $5000
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sin costo (con condiciones)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset


\size small
Información no disponible en la web
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

USD $5000
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset


\size small
Información no disponible en la web
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

SSL 2.0 (no
\begin_inset space ~
\end_inset

seguro)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

No
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

No
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

No
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

No
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

No especificado
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

SSL 3.0 (no
\begin_inset space ~
\end_inset

seguro)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Desactivado por defecto
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Desactivado por defecto
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Desactivado por defecto
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Desactivado por defecto
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

No especificado
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

TLS 1.0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

TLS 1.1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

TLS 1.2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

DTLS 1.0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

No
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

DTLS 1.2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

No
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

NSA Suite B
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Verificaciones FIPS-140 de nivel 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

wolfCrypt FIPS Module: 3.6.0 (#2425)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

No
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

SafeZone FIPS Cryptographic Mudule: 11 (#2389)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

No
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Conocido por
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Usado en MySQL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Parte del proyecto mbed de ARM
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

No aplica
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

No aplica
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

No aplica
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparación-general"

\end_inset

Comparación de las bibliotecas analizadas: datos generales, licencia y compatibi
lidad con los distintos estándares TLS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Debemos destacar aquí que a pesar de las diferencias mostradas, todas las
 bibliotecas consideradas cumplen con las siguientes características.
\end_layout

\begin_layout Itemize
Lenguaje de programación
\begin_inset space ~
\end_inset

C estándar (y ensamblador, en algunos casos).
\end_layout

\begin_layout Itemize
Soporte para TLS 1.2.
\end_layout

\begin_layout Itemize
Soporte para la Suite
\begin_inset space ~
\end_inset

B definida por la agencia nacional de seguridad de los EEUU (National Security
 Agency, NSA
\begin_inset Index idx
status open

\begin_layout Plain Layout
National Security Agency (NSA)
\end_layout

\end_inset

), que incluye 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc6379-NSA-Suite-B"

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Algoritmos de criptografía simétrica: Advanced Encryption Standard – AES-128
 y AES-256, con los modos CTR o GCM.
\end_layout

\begin_layout Itemize
Algoritmos de criptografía asimétrica: 
\lang english
Elliptic Curve Digital Signature Algorithm
\lang spanish
 – ECDSA (firmas digitales) y 
\lang english
Elliptic Curve Diffie-Hellman
\lang spanish
 – ECDH (intercambio de claves).
\end_layout

\begin_layout Itemize
Algoritmos de hash: Secure Hash Algorithm 2 – SHA-256 y SHA-384 (
\lang english
message digest
\lang spanish
).
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset space \thinspace{}
\end_inset


\lang english
Footprint
\lang spanish
 reducida, necesaria para la integración en sistemas embebidos.
\end_layout

\begin_layout Itemize
Compatible con la arquitectura ARM.
\end_layout

\begin_layout Subsubsection
Compatibilidad con el sistema objetivo
\end_layout

\begin_layout Standard
Como desarrollamos en el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Descripción-del-sistema"

\end_inset

, el sistema objetivo está basado en un procesador de la familia ARM Cortex-M4,
 en el que se ejecuta CMSIS-RTOS como sistema operativo de tiempo real y
 se usa lwIP para implementar la pila de protocolos TCP/IP y UDP/IP.
\end_layout

\begin_layout Standard
Estos aspectos deben considerarse cuidadosamente a la hora de elegir la
 biblioteca TLS a integrar.
 En esta sección trataremos los aspectos de compatibilidad con el sistema
 objetivo, así como la disponibilidad de documentación y de otros recursos.
\end_layout

\begin_layout Standard
Además de los criterios mencionados al comienzo de este capítulo, evaluaremos
 el soporte para CMSIS-RTOS y para lwIP que ofrecen estas bibliotecas, ya
 que pueden reducir dramáticamente el tiempo de desarrollo.
\end_layout

\begin_layout Standard
La 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparación-doc+compatib"

\end_inset

 muestra un resumen de la información obtenida a partir de fuentes oficiales
 de cada una de las implementaciones al respecto.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
arrayrulewidth=1.3pt
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="6">
<features islongtable="true" headBottomDL="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="2cm">
<column alignment="left" valignment="top" width="2cm">
<column alignment="left" valignment="top" width="2cm">
<column alignment="left" valignment="top" width="2cm">
<column alignment="left" valignment="top" width="2cm">
<column alignment="left" valignment="top" width="2cm">
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
arrayrulecolor{white}
\backslash
rowcolor{head}
\backslash
color{white}
\end_layout

\end_inset


\size small
Implemen-tación
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

WolfSSL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

mbedTLS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

MatrixSSL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

cryptlyb
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

SharkSSL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Disponibilidad de documentación
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Disponible de forma abierta en la web oficial.
 Exhaustiva y bien organizada.
 Numerosos recursos en línea
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Disponible de forma abierta en la web oficial.
 Exhaustiva y bien organizada.
 Numerosos recursos en línea
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Disponible de forma abierta en forma de PDF, descargable desde el repositorio
 oficial.
 Recursos en línea limitados
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Disponible de forma abierta en forma de manual PDF.
 Recursos en línea limitados
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

No disponible de forma abierta (es necesario registrarse para probar ejemplos).
 Sin recursos en línea
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Comunidad 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset


\size default
Muy activa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset


\size default
Muy activa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset


\size default
Poco activa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset


\size default
Poco activa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset


\size default
Inexistente
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Soporte para ingenieros
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Foro para Q&A.
 Soporte por e-mail.
 GitHub Issues
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Foro para Q&A.
 Soporte por e-mail.
 GitHub Issues
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Soporte por e-mail.
 GitHub Issues
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Soporte por e-mail.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Soporte por e-mail.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Disponibilidad del código fuente
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Disponible en GitHub
\begin_inset Note Note
status open

\begin_layout Plain Layout

\size small
(
\color red
73+
\color inherit
 versiones estables)
\end_layout

\end_inset

.
 Disponible el código de la última versión estable en la web oficial
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Disponible en GitHub
\begin_inset Note Note
status open

\begin_layout Plain Layout

\size small
(
\color red
99+
\color inherit
 versiones estables)
\end_layout

\end_inset

.
 Disponibles varias versiones estables en la web oficial
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Disponible en GitHub
\begin_inset Note Note
status open

\begin_layout Plain Layout

\size small
(
\color red
2+
\color inherit
 versiones estables)
\end_layout

\end_inset

.
 Disponibles 46+ versiones estables en la web oficial
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Bajo demanda, tras rellenar un formulario
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

No disponible antes de la adquisición de la licencia
\end_layout

\end_inset
</cell>
</row>
<row newpage="true">
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Presencia en las redes sociales
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Web clara, GitHub, Twitter, Facebook, Linkedin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Web clara, GitHub, Twitter, Facebook, Linkedin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Web plana, GitHub, blog
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

Web poco clara, blog
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{meh}
\end_layout

\end_inset

Web clara
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Soporte para CMSIS-RTOS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, característica incluida
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, característica incluida
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

No se mencina en la web
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, característica incluida.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

Con soporte para MDK-ARM y mbed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Soporte para lwIP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, característica incluida
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, característica incluida
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

No se mencina en la web
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{bad}
\end_layout

\end_inset

No se mencina en la web ni en la documentación
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparación-doc+compatib"

\end_inset

Comparación de las bibliotecas analizadas: disponibilidad de documentación
 y soporte y compatibilidad con el sistema objetivo.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Elección de la biblioteca
\end_layout

\begin_layout Standard
Al contemplar las tablas 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Comparación-general"

\end_inset

 y 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Comparación-doc+compatib"

\end_inset

 es evidente que WolfSSL y mbedTLS son las opciones más adecuadas.
 Por esta razón las hemos analizado más a fondo.
 La 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Comparación-WolfSSL-mbedTLS"

\end_inset

 muestra una comparación en mayor profundidad de estas dos bibliotecas.
 Como podemos comprobar, ambas tienen características muy parecidas.
 Finalmente, nos hemos decantado por mbedTLS por los motivos siguientes:
\end_layout

\begin_layout Itemize
AWS
\begin_inset space ~
\end_inset

IoT Device SDK funciona con mbedTLS de forma nativa.
 Este es un argumento de peso, ya que facilitará enormemente la integración
 del SDK de AWS
\begin_inset space ~
\end_inset

IoT.
\end_layout

\begin_layout Itemize
La licencia parece más apropiada para el proyecto.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
arrayrulewidth=1.3pt
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="4cm">
<column alignment="left" valignment="top" width="4cm">
<column alignment="left" valignment="top" width="4cm">
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
arrayrulecolor{white}
\backslash
rowcolor{head}
\backslash
color{white}
\end_layout

\end_inset


\size small
Implementación
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

WolfSSL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{white}
\end_layout

\end_inset

mbedTLS
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Compilación en MS Windows
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, con el proyecto de Visual Studio incluido
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, con el proyecto de Visual Studio incluido y con la IDE Eclipse
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Compilación en GNU/Linux
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, usando Make
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, usando Make y CMake
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Configuración de la biblioteca
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, en la forma de un fichero de configuración que modifica el comportamiento
 de Make
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, modificando el fichero config.h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Soporte para otros sistemas operativos de tiempo real (RTOS)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, incluyendo Linux embebido, FreeRTOS, TinyOS y 
\begin_inset Formula $\mu$
\end_inset

C/OS.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, incluyendo FreeRTOS, SEGGER, embedOS y eCOS.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Tests funcionales y comprobaciones de integridad
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, conjunto de tests incluido
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí, conjunto de tests incluido
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Compatible con OpenSSL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{head}
\backslash
color{white}
\end_layout

\end_inset

Disponibilidad de una versión con funcionalidades mínimas
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cellcolor{good}
\end_layout

\end_inset

Sí
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Comparación-WolfSSL-mbedTLS"

\end_inset

Comparación de WolfSSL y mbedTLS: características de compilación y configuración
 de la biblioteca
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Having a look at the tables above, it is evident that WolfSSL and mbed TLS
 are the most suitable options.
 For this reason, they have been further analyzed.
 A closer comparison is presented below.
 
\end_layout

\begin_layout Plain Layout
A series of different TLS implementations have been analyzed and compared.
 Both open source and privative implementations have been considered.
 Among all the compared alternatives, WolfSSL and mbed TLS appear to be
 the most developed ones.
 They also have the strongest communities, widest presence in social networks,
 largest documentation and biggest development rate.
 For these reasons, WolfSSL and mbed TLS are concluded to better fit target
 system’s requirements.
 Checking the available information on WolfSSL and mbed TLS websites does
 not bring to a clear close.
 Actually, both libraries seem to have much the same features.
 Maybe diving into the code and performing some compilation tests would
 be convenient to end up with a definitive conclusion.
 
\end_layout

\begin_layout Plain Layout
Tras valorar estas opciones, decidimos mbedTLS por los siguientes motivos:
 
\end_layout

\begin_layout Itemize
AWS IoT Device SDK funciona con mbedTLS de forma nativa
\end_layout

\begin_layout Itemize
#
\end_layout

\begin_layout Itemize
#
\end_layout

\begin_layout Itemize
#
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con esta elección ponemos fin a este capítulo, en el que hemos analizado
 y comparado una serie de implementaciones TLS, tanto de código abierto
 como privativas.
 Destacaremos que de entre las alternativas comparadas, WolfSSL y mbedTLS
 parecen ser las más desarrolladas, tanto desde el punto de vista tecnológico
 como por la disponibilidad de documentación, presencia en las redes sociales
 y comunidad.
 Tras revisar la información disponible en los sitios web de WolfSSL y mbedTLS,
 resultan tener características muy similares.
 El principal motivo de la elección de mbedTLS ha sido su excelente compatibilid
ad con AWS
\begin_inset space ~
\end_inset

IoT Device SDK, puesto que este último la integra por defecto.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementación-TLS"

\end_inset

Integración de mbedTLS
\end_layout

\begin_layout Standard
Tras elegir la implementación TLS que integraremos en el sistema, hemos
 llevado a cabo una evaluación en profundidad de la misma.
 Esta se ha basado principalmente en la documentación oficial de mbedTLS,
 disponible en su página web 
\begin_inset CommandInset citation
LatexCommand cite
key "mbedTLS-knowledge-base"

\end_inset

.
 También hemos estudiado su código fuente y su documentación para aclarar
 algunos detalles 
\begin_inset CommandInset citation
LatexCommand cite
key "mbedTLS-API-reference"

\end_inset

.
\end_layout

\begin_layout Standard
Dedicaremos este capítulo a la integración de mbedTLS en el XMC4500 presente
 en el miniGW.
 Presentaremos aquí algunos detalles de la biblioteca, que serán de interés
 para integrarla al sistema.
 A continuación, discutiremos los detalles de esta integración, recorriendo
 cada uno de los elementos portados.
\end_layout

\begin_layout Section
Detalles de la biblioteca
\end_layout

\begin_layout Standard
mbedTLS ofrece APIs tanto para la parte del cliente como para la del servidor,
 con soporte para todos los estándares SSL y TLS actuales.
 Además, la biblioteca incluye un amplio rango de algoritmos criptográficos.
 Así mismo, incluye una variedad de métodos de intercambio de claves, algoritmos
 de cifrado simétrico, algoritmos de hash, diversas curvas elípticas y herramien
tas para la generación de números aleatorios 
\begin_inset CommandInset citation
LatexCommand cite
key "mbedTLS-core-features"

\end_inset

.
 Además, mbedTLS dispone de todos los algoritmos criptográficos definidos
 en la 
\emph on
Suite
\begin_inset space ~
\end_inset

B
\emph default
 de la NSA 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc6379-NSA-Suite-B"

\end_inset

.
\end_layout

\begin_layout Subsection
Estructura de ficheros
\end_layout

\begin_layout Standard
El código fuente de la biblioteca está estructurado de la forma que se presenta
 a continuación.
\end_layout

\begin_layout Description

\family typewriter
/
\family default
 en el directorio raíz se encuentran los ficheros que podemos encontrar
 en la mayoría de los proyectos, como 
\family typewriter
Makefile
\family default
, 
\family typewriter
README
\family default
, 
\family typewriter
LICENSE
\family default
, etc.
\end_layout

\begin_deeper
\begin_layout Description

\family typewriter
configs
\family default
 en este directorio podemos encontrar diversos ejmplos de ficheros de configurac
ión.
\end_layout

\begin_layout Description

\family typewriter
doxygen
\family default
 ficheros de entrada para la documentación generada con Doxygen.
\end_layout

\begin_layout Description

\family typewriter
include
\family default
 ficheros de cabecera (
\family typewriter
.h
\family default
).
\end_layout

\begin_layout Description

\family typewriter
library
\family default
 en este directorio se encuentran los ficheros 
\family typewriter
.c
\family default
 de la biblioteca, que contienen el código fuente de los distintos módulos
 y funciones de la misma.
\end_layout

\begin_layout Description

\family typewriter
programs
\family default
 programas de ejemplo, que demuestran las distintas características de mbedTLS.
\end_layout

\begin_layout Description

\family typewriter
scripts
\family default
 scripts útiles para configurar mbedTLS y medir su rendimiento.
\end_layout

\begin_layout Description

\family typewriter
tests
\family default
 programas y scripts de test.
\end_layout

\begin_layout Description

\family typewriter
visualc
\family default
 proyecto de Microsoft
\begin_inset space ~
\end_inset

Visual
\begin_inset space ~
\end_inset

Studio, usado para compilar mbedTLS en entornos MS
\begin_inset space ~
\end_inset

Windows.
\end_layout

\begin_layout Description

\family typewriter
yotta
\family default
 ficheros usados por Yotta para compilar mbedTLS como un módulo ARM
\begin_inset space ~
\end_inset

mbed.
\end_layout

\end_deeper
\begin_layout Subsection
Opciones de configuración
\end_layout

\begin_layout Standard
Dado que muy pocos sistemas requieren de todos los algoritmos criptográficos
 disponibles, mbedTLS permite habilitarlos o deshabilitarlos en tiempo de
 compilación.
 De este modo, tanto el tamaño del ejecutable como la memoria requerida
 en tiempo de ejecución son minimizados, atendiendo únicamente a las necesidades
 de la aplicación.
 Para facilitar el proceso de configuración a los desarrolladores, la biblioteca
 incluye un fichero de configuración con todas las opciones disponibles.
 Este fichero de configuración es, en realidad, un archivo de cabecera en
 lenguaje
\begin_inset space ~
\end_inset

C, que contiene una lista exhaustiva de definiciones con su correspondiente
 documentación.
 De esta forma, el desarrollador puede activar o desactivar cualquiera de
 las opciones.
 El fichero de configuración es referenciado por cada uno de los otros ficheros
 de cabecera, consiguiendo que la configuración se haga efectiva en tiempo
 de compilación 
\begin_inset CommandInset citation
LatexCommand cite
key "mbedTLS-config_h"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Las opciones son comprobadas para ver si son compatibles (por ejemplo, no
 se puede hacer un intercambio de claves basado en clave pública si no hay
 habilitadas claves públicas)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las opciones de configuración pueden ser divididas en cuatro grupos:
\end_layout

\begin_layout Description
Soporte
\begin_inset space ~
\end_inset

del
\begin_inset space ~
\end_inset

sistema estas opciones deben seleccionarse de forma acorde a la plataforma
 sobre la que se ejecutará mbedTLS.
\end_layout

\begin_layout Description
Soporte
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

características
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

seguridad estas opciones permiten elegir las características que son necesarias
 de cada módulo habilitado.
 De esta forma, pueden seleccionarse qué modos de cifrado estarán disponibles,
 qué curvas elípticas, qué algoritmos de intercambio de claves, etc.
 Se trata de opciones con una alta granularidad.
\end_layout

\begin_layout Description
Módulos
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

mbedTLS estas opciones permiten habilitar o deshabilitar los módulos de
 mbedTLS de forma completa.
 Por ejemplo, podríamos deshabilitar completamente RSA o MD5 si no son necesario
s
\end_layout

\begin_layout Description
Opciones
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

configuración
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

los
\begin_inset space ~
\end_inset

módulos estas opciones permiten ajustas opciones específicas para cada módulo,
 como el tamaño máximo de los números enteros, el tamaño de los búferes
 internos de SSL, etc.
\end_layout

\begin_layout Standard
Todas estas opciones pueden modificarse de forma manual o usando un script
 en Perl proporcionado con la biblioteca 
\begin_inset CommandInset citation
LatexCommand cite
key "mbedTLS-how-do-i-configure,mbedTLS-reduce-footprint"

\end_inset

.
\end_layout

\begin_layout Subsection
Opciones de compilación
\end_layout

\begin_layout Standard
Con el fin ejecutar mbedTLS en la plataforma objetivo, tendremos que compilarlo
 con las opciones apropiadas, usando el conjunto de herramientas de compilación
 y enlazado necesarias.
 Tenemos cuatro formas de compilar la biblioteca 
\begin_inset CommandInset citation
LatexCommand cite
key "mbedTLS-how-do-I-build-compile"

\end_inset

.
\end_layout

\begin_layout Description
Makefile a pesar de ser el método de compilación por defecto en sistemas
 Unix-like, no es recomendada, ya que dejó de ser mantenida por el equipo
 de desarrollo de mbedTLS.
\end_layout

\begin_layout Description
CMake este método permite generar un fichero Makefile bien estructurado
 y de forma automática, detectando las dependencias y las opciones de compilació
n.
 Además, crea una estructura de directorios con la que se consigue que los
 ficheros objeto no se mezclen con el código fuente.
 Este es el método recomendado por el equipo de mbedTLS.
\end_layout

\begin_layout Description
Yotta esta herramienta, creada en el marco del proyecto mbed de ARM, pretende
 ayudar a los desarrolladores que incluyen distintos módulos de mbed en
 sus proyectos.
 Está basada en CMake, pero cuenta con el concepto de módulos, de forma
 que resulta sencillo compilar distintos módulos que vayan a usarse en mbedOS.
\end_layout

\begin_layout Description
MS
\begin_inset space ~
\end_inset

Visual
\begin_inset space ~
\end_inset

Studio el equipo de mbedTLS proporciona un fichero de proyecto de Microsoft
 Visual Studio con el objetivo de que los desarrolladores que usen esta
 IDE puedan compilar la biblioteca sin preocuparse demasiado por el proceo
 de compilación.
\end_layout

\begin_layout Standard
Aunque estos son los procedimientos de compilación provistos con la biblioteca,
 existen más opciones.
 Por ejemplo, podemos incluir el código fuente en un proyecto de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 y dejar que este lo compile de forma automática.
 Esto es posible gracias a que 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 genera los ficheros objeto para cada fichero 
\family typewriter
.c
\family default
, buscando las cabeceras en los directorios que se le indique.
 De esta forma, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 comprobará si hemos realizado algún cambio en los ficheros de mbedTLS antes
 de cada compilación, por lo que no tendremos que compilar la biblioteca
 y el proyecto por separado.
 Esta opción es muy flexible, y será la que usaremos en este proyecto.
\begin_inset Note Note
status open

\begin_layout Plain Layout
, puede ser más lenta.
 Por eso, hemos preferido compilar la biblioteca en un fichero archivador
 (
\family typewriter
.a
\family default
), que será el que incluimos en el proyecto junto con los ficheros de cabecera
 (
\family typewriter
.h
\family default
).
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Portabilidad-mbedTLS"

\end_inset

Portabilidad a otras plataformas
\end_layout

\begin_layout Standard
mbedTLS está programado en código
\begin_inset space ~
\end_inset

C estándar, por lo que es fácilmente portable.
 Además, el código de esta biblioteca es muy modular, siendo los siguientes
 los únicos módulos que presentan dependencias de la plataforma 
\begin_inset CommandInset citation
LatexCommand cite
key "mbedTLS-how-do-I-port"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
en el directorio library, cada fichero .c contiene una serie de defines con
 los que se selecciona la plataforma (#if #else).
 Para añadir la nueva plataforma, deberán modificarse estos ficheros y añadir
 las líneas pertinentes.
\end_layout

\end_inset


\end_layout

\begin_layout Description
Módulo
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

red
\begin_inset space ~
\end_inset

(
\lang english
Networking
\lang spanish
)
\begin_inset space ~
\end_inset

[requerido] las funciones de red están implementadas usando la API de sockets
 BSD.
 Gracias es esto, el módulo de red incluido con la biblioteca es compatible
 tanto con sistemas Unix como con MS
\begin_inset space ~
\end_inset

Windows.
 A fin de que mbedTLS pueda establecer comunicaciones de red en un sistema
 empotrado, será necesario compilarlo junto a una biblioteca que proporcione
 una interfaz de sockets BSD.
 
\end_layout

\begin_layout Description
Módulo
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

temporización
\begin_inset space ~
\end_inset

(
\lang english
Timing
\lang spanish
) este módulo es requerido únicamente cuando nuestro sistema establezca
 comunicaciones a través del protocolo DTLS.
 De lo contrario, podemos deshabilitarlo de forma segura.
\end_layout

\begin_layout Description
Fuentes
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

entropía
\begin_inset space ~
\end_inset

por
\begin_inset space ~
\end_inset

defecto
\begin_inset space ~
\end_inset

(
\lang english
Default
\begin_inset space ~
\end_inset

entropy
\begin_inset space ~
\end_inset

sources
\lang spanish
)
\begin_inset space ~
\end_inset

[requerido] el pool de entropía (
\lang english
entropy pool
\lang spanish
) se encarga de acumular y combinar la entropía de distintas fuentes de
 una forma segura.
 Estas fuentes pueden estar basadas en software o en hardware, y deben proporcio
nársele al módulo de generación de números aleatorios.
 Aunque las funciones de entropía pueden ser desactivadas sin afectar a
 ningún otro módulo, la generación de números aleatorios es esencial para
 muchas des las funciones criptográficas, por lo que tendremos que asegurarnos
 una buena fuente de entropía para hacer que nuestro sistema sea seguro.
\end_layout

\begin_layout Description
Aceleración
\begin_inset space ~
\end_inset

Hardware
\begin_inset space ~
\end_inset

(
\lang english
Hardware
\begin_inset space ~
\end_inset

Acceleration
\lang spanish
) muchos de los módulos que implementan primitivas criptográficas pueden
 ser sustituidos por implementaciones alternativas de las mismas.
 De esta forma, la es posible aprovechar implementaciones hardware que pudieran
 estar presentes en la plataforma.
\end_layout

\begin_layout Description
Acceso
\begin_inset space ~
\end_inset

al
\begin_inset space ~
\end_inset

sistema
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

ficheros
\begin_inset space ~
\end_inset

(
\lang english
Filesystem
\begin_inset space ~
\end_inset

access
\lang spanish
) todas las funciones que acceden al sistema de ficheros están implementadas
 de forma que, en realidad, simplemente se lee un búfer de memoria.
 De este modo, solo es necesario portar las funciones que cargan/guardan
 el contenido de estos búferes del/al sistema de ficheros.
 Gracias a esta implementación, los desarrolladores pueden elegir si prefieren
 leer los datos del disco o incrustarlos 
\begin_inset Quotes fld
\end_inset

a fuego
\begin_inset Quotes frd
\end_inset

 en el código fuente (
\lang english
hard-coded
\lang spanish
).
\end_layout

\begin_layout Description
Reloj
\begin_inset space ~
\end_inset

en
\begin_inset space ~
\end_inset

tiempo
\begin_inset space ~
\end_inset

real
\begin_inset space ~
\end_inset

(
\lang english
Real-Time
\begin_inset space ~
\end_inset

Clock
\lang spanish
) algunos módulos acceden de forma opcional a la hora y fecha actuales,
 bien para medir intervalos de tiempo, bien para conocer la fecha y hora
 actuales.
 Este módulo solo es imprescindible a la hora de validar la vigencia o caducidad
 de los certificados X.509.
\end_layout

\begin_layout Subsection
Programas de ejemplo
\end_layout

\begin_layout Standard
mbedTLS incluye numerosos programas de ejemplo, con los que pueden probarse
 las distintas características de la biblioteca.
 Por su relevancia en este proyecto, haremos referencia a dos de ellos.
 Estos programas han sido cuidadosamente estudiados, usando parte de su
 código en algunos pasos de la integración.
\end_layout

\begin_layout Subsubsection
Certificate Authorities 
\end_layout

\begin_layout Standard

\family typewriter
programs/x509/cert_app.c
\family default
 demuestra el uso de certificados X.509 en mbedTLS.
 Como se demuestra en este programa, las autoridades certificadoras pueden
 cargarse a partir del sistema de ficheros haciendo uso de las funciones
 
\family typewriter
mbedtls_x509_crt_parse_file()
\family default
 y 
\family typewriter
mbedtls_x509_crt_parse_path()
\family default
.
 Estas funciones no son más que una envoltura (
\lang english
wrapper
\lang spanish
) de la función 
\family typewriter
mbedtls_x509_crt_parse()
\family default
, la cuál analiza el contenido de un búfer para obtener los distintos campos
 que conforman el certificado, guardándolos en una estructura definida en
 la biblioteca.
\end_layout

\begin_layout Subsubsection
Connection sockets 
\end_layout

\begin_layout Standard

\family typewriter
programs/ssl/ssl_client1.c
\family default
 demuestra el uso de sockets a la hora de realizar una conexión TLS desde
 el lado del cliente.
 Los siguientes pasos deben seguirse para establecer la conexión.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Inicializar el contexto TCP mediante la función 
\family typewriter
mbedtls_net_connect()
\family default
.
 En este paso deben especificarse la dirección del servidor (IP o DNS),
 el puerto y el protocolo.
\end_layout

\begin_layout Enumerate
Configurar el contexto TLS con 
\family typewriter
mbedtls_ssl_config_defaults()
\family default
.
 En este paso deben definirse algunos parámetros de configuración de TLS,
 como la versión o las ciphersuites.
\end_layout

\begin_layout Enumerate
Iniciar la conexión segura con 
\family typewriter
mbedtls_ssl_set_bio()
\family default
 y 
\family typewriter
mbedtls_ssl_handshake()
\family default
.
 Si todo va bien, después de este paso el handshake habrá concluido con
 éxito, por lo que podremos pasar a transmitir datos de forma segura.
\end_layout

\begin_layout Enumerate
Recibir y enviar datos de forma segura con 
\family typewriter
mbedtls_ssl_read()
\family default
 y 
\family typewriter
mbedtls_ssl_write()
\family default
.
\end_layout

\begin_layout Enumerate
Para finalizar, debe cerrarse la conexión con 
\family typewriter
mbedtls_ssl_close_notify()
\family default
.
 No debemos olvidarnos de liberar la memoria dinámica que hayamos reservado
 en los pasos anteriores.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:mbedTLS-test-programs"

\end_inset

Comprobaciones de integridad
\end_layout

\begin_layout Standard
mbedTLS incluye programas de test, con los que puede verificarse el correcto
 funcionamiento de cada uno de los módulos de la biblioteca.
 Al ejecutarse, estos programas llaman a las funciones de los distintos
 módulos con parámetros conocidos y comprueban que el resultado obtenido
 sea el esperado, verificando de esta forma si los módulos trabajan de manera
 adecuada.
 Si se detecta algún error en los módulos examinados, el programa de test
 informará al usuario de la existencia del problema.
 Los tests que verifican la funcionalidad de un módulo concreto solo se
 ejecutarán si mbedTLS fue configurado para usar este módulo, es decir,
 si la biblioteca fue compilada con el módulo en cuestión.
\end_layout

\begin_layout Standard
Además de estos programas de test, mbedTLS incluye numerosos scripts que
 realizan pruebas automatizadas (
\lang english
automated testing
\lang spanish
).
 Estos scripts no se limitan a la comprobación de los distintos módulos
 de la biblioteca, sino que son capaces de verificar el proceso de compilación,
 realizar pruebas de interoperabilidad con OpenSSL y GnuTLS, etc.
 Estos scripts proporcionan un banco de pruebas muy completo, con más de
 6000 tests 
\begin_inset CommandInset citation
LatexCommand cite
key "mbedTLS-tests-guidelines,mbedTLS-tests-scripts"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
, y solo requieren de las herramientas de compilación Make y del intérprete
 Perl .
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Añadir ejemplos de los tests! Se ha usado uno de estos test en el microcontrolad
or para comprobar que todo funcionaba, no?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Integración de mbedTLS en el miniGW
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Portar a XMC con CMSIS-RTOS, vamos
\end_layout

\begin_layout Plain Layout
Hablar del montaje en el laboratorio (PC como bridge, switch, intranet,
 Internet)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para llevar a cabo la integracion de mbedTLS en el miniGW, partiremos de
 un proyecto inicial en el que están presentes CMSIS-RTOS y lwIP.
 Este proyecto de partida no realiza ninguna función en especial, pero tiene
 una pila IP funcional, gracias a la cuál pueden establecerse conexiones
 TCP con gran facilidad.
 Además, lwIP responde a los 
\lang english
pings
\lang spanish
 de ICMP por defecto, lo cuál es muy útil para comprobar la conectividad.
\end_layout

\begin_layout Subsection
Importación de mbedTLS al proyecto
\end_layout

\begin_layout Standard
Para integrar cualquier biblioteca, lo primero que tendremos que hacer es
 importarla al proyecto.
 De esta forma, el IDE la compilará automáticamente con el resto del código,
 pudiéndose referenciar los objetos de la misma desde cualquier lugar.
 Existen dos formas principales de importar la biblioteca al proyecto.
 La primera de ellas consiste en copiar los ficheros de la biblioteca al
 directorio del proyecto.
 De esta forma, todo el código fuente, tanto el del programa usuario como
 el de la biblioteca, se encontrará bajo el mismo directorio, siendo accesible
 al proceso de compilación.
 Sin embargo, esta aproximación presenta algunos inconvenientes, sobre todo
 cuando se trata de usar una misma biblioteca que está sujeta a cambios
 en distintos proyectos.
 En este caso, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 nos ofrece una alternativa, que hereda de Eclipse
\begin_inset space ~
\end_inset

IDE.
 La alternativa consiste en 
\emph on
enlazar
\emph default
 la biblioteca al proyecto, de forma que en el mismo se almacena únicamente
 una referencia a la biblioteca.
 De esta forma, cualquier cambio que realicemos a la biblioteca dentro del
 proyecto quedará guardado en la misma.
 Este flujo de trabajo es especialmente conveniente cuando la biblioteca
 se tiene bajo control de versiones, en un repositorio distinto al del proyecto
 y que es compartido por todo el equipo
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Git submodules es otra forma de resolver este problema.
 Sin embargo, el flujo de trabajo de eesy-innovation no contempla el uso
 de submódulos.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
solo se debe importar include y library.
 El resto, si se incluye en el proyecto, debe marcarse para la no compilación.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una vez que el código fuente de la biblioteca está accesible y puede compilarse
 en conjunto con el resto del proyecto, será necesario ajustar algunos parámetro
s de la compilación.
 En concreto, será necesario añadir algunos símbolos y rutas, que en 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

, al igual que en Eclipse
\begin_inset space ~
\end_inset

IDE, puede hacerse de forma gráfica accediendo a las propiedades de compilación
 del proyecto.
 En el caso que nos ocupa, definiremos un símbolo 
\family typewriter
DAVE
\family default
, sin ningún valor específico, para usarlo como indicador de la plataforma
 cuando modifiquemos el código fuente de la biblioteca al portarla.
 Esto en GCC se consigue con el flag '
\family typewriter
-D
\family default
'.
 También tendremos que indicar al compilador que busque archivos de cabecera
 contenidos en 
\family typewriter
mbedtls/include
\family default
 añadiendo esta ruta con el flag '
\family typewriter
-I
\family default
'.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
herramienta 
\begin_inset Quotes fld
\end_inset

bibliotecas con referencias
\begin_inset Quotes frd
\end_inset

 de DAVE: Nos permite tener la biblioteca en una localización diferente
 a la del proyecto, haciéndose fácil su importación.
 Configuración de Símbolos?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Adaptación de la biblioteca a la plataforma
\end_layout

\begin_layout Standard
Una vez importado el código de la biblioteca y establecidos los parámetros
 de compilación, pasaremos a realizar los cambios necesarios en la biblioteca
 para que esta pueda compilarse y ser funcional en la nueva plataforma.
 Puesto que mbedTLS selecciona la plataforma a través de directivas condicionale
s del preprocesador de
\begin_inset space ~
\end_inset

C (es decir, a través de directivas 
\family typewriter
#if
\family default
 
\family typewriter
#else
\family default
), tendremos que modificar cada uno de los ficheros dependientes de la plataform
a.
 Como explicamos en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Portabilidad-mbedTLS"

\end_inset

, los módulos dependientes de la plataforma 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
y que deben ser portados 
\end_layout

\end_inset

son el módulo de red y la fuente de entropía.
 A continuación describiremos los cambios realizados en cada uno de estos
 módulos.
\end_layout

\begin_layout Subsubsection
Módulo de red
\end_layout

\begin_layout Standard
Con respecto a las capacidades de red, mbedTLS se basa en los sockets BSD
 estándar, que es la interfaz de red predeterminada en muchos sistemas tipo
 Unix, así como lo es en MS
\begin_inset space ~
\end_inset

Windows.
 Las versiones recientes de lwIP proporcionan esta interfaz de sockets estándar,
 por lo podremos usar esta biblioteca como la pila de red del sistema.
\end_layout

\begin_layout Standard
Volviendo a mbedTLS, hemos modificado el fichero 
\family typewriter
net_sockets.c
\family default
, que es una capa de abstracción donde se interconecta mbedTLS con los sockets
 tipo BSD.
 Esta es la lista de cambios que hemos realizado en el fichero:
\end_layout

\begin_layout Itemize
Permitir compilar este archivo para un entorno distinto a Unix y MS
\begin_inset space ~
\end_inset

Windows, incluyendo directivas 
\family typewriter
#if
\family default
 al comienzo del fichero.
\end_layout

\begin_layout Itemize
Uso de lwIP como la pila de red, incluyendo los ficheros de cabecera al
 comienzo de 
\family typewriter
net_sockets.c
\family default
, bajo la condicional 
\family typewriter
#ifdef DAVE
\family default
, donde 
\family typewriter
DAVE
\family default
 es el símbolo definido anteriormente.
\end_layout

\begin_layout Itemize
Deshabilitar IPv6 cuando esté definido el símbolo 
\family typewriter
DAVE
\family default
, ya que esta versión del protocolo no está soportado por lwIP en la fecha
 de realizar esta integración.
\end_layout

\begin_layout Itemize
Uso de la implementación de la función 
\family typewriter
fcntl()
\family default
 provista por la biblioteca 
\lang english
newlib
\lang spanish
, incluida en el kit de herramientas de compilación 
\emph on
arm-none-eabi
\emph default
 de 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Fuentes de entropía
\end_layout

\begin_layout Standard
Una buena entropía es la base fundamental para una criptografía robusta.
 Esta entropía puede obtenerse de diversas maneras.
 Los módulos de hardware que proporcionan entropía, como los módulos de
 generación de números (pseudo-)aleatorios (
\lang english
pseudo-random number generator
\lang spanish
, PRNG) están presentes en muchos microcontroladores.
 El microcontrolador XMC4500 incluye uno de estos módulos PRNG como parte
 de los generadores de señal del módulo DAC.
 Utilizaremos este módulo como fuente principal de entropía en este proyecto.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/XMC4500-PRNG-block-diagram.eps
	width 60col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:XMC-PRNG-block-diagram"

\end_inset

Diagrama de bloques del PRNG disponible en el XMC4500 
\begin_inset CommandInset citation
LatexCommand cite
key "infineon:XMC4500-reference"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
El PRNG presente en el XMC4500, cuyo diagrama de bloque puede consultarse
 en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:XMC-PRNG-block-diagram"

\end_inset

 genera números pseudoaleatorios de 12 bits.
 Para ello, utiliza un registro de desplazamiento de realimentación lineal
 (
\lang english
linear-feedback shift register
\lang spanish
, LFSR) de 20 bits que funciona a la frecuencia de reloj del sistema.
 Al recibir una señal de 
\emph on
trigger
\emph default
, el valor presente en el LFSR se copia al registro de salida, permaneciendo
 en este para su lectura por otro módulo.
 Cada vez que se reinicia el PRNG, el LFSR vuelve a su valor inicial y,
 por lo tanto, siempre se repite la misma secuencia de números pseudoaleatorios
 
\begin_inset CommandInset citation
LatexCommand cite
key "infineon:XMC4500-reference"

\end_inset

.
 A pesar de esto, hay tres factores que deberían garantizar una buena entropía
 en la implementación.
\end_layout

\begin_layout Enumerate
Existen muchos factores que hacen que el sistema no sea determinista, por
 lo que el momento en que se leen los números aleatorios es cada vez distinto.
 Entre estos factores podemos contar con el propio RTOS, que no garantiza
 que las tareas se ejecuten siempre en el mismo orden, o el hecho de que
 los tiempos de transmisión en la red sean cada vez distintos.
\end_layout

\begin_layout Enumerate
El PRNG forma parte del módulo DAC del microcontrolador, por lo que será
 necesario transformar la señal analógica generada a un número digital,
 a través de un ADC.
 Esta lectura está sujeta a pequeñas variaciones, pues la señal analógica
 generada se verá afectada por distintos ruidos, siempre presentes en los
 circuitos electrónicos 
\begin_inset CommandInset citation
LatexCommand cite
key "design-of-digital-integrated-circuits"

\end_inset

.
 Además, usaremos una frecuencia relativamente alta en la generación de
 números aleatorios, de forma que el ADC no llegue a estabilizarse en la
 lectura y siempre cometa un error 
\begin_inset CommandInset citation
LatexCommand cite
key "SedraSmith"

\end_inset

.
\end_layout

\begin_layout Enumerate
mbedTLS toma estos números aleatorios como una fuente de entropía, para
 luego combinarla con otras fuentes en el recolector de entropía.
 Esto se hace con la finalidad de asegurar una generación de números lo
 más aleatorios posibles 
\begin_inset CommandInset citation
LatexCommand cite
key "mbedTLS-add-entropy"

\end_inset

.
\end_layout

\begin_layout Standard
El uso del PRNG en el proyecto se ha llevado a cabo mediante el uso de diversas
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE APPs
\end_layout

\end_inset

, con las que hemos configurado uno de los módulos DAC para la generación
 de ruido y uno de los ADC para leer la señal generada.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para integrar esta fuente de entropía en mbedTLS hemos modificado el fichero
 
\family typewriter
entropy_poll.c
\family default
, que contiene las funciones de entropía definidas por el usuario para cada
 plataforma.
 En este fichero, hemos añadido una sección específica para la plataforma
 
\family typewriter
DAVE
\family default
.
 En esta sección, simplemente hemos completado la función 
\family typewriter
mbedtls_hardware_poll()
\family default
 para que lea números aleatorios a partir del ADC.
 Esto último se consigue haciendo uso de las APIs correspondientes de la
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE APP
\end_layout

\end_inset

 del ADC.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Módulo de temporización
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aunque este módulo no es un requisito para el funcionamiento de la biblioteca,
 será necesario a la hora de verificar la validez del certificado de los
 servidores de AWS.
 Para integrar el RTC con mbedTLS, hemos creados los fichero 
\family typewriter
platform_DAVE.c
\family default
 y 
\family typewriter
platform_DAVE.h
\family default
, referenciándolos luego en 
\family typewriter
main.c
\family default
.
 Más concretamente, en la secuencia de inicialización llamamos a la función
 
\family typewriter
mbedtls_platform_set_time()
\family default
, pasándole como parámetro la función 
\family typewriter
mbedtls_time_DAVE()
\family default
 definida en 
\family typewriter
platform_DAVE.c
\family default
.
 Esta última función realiza una lectura del RTC del microcontrolador a
 través de la API definida en una 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE APP
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La fecha y hora del RTC serán ajustadas gracias a un cliente NTP sencillo,
 que actualizará la hora periódicamente basándose en una lista de servidores.
 El código fuente de este cliente ha sido proporcionado por el equipo de
 desarrollo de eesy-innovation.
\end_layout

\begin_layout Subsection
Configuración de mbedTLS
\end_layout

\begin_layout Standard
Una vez integrados los diferentes módulos con la plataforma, será necesario
 configurar mbedTLS para que pueda compilar.
 La configuración de mbedTLS se lleva a cabo modificando el fichero 
\family typewriter
config.h
\family default
.
 La biblioteca incluye varios de estos ficheros para ejemplificar algunas
 configuraciones comunes.
 Para llevar a cabo la configuración necesaria, hemos partido del fichero
 
\family typewriter
config-suite-b.h
\family default
, que presenta una configuración mínima para la Suite
\begin_inset space ~
\end_inset

B definida por la NSA.
 Esta configuración trata de minimizar el uso de RAM y emplea únicamente
 criptografía de curva elíptica (ECC) como algoritmos de clave pública,
 satisfaciendo los requisitos de AWS
\begin_inset space ~
\end_inset

IoT en cuanto a la ciphersuite.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Se ha usado una configuración mínima, a la que se han ido añadiendo característi
cas, para comprobar que los distintos elementos se han integrado correctamente
 en la plataforma.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Destacamos la adición de los siguientes símbolos en nuestra configuración
 
\begin_inset CommandInset citation
LatexCommand cite
key "mbedTLS-config_h"

\end_inset

:
\end_layout

\begin_layout Description

\family typewriter
MBEDTLS_SELF_TEST
\family default
 habilita las funciones de test, para poder verificar la integridad de la
 biblioteca.
\end_layout

\begin_layout Description

\family typewriter
MBEDTLS_PLATFORM_C
\family default
 habilita la capa de abstracción de plataforma que permite reasignar funciones
 como 
\family typewriter
calloc()
\family default
, 
\family typewriter
printf()
\family default
, etc.
 Es necesaria para reasignar las funciones de lectura del RTC.
\end_layout

\begin_layout Description

\family typewriter
MBEDTLS_HAVE_TIME_DATE
\family default
 habilita la verificación de la validez de los certificados digitales basada
 en la fecha y hora.
 Requiere la integración del RTC.
\end_layout

\begin_layout Description

\family typewriter
MBEDTLS_PLATFORM_TIME_ALT
\family default
 permite que mbedTLS soporte funciones alternativas en el módulo de temporizació
n, que estarán definidas en la capa de abstracción de la plataforma.
\end_layout

\begin_layout Description

\family typewriter
MBEDTLS_NO_PLATFORM_ENTROPY
\family default
 evita que mbedTLS use las funciones de entropía definidas por defecto,
 y que requieren de sistemas tipo Unix o MS
\begin_inset space ~
\end_inset

Windows.
\end_layout

\begin_layout Description

\family typewriter
MBEDTLS_ENTROPY_HARDWARE_ALT
\family default
 permite que mbedTLS use una implementación propia de un recolector de entropía
 hardware.
\end_layout

\begin_layout Standard
Además de estos nuevos símbolos, el fichero de configuración incluye opciones
 para reducir el uso de memoria de mbedTLS.
 El uso de algunas de estas opciones requiere conocer cuáles son los requisitos
 específicos de la comunicación con el servidor, ya que la reducción del
 uso de memoria consiste, en muchos casos, en limitar los 
\lang english
ciphersuites
\lang spanish
 disponibles y el tamaño de las operaciones.
 A continuación destacamos alguna de estas opciones 
\begin_inset CommandInset citation
LatexCommand cite
key "mbedTLS-reduce-footprint"

\end_inset

:
\end_layout

\begin_layout Description

\family typewriter
MBEDTLS_AES_ROM_TABLES
\family default
 almacena las tablas AES en la ROM, evitando consumo de RAM.
\end_layout

\begin_layout Description

\family typewriter
MBEDTLS_ECP_MAX_BITS
\family default
 limita el tamaño máximo reservado para las curvas elípticas.
 
\end_layout

\begin_layout Description

\family typewriter
MBEDTLS_MPI_MAX_SIZE
\family default
 limita el tamaño máximo de los enteros de precisión múltiple (
\lang english
multiple-precision integers
\lang spanish
, MPI).
 El uso de esta opción requiere conocer cuáles son los requisitos de la
 comunicación.
\end_layout

\begin_layout Description

\family typewriter
MBEDTLS_SSL_CIPHERSUITES
\family default
 permite definir las 
\lang english
ciphersuites
\lang spanish
 que serán requeridas.
 Solo estas estarán disponibles en tiempo de ejecución, evitando que mbedTLS
 incluya código de otras en su compilación y reduciendo por tanto el tamaño
 del programa.
\end_layout

\begin_layout Standard
Con esta configuración, hemos podido compilar el código de la biblioteca
 y llamar a sus funciones desde las distintas tareas del RTOS.
 En la siguiente sección hablamos de la verificación de la integración llevada
 a cabo.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Ciphersuites - configurados en config.h de mbedTLS para tener una versión
 mínima que compile y se ejecute.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
enseñar config? hablar de la configuración mínima?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Verificación de la integración
\end_layout

\begin_layout Standard
Llegados a este punto tenemos una integración de mbedTLS que compila en
 el sistema, y cuyas funciones pueden ser usadas desde las distintas tareas,
 siempre y cuando se incluyan los archivos de cabecera al inicio del código
 fuente de la tarea.
 A continuación comprobaremos que la biblioteca se comporta de la manera
 esperada, y que sus funciones producen una respuesta adecuada.
 Para ello, usaremos los programas de test de los que hablamos en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:mbedTLS-test-programs"

\end_inset

.
 Una vez que llevemos a cabo este proceso de auto-verificación, pasaremos
 a realizar un test funcional, que consistirá en descargar una web a través
 de HTTPS.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Mencionar que estos dos tests han sido, en realidad, dos versiones del firmware:
 dos proyectos distintos, que parten del mismo proyecto.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Tests unitarios: 
\family typewriter
selftest.c
\end_layout

\begin_layout Standard
Hemos usado el fichero 
\family typewriter
selftest.c
\family default
, localizado en el directorio 
\family typewriter
programs/test
\family default
, como base para verificar el correcto funcionamiento de los módulos en
 la integración.
 Este programa cuenta el número de módulos comprobados en las variables
 
\family typewriter
suites_tested
\family default
, cuando la comprobación se ha realizado con éxito, y 
\family typewriter
suites_failed
\family default
, en caso contrario.
\end_layout

\begin_layout Standard
Puesto que este fichero está diseñado para ejecutarse de forma independiente
 y no como parte de un programa más grande, hemos tenido que cambiar el
 nombre de la rutina 
\family typewriter
main()
\family default
 por 
\family typewriter
self_test()
\family default
, ya que el primero está reservado como punto de entrada del programa principal.
 El firmware resultante se ejecuta en los siguientes pasos:
\end_layout

\begin_layout Enumerate
Inicialización del sistema, a través de la inicialización de las 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE APPs
\end_layout

\end_inset

 mediante la función 
\family typewriter
DAVE_Init()
\family default
.
 Se inicializan tanto módulos hardware y componentes software, como las
 variables de CMSIS-RTOS.
\end_layout

\begin_layout Enumerate
Configuración de mbedTLS para usar el RTC, tal y como hemos explicado en
 la sección anterior.
\end_layout

\begin_layout Enumerate
Creación de una tarea de ejecución única, que llamará a la función 
\family typewriter
self_test()
\family default
.
\end_layout

\begin_layout Enumerate
Inicialización del núcleo del RTOS, mediante la función 
\family typewriter
osKernelStart()
\family default
.
\end_layout

\begin_layout Standard
Gracias a la interfaz de depuración hemos podido observar la ejecución del
 programa y la evolución de las variables 
\family typewriter
suites_tested
\family default
 y 
\family typewriter
suites_failed
\family default
.
 En este proceso
\begin_inset Note Note
status open

\begin_layout Plain Layout
Gracias a Prometeo,
\end_layout

\end_inset

 hemos podido comprobar que la totalidad de los tests han sido superados
 con éxito, por lo que todos los módulos funcionan correctamente en la integraci
ón llevada a cabo.
\end_layout

\begin_layout Subsubsection
Test funcional: 
\emph on
cliente HTTPS sencillo
\end_layout

\begin_layout Standard
Para comprobar que mbedTLS funciona en su conjunto y que es posible establecer
 comunicación con el exterior, hemos probado el programa de ejemplo 
\family typewriter
ssl_client1.c
\family default
.
 Este programa, que se encuentra en el directorio 
\family typewriter
programs/ssl
\family default
, establece conexión con un servidor HTTPS
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
HTTPS es una extensión del protocolo de aplicación HTTP, que consigue una
 comunicación segura gracias a una capa adicional de SSL o TLS.
 Por este motivo, a veces HTTPS es referido como 
\emph on
HTTP sobre SSL
\emph default
 o 
\emph on
HTTP sobre TLS
\emph default
.
\end_layout

\end_inset

 y realiza una petición 
\family typewriter
HTTP
\begin_inset space ~
\end_inset

GET
\family default
, imprimiendo la respuesta del servidor si todo ha ido bien.
\end_layout

\begin_layout Standard
Tal y como hemos hecho con el test anterior, hemos modificado este programa
 de ejemplo para que funcione como una tarea en RTOS.
 También hemos tenido que ajustar algunas líneas de 
\family typewriter
ssl_client1.c
\family default
.
 En concreto, hemos redefinido 
\family typewriter
SERVER_NAME
\family default
 con el valor 
\begin_inset Quotes fld
\end_inset

https://www.wikipedia.org/
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
Para completar este test, hemos tenido que conectar el miniGW a Internet.
 Esto lo hemos conseguido haciendo uso de un ordenador con GNU/Linux, que
 ha sido configurado para redireccionar el tráfico de red entre el puerto
 Ethernet y una conexión WiFi.
 De esta forma también hemos podido ver los paquetes de datos con el software
 de análisis de red Wireshark.
 Una vez hecho esto, hemos tenido que configurar lwIP y la interfaz Ethernet
 del computador convenientemente, a fin de que las interfaces de ambos dispositi
vos se encuentren en la misma subred IP y para que el computador se use
 como pasarela de red del miniGW.
\end_layout

\begin_layout Standard
Al ejecutar el programa y analizar algunas variables con el depurador, hemos
 podido ver la respuesta del servidor, que ha aceptado nuestra petición
 devolviendo un mensaje del tipo 
\family typewriter
200 OK
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
EXPLICAR UN POCO EL PROGRAMA DE EJEMPLO: QUÉ SE HACE DENTRO? #REF#
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Explicar montaje en el laboratorio: miniGW, router, PC, Inet
\end_layout

\begin_layout Plain Layout
Se ha conseguido recibir una respuesta de servidores en Inet, viendo el
 HTTP 200 OK.
\end_layout

\begin_layout Plain Layout
Hablar de la estructura del programa:
\end_layout

\begin_layout Enumerate
Inicializar biblioteca?
\end_layout

\begin_layout Enumerate
Certificados en variables (fichero .c?)
\end_layout

\begin_layout Enumerate
Cargar certificados
\end_layout

\begin_layout Enumerate
Iniciar conexión
\end_layout

\begin_layout Enumerate
En cada paso se imprime por el puerto serial información útil.
 Si todo va bien, se imprime la respuesta del servidor.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Resolución de problemas
\end_layout

\begin_layout Standard
En la sección anterior hemos presentado los resultados obtenidos al verificar
 la integración de mbedTLS.
 Como hemos comentado, tras ajustar los programas de ejemplo e integrarlos
 en el sistema hemos conseguido que la biblioteca funcione correctamente.
 Sin embargo, hemos tenido algunas dificultades en la integración que han
 ido más allá de las configuraciones expuestas anteriormente.
 En esta sección presentaremos estos problemas y la forma en que los hemos
 solucionado.
\end_layout

\begin_layout Subsubsection
Configuración de CMSIS-RTOS
\end_layout

\begin_layout Standard
Como mencionamos en el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Seguridad-en-sist-empotrados"

\end_inset

, las funciones criptográficas suelen ser computacionalmente costosas, por
 lo que no solo requieren numerosos ciclos de reloj, sino que también hacen
 un uso intensivo de la memoria.
 Por este motivo, para hacer que mbedTLS funcione en nuestro sistema, hemos
 tenido que aumentar la memoria disponible para las tareas en RTOS hasta
 10KB.
 Debe tenerse en cuenta que este valor se refiere exclusivamente a la memoria
 disponible para la pila, es decir, para las variables declaradas 
\begin_inset Note Note
status open

\begin_layout Plain Layout
de forma estática 
\end_layout

\end_inset

en las funciones de mbedTLS y de los programas de ejemplo.
 No tenemos una forma directa de saber cuánto heap está siendo usado por
 las funciones criptográficas, aunque podemos presumir que algo más.
\end_layout

\begin_layout Standard
Otra configuración que hemos tenido que realizar en este punto ha sido increment
ar el número máximo de tareas definidas por el usuario que pueden ejecutarse
 en paralelo, para dar cabida a la tarea de test y a las requeridas por
 lwIP.
\end_layout

\begin_layout Subsubsection
Actualización de lwIP
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Cuál era el problema? Qué versión de lwIP en DAVE?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al tratar de compilar la integración de mbedTLS en 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

, encontramos numerosos errores de compilación.
 Estos errores hacían referencia a funciones inexistentes y tipos de variable
 desconocidos, todos relacionados con la pila de protocolos IP.
 Tras analizar detenidamente el problema, nos dimos cuenta de que la versión
 de lwIP que se incluye con la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE APP
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(vXX.YY) #!
\end_layout

\end_inset

 estaba obsoleta, por lo que fue necesario llevar a cabo una actualización.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hemos actualizado lwIP en el proyecto.
 Esto no es trivial, ya que lwIP trabaja directamente con el hardware Ethernet
 y estaba importado en el proyecto como una
\end_layout

\end_inset

 El proceso de actualización ha requerido analizar la 
\begin_inset ERT
status open

\begin_layout Plain Layout

APP
\end_layout

\end_inset

 en busca del código fuente de lwIP y de los ficheros de configuración,
 para sustituir el directorio donde se encuentra el código fuente de lwIP.
 Hemos usado la versión de lwIP
\begin_inset space ~
\end_inset

2.0.0, por ser la versión estable más reciente en el momento de realizar este
 trabajo.
 Finalmente, hemos tenido que aplicar una serie de cambios a la biblioteca
 y a la configuración proporcionada por la 
\begin_inset ERT
status open

\begin_layout Plain Layout

APP
\end_layout

\end_inset

, en aras de la compatibilidad con el sistema.
\begin_inset Note Note
status open

\begin_layout Plain Layout
, para hacer compatible con el sistema.
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Estos cambios han consistido en modificar algunas definiciones de tipos,
 incluir algunos ficheros de cabecera y resolver conflictos con tipos y
 funciones ya definidos en otros lugares del proyecto.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La metodología de trabajo en este caso ha pasado por analizar los mensajes
 de error que arrojaba el compilador y realizar las correcciones pertinentes
 en el código.
 Puesto que esta actualización debe ser realizada y comprendida posteriormente
 por la empresa, hemos desarrollado un script que lleva a cabo la actualización
 de forma automática.
 Este script no hace más que copiar los ficheros de lwIP
\begin_inset space ~
\end_inset

2.0.0 al directorio correspondiente y aplicar un parche tanto a la biblioteca
 como a la 
\begin_inset ERT
status open

\begin_layout Plain Layout

APP
\end_layout

\end_inset

.
 Este parche ha sido generado usando el comando 
\family typewriter
git
\begin_inset space ~
\end_inset

diff
\family default
, para recoger las diferencias entre, por un lado, la versión del proyecto
 con lwIP recién copiado a la versión 2.0.0, y por otro, con lwIP funcional
 después de ajustar la 
\begin_inset ERT
status open

\begin_layout Plain Layout

APP
\end_layout

\end_inset

.
 Este script tiene que ejecutarse cada vez que se modifica la configuración
 de las 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE APPs
\end_layout

\end_inset

, ya que al generar el código de las mismas se revierten los cambios realizados
 manualmente al código fuente de estas, y, en concreto, se revierten los
 cambios realizados en la 
\begin_inset ERT
status open

\begin_layout Plain Layout

APP
\end_layout

\end_inset

 de lwIP.
\end_layout

\begin_layout Standard
Entre los cambios recogidos en este parche, cabe destacar la inclusión de
 los nuevos archivos de cabecera y el renombramiento de algunos tipos y
 símbolos.
 Además, después de aplicar los cambios mencionados, hemos tenido que actualizar
 las propiedades de compilación para incluir algunas rutas de archivos de
 cabecera, que se encuentran en directorios distintos ahora.
\end_layout

\begin_layout Subsubsection
Configuración de mbedTLS
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Suite
\begin_inset space ~
\end_inset

B VS Suite
\begin_inset space ~
\end_inset

B
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La configuración de mbedTLS expuesta anteriormente es la mínima requerida
 para tener la Suite
\begin_inset space ~
\end_inset

B de la NSA funcionando en nuestro sistema.
 Con esta configuración, el proyecto compila y podemos verificar que los
 módulos de mbedTLS funcionan correctamente.
 Sin embargo, hemos tenido que realizar algunas modificaciones para poder
 realizar el test funcional y conectarnos con el servidor HTTPS.
 En concreto, hemos tenido que habilitar RSA como método para criptografía
 de clave pública e intercambio de claves.
 También hemos tenido que eliminar algunas de las opciones para reducir
 el uso de memoria, ya que estas limitaban las 
\lang english
ciphersuites
\lang spanish
 disponibles y el tamaño de las claves criptográficas.
 Finalmente, hemos tenido que incrementar el tamaño de los búferes de recepción
 a 2048 bytes, pues los paquetes de respuesta del servidor superaban el
 tamaño del búfer (
\family typewriter
MBEDTLS_SSL_MAX_CONTENT_LEN
\begin_inset space \quad{}
\end_inset

2048
\family default
).
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementación-AWS-IoT"

\end_inset

Integración de AWS IoT Device SDK
\end_layout

\begin_layout Standard
Amazon Web Services proporciona un SDK oficial para conectarse con AWS-IoT
 desde cualquier dispositivo.
 Este kit de desarrollo, denominado 
\emph on
AWS
\begin_inset space ~
\end_inset

IoT
\begin_inset space ~
\end_inset

Device
\begin_inset space ~
\end_inset

SDK para
\begin_inset space ~
\end_inset

C
\begin_inset space ~
\end_inset

embebido
\emph default
, está escrito en el lenguaje de programación
\begin_inset space ~
\end_inset

C y puede portarse a cualquier tipo de dispositivo.
 Además, su código fuente está disponible en GitHub 
\begin_inset Newline linebreak
\end_inset

(
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/aws/aws-iot-device-sdk-embedded-C
\end_layout

\end_inset

), de donde podemos descargarlo.
 Toda la información acerca de 
\family sans
AWS
\begin_inset space ~
\end_inset

IoT
\begin_inset space ~
\end_inset

Device
\begin_inset space ~
\end_inset

SDK
\family default
 está disponible en 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://aws.amazon.com/iot/sdk/
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Detalles de la biblioteca
\end_layout

\begin_layout Standard
El Device SDK de AWS
\begin_inset space ~
\end_inset

IoT para
\begin_inset space ~
\end_inset

C
\begin_inset space ~
\end_inset

embebido es una colección de ficheros
\begin_inset space ~
\end_inset

C diseñada para conectar aplicaciones embebidas a la nube de AWS IoT de
 forma segura.
 El SDK incluye clientes de la capa de transporte, una implementación de
 TLS (mbedTLS) y ejemplos de uso.
 También da soporte a características específicas de AWS
\begin_inset space ~
\end_inset

IoT, como una API para acceder al 
\lang english
Device Shadow service
\lang spanish
.
 Se distribuye en la forma de código fuente, de modo que deberá compilarse
 junto con la aplicación deseada, permitiendo la existencia de otras bibliotecas
 y RTOS 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-SDK"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Estructura-ficheros-AWS-IoT"

\end_inset

Estructura de ficheros
\end_layout

\begin_layout Standard
A continuación se presenta la estructura de ficheros del AWS
\begin_inset space ~
\end_inset

IoT Device
\begin_inset space ~
\end_inset

SDK 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-SDK-porting-guide"

\end_inset

.
\end_layout

\begin_layout Description

\family typewriter
certs
\family default
 este directorio es el que albergará los certificados digitales necesarios
 para la autenticación mutua entre el dispositivo y los servidores de AWS
\begin_inset space ~
\end_inset

IoT.
 Aquí se almacenarán el certificado del cliente, su clave privada y la autoridad
 certificadora con la que se verificará la autenticidad del servidor.
\end_layout

\begin_layout Description

\family typewriter
docs
\family default
 documentación de la API del SDK.
\end_layout

\begin_layout Description

\family typewriter
external_libs
\family default
 código fuente de las bibliotecas de las que depende el Device
\begin_inset space ~
\end_inset

SDK: mbedTLS y jsmn
\begin_inset Foot
status open

\begin_layout Plain Layout
Jsmn (pronunciado como 'jasmine') es una biblioteca para dar soporte a JSON
 en C.
 Gracias a su implementación minimalista, se puede integrar fácilmente proyectos
 con limitaciones de recursos, incluyendo sistemas embebidos
\begin_inset Note Note
status open

\begin_layout Plain Layout
 #ref#
\end_layout

\end_inset

.
\end_layout

\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 El código fuente de jsmn siempre está presente.
 El código fuente de mbedTLS solo se incluyen cuando el SDK se descarga
 en formato tarball, por lo que debe incluirse en otro caso.
\end_layout

\end_inset


\end_layout

\begin_layout Description

\family typewriter
include
\family default
 este directorio contiene los archivos de cabecera 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(header files) 
\end_layout

\end_inset

que las aplicaciones deben incluir para hacer uso del SDK.
\end_layout

\begin_layout Description

\family typewriter
src
\family default
 este directorio contiene el código fuente del SDK, incluyendo la biblioteca
 MQTT, el código de la sombra del dispositivo 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(device shadow)
\end_layout

\end_inset

 y otras utilidades.
\end_layout

\begin_layout Description

\family typewriter
platform
\family default
 este directorio contiene los ficheros dependientes de la plataforma, tales
 como los temporizadores (
\lang english
timers
\lang spanish
), la implementación de TLS y la capa de concurrencia.
 Por defecto, el directorio incluye una implementación para GNU/Linux usando
 mbedTLS y pthread.
\end_layout

\begin_layout Description

\family typewriter
samples
\family default
 este directorio contiene algunos programas de ejemplo, así como sus Makefiles.
 Entre estos programas, cabe destacar dos ejemplos: el primero demuestra
 el uso de MQTT, a través de la suscripción y publicación en un 
\lang english
topic
\lang spanish
 de AWS IoT; el segundo muestra cómo interactuar con la sombra del dispositivo
\begin_inset Note Note
status open

\begin_layout Plain Layout
 (device shadow)
\end_layout

\end_inset

.
\end_layout

\begin_layout Description

\family typewriter
tests
\family default
 contiene tests para verificar la funcionalidad del SDK.
\end_layout

\begin_layout Subsection
Portabilidad a otras plataformas
\end_layout

\begin_layout Standard
En esta sección, explicaremos los elementos del AWS
\begin_inset space ~
\end_inset

IoT Device SDK que deben ser portados para hacer que este pueda ejecutarse
 en una nueva plataforma.
 Cabe destacar que las interfaces del SDK siguen un
\begin_inset Note Note
status open

\begin_layout Plain Layout
 modelo de muchos controladores de dispositivo (drivers),
\end_layout

\end_inset

 donde solo los prototipos están definidos por el Device SDK, mientras que
 la implementación corre a cargo del usuario del SDK, que deberá ajustarla
 a la plataforma en uso.
\end_layout

\begin_layout Standard
A continuación se presentan las funcionalidades necesarias para que el Device
 SDK se ejecute correctamente en una plataforma arbitraria 
\begin_inset CommandInset citation
LatexCommand cite
key "AWS-IoT-SDK-porting-guide"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Timer Functions [requerido]
\end_layout

\begin_layout Standard
El SDK necesita una implementación de temporizador para gestionar los tiempos
 de espera de las peticiones MQTT (como 
\emph on
connect
\emph default
 y 
\emph on
subscribe
\emph default
, entre otros comandos), así como para el mantenimiento de la conexión (
\emph on
MQTT keep-alive pings
\emph default
).
 Los temporizadores deberán tener una resolución de milisegundos.
 Puesto que los temporizadores se consultan para comprobar si ha transcurrido
 un determinado intervalo de tiempo, es posible usar un contador de ejecución
 del tipo 
\begin_inset Quotes fld
\end_inset

milisegundos desde el inicio
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Network Functions [requerido]
\end_layout

\begin_layout Standard
Para que la pila de clientes MQTT pueda comunicarse a través de la pila
 de protocolos TCP/IP utilizando una conexión TLS autenticada mutuamente,
 es necesario contar con una implementación de las funciones de red.
 La biblioteca TLS proporciona generalmente la API para el socket TCP subyacente.
\end_layout

\begin_layout Subsubsection
Threading Functions
\end_layout

\begin_layout Standard
La capa de concurrencia proporciona la implementación de 
\emph on
mutexes
\emph default
 usados para operaciones 
\lang english
thread-safe
\lang spanish
.
 Aunque el cliente MQTT utiliza una máquina de estados para controlar las
 operaciones un un entorno multi-hebra, requiere la implementación de los
 mutexes para garantizar la seguridad de las hebras (
\lang english
thread safety
\lang spanish
).
 Esto no es necesario en los casos en que la seguridad de las hebras no
 es importante, por lo que está deshabilitado por defecto.
\end_layout

\begin_layout Section
Integración de AWS IoT Device SDK en el miniGW
\end_layout

\begin_layout Standard
Para llevar a cabo la integración de AWS
\begin_inset space ~
\end_inset

IoT Device SDK, partiremos del proyecto con mbedTLS, sin ningún programa
 de ejemplo.
 Esto ha sido posible gracias al uso de diferentes ramas en git.
 En nuestro caso, hemos separado la rama principal de desarrollo (
\family typewriter
dev
\family default
) de las ramas en las que hemos integrado una prueba del sistema (
\family typewriter
test-
\family default
), de modo que ha sido muy fácil revertir los cambios y llevar a cabo distintas
 líneas de desarrollo y de corrección de errores.
\end_layout

\begin_layout Subsection
Importación de AWS IoT Device SDK al proyecto
\end_layout

\begin_layout Standard
Al igual que en el caso de mbedTLS, tendremos que importar la biblioteca
 al proyecto.
 De nuevo, enlazaremos sus ficheros usando las propiedades del proyecto
 en 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

.
 En este caso, solo necesitamos los directorios 
\family typewriter
include
\family default
, 
\family typewriter
src
\family default
 y 
\family typewriter
external_libs/jsmn
\family default
, por lo que prescindiremos del resto.
 Como ya hemos importado mbedTLS y hemos añadido las rutas de los archivos
 de cabecera, no será necesario introducir la biblioteca en el directorio
 
\family typewriter
external_libs
\family default
, aunque podemos hacerlo para una mejor organización del código fuente.
\end_layout

\begin_layout Standard
Para terminar de importar AWS
\begin_inset space ~
\end_inset

IoT Device SDK y permitir que el compilador encuentre los archivos de cabecera
 referenciados por la biblioteca, será necesario añadir algunas rutas en
 las opciones de compilación.
 En concreto, hemos añadido las siguientes entradas con el flag '
\family typewriter
-I
\family default
', para que se encuentren los archivos de cabecera:
\end_layout

\begin_layout Itemize

\family typewriter
AWS-IoT-SDK/include
\end_layout

\begin_layout Itemize

\family typewriter
AWS-IoT-SDK/external_libs/jsmn
\end_layout

\begin_layout Subsection
Definición de una nueva plataforma
\end_layout

\begin_layout Standard
A diferencia de mbedTLS, el Device SDK de AWS IoT se basa en el modelo de
 controladores, con el que se intenta facilitar la portabilidad a otras
 plataformas.
 Siguiendo este modelo, la biblioteca incluye un directorio 
\family typewriter
platform
\family default
, donde se colocan los ficheros dependientes de plataforma de una forma
 estructurada.
 De esta manera, es posible definir varias plataformas, usándose solo la
 que se incluya en las opciones de compilación del proyecto.
 Otra particularidad de este modelo es que las funciones que se encuentran
 en este directorio son, en realidad, envoltorios (
\lang english
wrappers
\lang spanish
), dentro de los cuáles se llama a las funciones que realizarán el trabajo
 real en cada caso.
 Esta estructura dota a la biblioteca de una gran versatilidad y hace muy
 sencilla su integración en nuevos sistemas.
 Añadiremos el directorio 
\family typewriter
platform/DAVE4_CMSIS_RTOS
\family default
, con la estructura encontrada en 
\family typewriter
platform/Linux
\family default
.
\end_layout

\begin_layout Standard
A continuación se listan los elementos que han debido portarse.
 Como hemos mencionado, será necesario añadir los subdirectorios de 
\family typewriter
port
\family default
 a la ruta de búsqueda de archivos de cabecera.
\end_layout

\begin_layout Subsubsection
Temporizadores
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Estas funciones se encargan de los 
\lang english
timeouts
\lang spanish
.
 Rellenaremos los 
\lang english
wrappers
\lang spanish
 encontrados en el fichero 
\family typewriter
timer.c
\family default
 e incluiremos los archivos de cabecera necesarios en 
\family typewriter
timer_platform.h
\family default
, ambos ficheros encontrados en el directorio 
\family typewriter
platform/DAVE4_CMSIS_RTOS/common
\family default
.
 Las funciones definidas harán uso de SysTick, disponible a través de CMSIS-RTOS
, para proporcionar las funcionalidades requeridas.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Concurrencia
\end_layout

\begin_layout Standard
Al igual que con los temporizadores, completaremos las funciones del fichero
 
\family typewriter
threads.c
\family default
 y añadiremos las cabecereas necesarias a 
\family typewriter
threads_platform.h
\family default
, ambos en el directorio 
\family typewriter
platform/DAVE4_CMSIS_RTOS/pthreads
\family default
.
 En esta ocasión, usaremos los mutexes proporcionados por CMSIS-RTOS para
 conseguir las funcionalidades necesarias.
\end_layout

\begin_layout Subsubsection
Conectividad de red
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El directorio 
\family typewriter
platform/DAVE4_CMSIS_RTOS/mbedtls
\family default
 contiene las funciones que se encargan de inicializar los contextos TLS
 y usar los sockets de manera conveniente.
 Puesto que AWS
\begin_inset space ~
\end_inset

IoT Device SDK usa mbedTLS por defecto, no ha habido que realizar grandes
 cambios aquí.
 Simplemente, hemos tenido que modificar algunas líneas de 
\family typewriter
network_mbedtls_wrapper.c
\family default
, en concreto, la función 
\family typewriter
iot_tls_init()
\family default
, para hacer que no cargue los certificados a partir de ficheros, sino que
 
\emph on
parsee
\emph default
 certificados contenidos en variables directamente.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\noindent

\family typewriter
aws_iot_config.h
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El Device SDK de AWS IoT requiere de un archivo de configuración nombrado
 
\family typewriter
aws_iot_config.h
\family default
 que debe ser accesible al compilador.
 Este fichero, que contiene tanto información sobre la conexión como configuraci
ones de los módulos, se incluye en algunas de las cabeceras de estos mismos
 módulos.
 Por ello, tendremos que importar este fichero en nuestro proyecto, copiándolo
 de cualquiera de los ejemplos que se proveen (por ejemplo, en 
\family typewriter
samples/linux/shadow_sample
\family default
).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Configuración de AWS IoT SDK
\end_layout

\begin_layout Standard
Llegados a este punto tenemos una integración de AWS IoT Device SDK que
 compila en el sistema, y cuyas funciones pueden ser usadas desde las distintas
 tareas, siempre y cuando se incluyan los archivos de cabecera al inicio
 de su código fuente.
 A continuación llevaremos a cabo algunas configuraciones que serán necesarias
 para establecer una comunicación con la nube de Amazon.
\end_layout

\begin_layout Subsubsection
Certificados digitales y clave del dispositivo
\end_layout

\begin_layout Standard
Como explicamos en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:Estructura-ficheros-AWS-IoT"

\end_inset

, existe un directorio destinado a albergar los certificados y claves que
 el dispositivo necesita para llevar a cabo la autenticación mutua con el
 servidor.
 Normalmente, estos certificados se almacenarían como ficheros en formato
 
\family typewriter
.pem
\family default
 o 
\family typewriter
.der
\family default
, y serían abiertos por mbedTLS accediendo al sistema de ficheros.
 Sin embargo, nuestro sistema no cuenta con dicho sistema de ficheros, por
 lo que almacenaremos los certificados y la clave en unas constantes, que
 se definirán en un fichero 
\family typewriter
.c
\family default
.
 De esta forma, los certificados y claves permanecerán almacenados directamente
 en el firmware (
\lang english
hardcoded
\lang spanish
) por lo que será imposible acceder a ellos si no se dispone de una interfaz
 de depuración
\begin_inset Foot
status open

\begin_layout Plain Layout
Aun con el hardware necesario para la depuración, existen formas de proteger
 el código contra lectura, de forma que la clave privada sea realmente inaccesib
le.
\end_layout

\end_inset

.
 Por simplicidad, las constantes de este fichero no serán más que cadenas
 de caracteres ASCII con el contenido literal de los certificados y de la
 clave privada en formato PEM 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc4648-Base64-encoding,rfc7468-PKIX-Encoding"

\end_inset

.
\end_layout

\begin_layout Standard
Este fichero, que llamaremos 
\family typewriter
certificates.c
\family default
, será el responsable de almacenar el certificado del cliente (
\family typewriter
client_cert
\family default
), su clave privada (
\family typewriter
client_key
\family default
) y la autoridad certificadora con la que se verificará la autenticidad
 del servidor (
\family typewriter
ca_root
\family default
).
 Estas constantes serán usadas posteriormente por el programa de ejemplo
 a la hora de establecer la conexión con el servidor.
 El contenido de estas constantes se obtendrá de la consola de AWS IoT,
 como se explicará en la siguiente sección.
\end_layout

\begin_layout Subsubsection
\noindent

\family typewriter
aws_iot_config.h
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Configuracion llevada a cabo en conjunto con la consola de AWS IoT.
 Para el test realizado, se ha considerado que el miniGW es un dispositivo
 (normalmente no sería así, sino que cada sensor sría un dispositivo)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Una vez integrada la biblioteca, tendremos que configurar algunos parámetros
 para conectarnos con los servidores de AWS.
 En concreto, necesitaremos los siguientes elementos para llevar a cabo
 la conexión.
 Estos elementos serán modificados en el fichero 
\family typewriter
aws_iot_config.h
\family default
, el cuál se importará al proyecto a partir del programa de ejemplo 
\family typewriter
subscribe_publish_sample
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
En realidad, los ficheros de configuración de todos los programas de ejemplo
 son idénticos.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Como se vio en el 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:AWS-IoT"

\end_inset

, es necesario que el dispositivo tenga algunos parámetros de conexión de
 los servidores de AWS.
 Modificaremos las siguientes línas de 
\family typewriter
aws_iot_config.h
\family default
 con los parámetros obtenidos de la consola de AWS
\begin_inset space ~
\end_inset

IoT.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Más detalles en la obtención de estos parámetros se explicarán en la sección
 ###
\end_layout

\end_inset

.
\end_layout

\begin_layout Description

\family typewriter
AWS_IOT_MQTT_HOST
\family default
 URL del 
\lang english
personal endpoint
\lang spanish
 asociado a AWS IoT.
 Puede encontrarse en la pestaña 
\lang english
Settings
\lang spanish
 de la consola, y tiene el formato 
\family typewriter
xxxxxxx.region-key.amazonaws.com
\family default
.
\end_layout

\begin_layout Description

\family typewriter
AWS_IOT_MQTT_PORT
\family default
 puerto para la conexión MQTT.
 Dejaremos el valor por defecto (8883).
\end_layout

\begin_layout Description

\family typewriter
AWS_IOT_MQTT_CLIENT_ID
\family default
 ID del cliente MQTT, que deberá ser distinto para cada dispositivo.
 Este ID será una cadena alfanumérica definida en producción.
 Puesto que en nuestro test solo tendremos un dispositivo, podemos dejarlo
 en su valor por defecto.
\end_layout

\begin_layout Description

\family typewriter
AWS_IOT_MY_THING_NAME
\family default
 nombre del dispositivo virtual definido en la plataforma.
\end_layout

\begin_layout Description

\family typewriter
AWS_IOT_ROOT_CA_FILENAME
\family default
 variable o constante donde se almacena el certificado digital de la autoridad
 certificadora, con la que el dispositivo autenticará a los servidores de
 AWS
\begin_inset space ~
\end_inset

IoT.
 Nótese que por los cambios realizados en la biblioteca, aquí no se indicará
 un nombre de archivo, sino el contenido del mismo.
 En este caso, será la constante 
\family typewriter
ca_root
\family default
, definida en la sección anterior.
\end_layout

\begin_layout Description

\family typewriter
AWS_IOT_CERTIFICATE_FILENAME
\family default
 variable o constante donde se almacena el certificado digital del dispositivo.
 Este certificado estará asociado al dispositivo virtual definido en la
 consola.
 Nótese que por los cambios realizados en la biblioteca, aquí no se indicará
 un nombre de archivo, sino el contenido del mismo.
 En este caso, será la constante 
\family typewriter
client_cert
\family default
, definida en la sección anterior.
\end_layout

\begin_layout Description

\family typewriter
AWS_IOT_PRIVATE_KEY_FILENAME
\family default
 variable o constante donde se almacena la clave privada del dispositivo.
 Nótese que por los cambios realizados en la biblioteca, aquí no se indicará
 un nombre de archivo, sino el contenido del mismo.
 En este caso, será la constante 
\family typewriter
client_key
\family default
, definida en la sección anterior.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El resto de parámetros definidos en el fichero se han dejado intactos, con
 sus valores por defecto.
 Estos parámetros controlan la configuración de búferes, uso de la sombra
 y otros parámetros de conexión.
 Además, incluiremos las constantes de los certificados digitales como 
\family typewriter
extern
\family default
, para que las mismas puedan ser usadas donde se requiera.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:AWS-IoT-Verificacion-integracion"

\end_inset

Verificación de la integración
\end_layout

\begin_layout Standard
A continuación comprobaremos que la integración de AWS IoT Device SDK se
 comporta de la manera esperada, realizando una conexión con AWS IoT y comproban
do que existe una transmisión de datos.
 Para ello, será necesario establecer un escenario de prueba, que definiremos
 a continuación.
 Solo llevaremos a cabo dos tests funcionales, ejecutando el código de los
 ejemplos 
\family typewriter
subscribe_publish
\family default
 y 
\family typewriter
shadow
\family default
 que se proporcionan en el directorio 
\family typewriter
sample
\family default
.
 Estos tests requerirán que configuremos de forma conjunta la plataforma
 y el dispositivo.
 En esta sección explicaremos las configuraciones requeridas por estos tests
 en particular, que van un poco más allá de las expuestas en el epígrafe
 anterior.
\begin_inset Note Note
status open

\begin_layout Plain Layout
 (no se han contado antes porque en la sección anterior se habla de configuracio
nes que hacen referencia exclusivamente al SDK y que serán necesarias en
 cualquier setup, por lo que el fichero de configuración del SDK ya queda
 presentado)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
El test funcional requiere tener configurado correctamente tanto el miniGW
 como el servicio AWS IoT.
 Estas configuraciones deben ser coherentes entre sí.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
En esta sección sólo hablaremos de configuración.
 Los resultados se expondrán en el capítulo #Resultados#.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Disposición de los elementos de prueba
\end_layout

\begin_layout Standard
La configuración de prueba que llevaremos a cabo es la que podemos ver,
 de forma esquemática, en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Configuración-de-prueba-AWS-IoT"

\end_inset

.
 Como se muestra en la misma, conectaremos el miniGW a Internet a través
 de un computador GNU/Linux que hará las veces de puerta de enlace, gracias
 a que lo configuraremos para realizar 
\lang english
IP forwarding
\lang spanish
.
 Esta conexión será monitorizada con Wireshark, donde veremos los paquetes
 transmitidos en ambas direcciones.
 Gracias a este software, podremos comprobar si se lleva a cabo la conexión,
 en qué puntos se producen errores en la misma, si hay paquetes erróneos,
 etc.
 En este mismo computador tendremos una terminal serial para visualizar
 la salida de las trazas de depuración definidas en el firmware.
 Esta conexión serial se usa para comprobar que se realizan todos los pasos
 correctamente (inicialización del RTOS, inicialización de los módulos,
 distintos pasos de la conexión, envío y recepción de mensajes, etc.), pero
 no está configurada para interactuar con el miniGW.
\end_layout

\begin_layout Standard
Por otro lado, tendremos un computador con la interfaz de depuración de
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

, con la que cargaremos el firmware cada vez que hagamos cambios.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE
\end_layout

\end_inset

 también nos permitirá usar las herramientas de depuración, como puntos
 de ruptura (
\lang english
breakpoints
\lang spanish
), con las que podremos analizar los problemas con más detalle.
 En este computador también tendremos abierta la consola de AWS IoT, desde
 la que veremos si la conexión se ha establecido y podremos analizar el
 intercambio de mensajes MQTT.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/test-setup-final.eps
	lyxscale 70
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Configuración-de-prueba-AWS-IoT"

\end_inset

Configuración de prueba final.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Añadir debugger en el esquema!! Poner este esquema en el capítulo anterior?
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Configuración conjunta de la consola de AWS IoT y del Device SDK
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
En esta sección trataremos la creación y configuración de un dispositivo
 en AWS IoT Console.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como hemos indicado anteriormente, para conectar el dispositivo a la Nube,
 tendremos que definir un dispositivo virtual en la plataforma.
 También tendremos que asignarle un certificado digital y una política de
 acceso.
\end_layout

\begin_layout Standard
En primer lugar, deberemos crear el dispositivo virtual en la plataforma.
 Tendremos que definir los distintos parámetros de nuestro dispositivo,
 como su nombre, que tendremos que definir de igual manera en el dispositivo
 físico (
\family typewriter
AWS_IOT_MY_THING_NAME
\family default
).
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
será fundamental para conectarnos al mismo.
\end_layout

\end_inset

 Este es, en realidad, el único campo requerido.
 Sin embargo, podemos definir algunos atributos, como la versión del 
\lang english
firmware
\lang spanish
 o los sensores que implementa el dispositivo.
 Recordemos que estos atributos sirven para describir el dispositivo, y
 no deben confundirse con el estado del mismo.
 De forma alternativa, nuestro dispositivo podría heredar los atributos
 de un tipo que hayamos definido previamente.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../../../Internet-de-las-Cosas/doc/img/platform-08-interact.png
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Thing-properties-1"

\end_inset

Propiedades del dispositivo registrado.
 Pestaña 
\family sans
\lang english
Interact
\family default
\lang spanish
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
En la consola de AWS
\begin_inset space ~
\end_inset

IoT, podemos acceder a la pestaña 
\family sans
\lang english
Interact
\family default
\lang spanish
 del dispositivo 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(figura
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Thing-properties-1"

\end_inset

) 
\end_layout

\end_inset

, donde se mostrará la información que tendremos que copiar para configurar
 el fichero 
\family typewriter
aws_iot_config.h
\family default
.
 En concreto, aquí se muestra la información sobre el 
\lang english
endpoint
\lang spanish
, con la que deberá definirse el símbolo 
\family typewriter
AWS_IOT_MQTT_HOST
\family default
.
\end_layout

\begin_layout Standard
El siguiente paso será crear un certificado.
 Es imprescindible que al crear el certificado se descargue la clave privada
 del mismo, ya que al cerrar el diálogo de descarga la clave privada será
 eliminada de la plataforma.
 También tendremos que descargar el certificado raíz (
\lang english
CA root
\lang spanish
), disponible desde la misma pestaña.
\end_layout

\begin_layout Standard
A continuación, tendremos que asociar este certificado con el dispositivo
 y con una política de acceso.
 Como se trata de un test, definiremos una política de acceso bastante laxa,
 en la que el dispositivo podrá interactuar libremente con todos los elementos
 IoT de nuestra cuenta de AWS.
 Para ello, añadiremos a la política la acción 
\family typewriter
iot:*
\family default
.
 Llegados a este punto, habremos terminado de configurar la plataforma.
\end_layout

\begin_layout Subsubsection
Verificación de la conexión
\end_layout

\begin_layout Standard
Al igual que hicimos con mbedTLS, usaremos los programas de ejemplo del
 Device SDK de AWS IoT para comprobar que el funcionamiento es el esperado.
 En concreto, usaremos los ejemplos 
\family typewriter
subscribe_publish_sample
\family default
 y 
\family typewriter
shadow_sample
\family default
.
 También aquí tendremos que modificar el ejemplo para que su código se ejecute
 dentro de una tarea de RTOS.
 En este caso, los pasos seguidos por el firmware en su ejecución son los
 siguientes:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Inicialización del sistema, a través de la inicialización de las 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DAVE APPs
\end_layout

\end_inset

 mediante la función 
\family typewriter
DAVE_Init()
\family default
.
 Se inicializan tanto módulos hardware y componentes software, como las
 variables de CMSIS-RTOS.
\end_layout

\begin_layout Enumerate
Configuración de mbedTLS para usar el RTC.
\end_layout

\begin_layout Enumerate
Creación de una tarea de una única ejecución, que llamará a la función 
\family typewriter
shadow_sample()
\family default
.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Explicar el ejemplo, o hacer referencia a la explicación!
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Llamada a la instrucción de inicialización del núcleo de CMSIS-RTOS
\family typewriter
 osKernelStart()
\family default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{sloppypar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La ejecución de este programa tiene como resultado el intercambio de mensajes
 MQTT entre el miniGW y la Nube.
 En primer lugar se lleva a cabo la ejecución de un handshake TLS, que hemos
 podido observar usando Wireshark.
 Tras el handshake, los datos de aplicación se envían encriptados, por lo
 que no podemos observar el contenido de los paquetes.
 En cambio, podemos comprobar que produce una comunicación con la Nube observand
o los mensajes a través de la consola de AWS
\begin_inset space ~
\end_inset

IoT.
 Para ello nos dirigiremos a la pestaña 
\family sans
\lang english
Activity
\family default
\lang spanish
, donde podremos ver los mensajes MQTT que producirán las sucesivas actualizacio
nes de la sombra
\begin_inset Note Note
status open

\begin_layout Plain Layout
 , como se muestra en la #missing-figure#
\end_layout

\end_inset

.
 Para observar el estado actual del dispositivo, podemos consultar su sombra
 en la pestaña 
\family sans
\lang english
Shadow
\family default
\lang spanish
.
\begin_inset Note Note
status open

\begin_layout Plain Layout
 tal y como se muestra en la 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Thing-properties"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../../../Internet-de-las-Cosas/doc/img/platform-10-shadow.png
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Thing-properties"

\end_inset

Propiedades del dispositivo registrado.
 Pestaña 
\family sans
\lang english
Shadow
\family default
\lang spanish
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Sustituir por imagen con el contenido real del miniGW.
 COHERENCIA DE IMÁGENES!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Como podemos comprobar
\end_layout

\end_inset

Finalmente, tras este proceso de integración, el miniGW puede comunicarse
 con los servidores AWS IoT.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Imágenes? Capturas de pantalla???
\end_layout

\end_inset


\end_layout

\begin_layout Section
Resolución de problemas
\end_layout

\begin_layout Standard
Como no podía ser de otra manera, la integración del Device SDK ha supuesto
 resolver algunos conflictos.
 La mayoría de ellos tienen que ver con el uso de memoria, ya que trabajamos
 en un entorno con recursos muy reducidos.
 A continuación los exponemos con detalle.
\end_layout

\begin_layout Subsubsection
Configuración de CMSIS-RTOS
\end_layout

\begin_layout Standard
De nuevo, hemos necesitado más memoria para CMIS-RTOS.
 Esto se debe a que en esta ocasión estamos verificando un certificado
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status open

\begin_layout Plain Layout
Con la conexión HTTPS no se verificaba el certificado del servidor #?
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
seguro que es por esto?
\end_layout

\end_inset

 y estamos autenticando al dispositivo de cara al servidor, lo que supone
 la firma de un 
\lang english
challenge
\lang spanish

\begin_inset Note Note
status open

\begin_layout Plain Layout
de nuevo: seguro?
\end_layout

\end_inset

.
 Estas operaciones requieren de mucha memoria, por lo que tendremos que
 incrementar el tamaño de la pila a 17KB.
 De nuevo, mencionamos que este valor no tiene nada que ver con el heap,
 solo la pila se está aumentando aquí.
\end_layout

\begin_layout Subsubsection
Modificación del mapa de memoria
\end_layout

\begin_layout Standard
En mbedTLS, el uso de enteros de precisión múltiple (MPI), también conocidos
 como BigNum, hace uso de la memoria dinámica
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
También se puede configurar mbedTLS para usar pools de memoria reservados
 de forma estática.
 En el caso que nos ocupa, al no tratarse de un sistema crítico, hemos preferido
 usar el heap gestionado por 
\lang english
newlib
\lang spanish
 y el 
\lang english
linker script
\lang spanish
.
\end_layout

\end_inset

.
 Sin embargo, el heap presente en el sistema con la configuración predefinida
 es demasiado pequeño para la verificación de certificado con claves de
 clave asimétrica tan largas.
 Para que las aplicaciones probadas se ejecuten correctamente, es necesario
 un heap de al menos 35KB.
 Esta heap será necesario para el proceso de validación del certificado
 y el proceso de firma en la autenticación mutua 
\begin_inset Note Note
status open

\begin_layout Plain Layout
copiado del report ;)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Por defecto, el heap definido en el proyecto usa la memoria restante en
 uno de los tres módulos RAM presentes en el XMC (ver 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:XMC-block-diagram"

\end_inset

).
 Para expandir la memoria usada por el heap, ha sido necesario modificar
 el comportamiento de 
\family typewriter
malloc()
\family default
.
 En concreto, se ha modificado la función 
\family typewriter
_sbrk()
\family default
 del fichero 
\family typewriter
syscalls.c
\family default
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(de qué biblioteca es esto?)
\end_layout

\end_inset

, para permitirle reservar memoria en cualquiera de los tres bancos disponibles.
 Este fichero depende de las variables 
\family typewriter
Heap_BankX_Start
\family default
 y 
\family typewriter
Heap_BankX_End
\family default
, que han tenido que definirse en el 
\lang english
linker script
\lang spanish
.
 La definición de estas variables ha sido directa, a partir de la definición
 del primer bloque de heap.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
es el culpable! -> Certificados con muchos bits! era eso, no?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Cómo era el linkerscript original? Bancos de memoria , cuánto espacio para
 qué cosa...
\end_layout

\begin_layout Plain Layout
Cómo se queda el linkerscript: cuánto espacio
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Sockets BSD
\end_layout

\begin_layout Standard
Al tratar de compilar el proyecto, hemos encontrado algunos conflictos con
 las funciones 
\family typewriter
connect
\family default
, 
\family typewriter
read
\family default
 y 
\family typewriter
write
\family default
, que estaban definidos en distintos lugares.
 Para solucionarlo, hemos modificado el fichero 
\family typewriter
aws_iot_mqtt_client.h
\family default
 para asegurar que se usa la implementación proporcionada por lwIP.
\begin_inset Note Note
status open

\begin_layout Plain Layout
#undef connect #undef read #undef write (se deben usar ¿los de lwIP?, pero
 estos están definidos en algún otro sitio y producen conflicto, no?)
\begin_inset Note Note
status open

\begin_layout Plain Layout
INVESTIGAR BIEN!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset Note Note
status open

\begin_layout Subsubsection
Ciphersuites?
\end_layout

\begin_layout Plain Layout
configurados en config.h de mbedTLS para tener una versión compatible.
 o venía ya hecho?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
REVISAR QUE LOS CIPHERSUITES DEFINIDOS EN NSA SUITE B SEAN LOS RECOMENDADOS
 POR AWS
\end_layout

\end_inset


\end_layout

\end_body
\end_document
